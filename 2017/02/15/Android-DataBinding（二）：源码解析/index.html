<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,Java,源码分析," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="准备工作看源码有两种方式可供选择，第一种是直接将整个AOSP下载下来，然后自行编译，这种方法的好处看源码不会遇到爆红，整个代码结构一目了然，缺点就是占用空间大，下载时间长，编译坑比较多……第二种方法是直接用sdk目录之下的。在这里笔者采用第一种方法，下载并编译AOSP请见：Mac OS Sierra下编译Android 7.1.1。
用Android Studio导入安卓源码之后，在Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android DataBinding（二）：源码解析">
<meta property="og:url" content="http://yoursite.com/2017/02/15/Android-DataBinding（二）：源码解析/index.html">
<meta property="og:site_name" content="Stephen's blog">
<meta property="og:description" content="准备工作看源码有两种方式可供选择，第一种是直接将整个AOSP下载下来，然后自行编译，这种方法的好处看源码不会遇到爆红，整个代码结构一目了然，缺点就是占用空间大，下载时间长，编译坑比较多……第二种方法是直接用sdk目录之下的。在这里笔者采用第一种方法，下载并编译AOSP请见：Mac OS Sierra下编译Android 7.1.1。
用Android Studio导入安卓源码之后，在Android">
<meta property="og:image" content="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%889.24.48.png">
<meta property="og:image" content="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1487508874434&di=188c6fb1e6fe4e69bf1cab8c82844595&imgtype=0&src=http%3A%2F%2Fwanzao2.b0.upaiyun.com%2Fsystem%2Fpictures%2F31274020%2Foriginal%2F1449639129_500x500.png">
<meta property="og:image" content="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-19%20%E4%B8%8B%E5%8D%888.36.08.png">
<meta property="og:updated_time" content="2017-02-20T07:06:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android DataBinding（二）：源码解析">
<meta name="twitter:description" content="准备工作看源码有两种方式可供选择，第一种是直接将整个AOSP下载下来，然后自行编译，这种方法的好处看源码不会遇到爆红，整个代码结构一目了然，缺点就是占用空间大，下载时间长，编译坑比较多……第二种方法是直接用sdk目录之下的。在这里笔者采用第一种方法，下载并编译AOSP请见：Mac OS Sierra下编译Android 7.1.1。
用Android Studio导入安卓源码之后，在Android">
<meta name="twitter:image" content="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%889.24.48.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/02/15/Android-DataBinding（二）：源码解析/"/>





  <title> Android DataBinding（二）：源码解析 | Stephen's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Stephen's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/15/Android-DataBinding（二）：源码解析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android DataBinding（二）：源码解析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-15T15:27:19+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/15/Android-DataBinding（二）：源码解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/15/Android-DataBinding（二）：源码解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>看源码有两种方式可供选择，第一种是直接将整个AOSP下载下来，然后自行编译，这种方法的好处看源码不会遇到爆红，整个代码结构一目了然，缺点就是占用空间大，下载时间长，编译坑比较多……第二种方法是直接用sdk目录之下的。在这里笔者采用第一种方法，下载并编译AOSP请见：<a href="http://zsrr.coding.me/2017/02/16/Mac-OS-Sierra%E4%B8%8B%E7%BC%96%E8%AF%91Android-7-1-1/" target="_blank" rel="external">Mac OS Sierra下编译Android 7.1.1</a>。</p>
<p>用Android Studio导入安卓源码之后，在Android视图，java包下会看到这几个包：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%889.24.48.png" alt=""><br>这就是我们要分析的源码了。</p>
<p>如果要采用第二种方法，platform请升到最新，不然可能出现当前platform找不到databinding的源码的问题，具体步骤如下：    </p>
<ul>
<li>随便新建一个Android项目</li>
<li>找到sdk文件夹，依次进入sources，android-xx（最新的），android文件夹，将里面的databinding文件夹复制到刚才新建的安卓项目当中。</li>
<li>更改databinding文件夹中所有java文件的包名。</li>
</ul>
<p>另外，如果你是Windows用户，那么请用<a href="https://www.sourceinsight.com/download/" target="_blank" rel="external">Source Insight</a>查看安卓源码。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="DataBindingUtil"><a href="#DataBindingUtil" class="headerlink" title="DataBindingUtil"></a>DataBindingUtil</h2><p>这是数据绑定的入口类，一般用它来创建相应的Binding类，我们由此开始分析。</p>
<p>先看最常见的用法：</p>
<pre><code>public static &lt;T extends ViewDataBinding&gt; T inflate(LayoutInflater inflater, int layoutId, ViewGroup parent, boolean attachToParent);
public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId);
public static &lt;T extends ViewDataBinding&gt; T bind(View root);
</code></pre><p>第一个方法最终调用的是<strong>bind(DataBindingComponent bindingComponent, View root, int layoutId)</strong>方法（如果attachToParent设置为false的话），这个方法的定义为：</p>
<pre><code>static &lt;T extends ViewDataBinding&gt; T bind(DataBindingComponent bindingComponent, View root,
        int layoutId) {
    return (T) sMapper.getDataBinder(bindingComponent, root, layoutId);
}
</code></pre><p>直接交给了sMapper来处理，sMapper是一个类型为DataBinderMapper的静态成员，其getDataBinder方法会根据xml文件生成的ViewDataBinding子类动态改变，这是笔者的getDataBinder源码（源自另一个已经写好的安卓项目）：</p>
<pre><code>public android.databinding.ViewDataBinding getDataBinder(android.databinding.DataBindingComponent bindingComponent, android.view.View view, int layoutId) {
    switch(layoutId) {
            case com.stephen.learning.R.layout.item_view:
                return com.stephen.learning.databinding.ViewHolderBinding.bind(view, bindingComponent);
            case com.stephen.learning.R.layout.activity_data_binding:
                return com.stephen.learning.databinding.ImageViewBinding.bind(view, bindingComponent);
    }
    return null;
}
</code></pre><p>可以看到，DataBinderMapper类将行为委托给了实际产生的ViewDataBinding的子类上，其具体的bind方法的实现，我们稍后再谈。现在再看<strong>setContentView</strong>方法，此方法的实现：</p>
<pre><code>public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId) {
    return setContentView(activity, layoutId, sDefaultComponent);
}

public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId,
        DataBindingComponent bindingComponent) {
    activity.setContentView(layoutId);
    View decorView = activity.getWindow().getDecorView();
    ViewGroup contentView = (ViewGroup) decorView.findViewById(android.R.id.content);
    return bindToAddedViews(bindingComponent, contentView, 0, layoutId);
}
</code></pre><p>bindToAddedViews方法的实现：</p>
<pre><code>private static &lt;T extends ViewDataBinding&gt; T bindToAddedViews(DataBindingComponent component,
        ViewGroup parent, int startChildren, int layoutId) {
    final int endChildren = parent.getChildCount();
    final int childrenAdded = endChildren - startChildren;
    if (childrenAdded == 1) {
        final View childView = parent.getChildAt(endChildren - 1);
        return bind(component, childView, layoutId);
    } else {
        final View[] children = new View[childrenAdded];
        for (int i = 0; i &lt; childrenAdded; i++) {
            children[i] = parent.getChildAt(i + startChildren);
        }
        return bind(component, children, layoutId);
    }
}
</code></pre><p>由上述代码可以发现，setContentView先获得activity中DecorView中的FrameLayout，再将其作为参数传入<strong>bindToAddedViews</strong>方法，此方法先判断parent当中子视图的数目，一般情况下我们activity的xml文件只有一个RelativeLayout或者LinearLayout的根元素，所以子视图一般只有一个，于是又开始调用bind方法，重新回到上面的流程。</p>
<p>下面分析<strong>bind(View root)</strong>方法：</p>
<pre><code>public static &lt;T extends ViewDataBinding&gt; T bind(View root) {
    return bind(root, sDefaultComponent);
}

public static &lt;T extends ViewDataBinding&gt; T bind(View root,
        DataBindingComponent bindingComponent) {
    T binding = getBinding(root);
    if (binding != null) {
        return binding;
    }
    Object tagObj = root.getTag();
    if (!(tagObj instanceof String)) {
        throw new IllegalArgumentException(&quot;View is not a binding layout&quot;);
    } else {
        String tag = (String) tagObj;
        int layoutId = sMapper.getLayoutId(tag);
        if (layoutId == 0) {
            throw new IllegalArgumentException(&quot;View is not a binding layout&quot;);
        }
        return (T) sMapper.getDataBinder(bindingComponent, root, layoutId);
    }
}
</code></pre><p>bind方法先调用<strong>getBinding</strong>方法，<strong>getBinding</strong>方法直接调用了ViewDataBinding的静态<strong>getBinding</strong>方法，这个方法之后分析ViewDataBinding的时候再讲。如果得到的binding是空的，那就创建一个binding并且返回，创建过程是先得到view的tag，这个tag是个String类型。例如ListView的item的xml文件名为item<em> view，里面的根元素是layout标签，那么我们用LayoutInflater类inflate出来的view便有一个String类型的Tag，并且值为：”layout/item</em> view_ 0”。好，找到tag之后，便调用DataBinderMapper类的<strong>getLayoutId</strong>方法，这个方法也是根据xml文件的定义自动生成的，笔者的方法定义如下所示：</p>
<pre><code>int getLayoutId(String tag) {
    if (tag == null) {
        return 0;
    }
    final int code = tag.hashCode();
    switch(code) {
        case -1223782307: {
            if(tag.equals(&quot;layout/item_view_0&quot;)) {
                return com.stephen.learning.R.layout.item_view;
            }
            break;
        }
        case 1514339820: {
            if(tag.equals(&quot;layout/activity_data_binding_0&quot;)) {
                return com.stephen.learning.R.layout.activity_data_binding;
            }
            break;
        }
    }
    return 0;
}
</code></pre><p>嗯……这么拿hashCode做判断再拿tag做判断的写法比较智障啊……<br>拿到layoutId之后，最后调用sMapper的<strong>getDataBinder</strong>，结束。</p>
<h2 id="DataBinderMapper"><a href="#DataBinderMapper" class="headerlink" title="DataBinderMapper"></a>DataBinderMapper</h2><p>这个类随着我们对xml的定义改变而改变，它的职责其实在上文对DataBindingUtil类的分析中已经展现：  </p>
<ul>
<li>作为DataBindingUtil和ViewDataBinding类的中介类</li>
<li>根据tag得到对应的id</li>
</ul>
<p>此外，它的内部还维护一个InnerBrLookUp的静态类，此静态类又维护一个String类型的数组，用来将BR类的id转成对应的String，通常用作打log，这里不再细谈。</p>
<h2 id="BaseObservable"><a href="#BaseObservable" class="headerlink" title="BaseObservable"></a>BaseObservable</h2><p>把此类放在这个位置是为了之后介绍<strong>ViewDataBinding</strong>类。</p>
<p>此类的实现相当简单：</p>
<pre><code>public class BaseObservable implements Observable {
    private transient PropertyChangeRegistry mCallbacks;

    public BaseObservable() {
    }

    @Override
    public synchronized void addOnPropertyChangedCallback(OnPropertyChangedCallback callback) {
        if (mCallbacks == null) {
            mCallbacks = new PropertyChangeRegistry();
        }
        mCallbacks.add(callback);
    }

    @Override
    public synchronized void removeOnPropertyChangedCallback(OnPropertyChangedCallback callback) {
        if (mCallbacks != null) {
            mCallbacks.remove(callback);
        }
    }


    public synchronized void notifyChange() {
        if (mCallbacks != null) {
            mCallbacks.notifyCallbacks(this, 0, null);
        }
    }

    public void notifyPropertyChanged(int fieldId) {
        if (mCallbacks != null) {
            mCallbacks.notifyCallbacks(this, fieldId, null);
        }
    }
}
</code></pre><p>将所有的职责都托付给了内部成员<strong>mCallbacks</strong>身上。</p>
<h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p><strong>BaseObservable</strong>实现了<strong>Observable</strong>接口。先看一下官方文档对此接口的介绍：</p>
<blockquote>
<p>Observable classes provide a way in which data bound UI can be notified of changes.</p>
</blockquote>
<p>简而言之，这个接口就是为了保证UI元素和数据之间的双向绑定，其内部有两个方法：</p>
<pre><code>void addOnPropertyChangedCallback(OnPropertyChangedCallback callback);
void removeOnPropertyChangedCallback(OnPropertyChangedCallback callback);
</code></pre><p>OnPropertyChangedCallback是一个抽象类，其内部只有一个抽象方法:</p>
<pre><code>public abstract void onPropertyChanged(Observable sender, int propertyId);
</code></pre><p>sender就是持有此类的<strong>Observable</strong>类，propertyId是绑定的数据id。当我们用<strong>Bindable</strong>注解标注一个getter时，自动生成的<strong>BR</strong>类会生成此id。</p>
<h3 id="CallbackRegistry"><a href="#CallbackRegistry" class="headerlink" title="CallbackRegistry"></a>CallbackRegistry</h3><p>上面说到<strong>BaseObservable</strong>将职责托付给了<strong>mCallbacks</strong>，而mCallbacks是一个<strong>PropertyChangeRegistry</strong>类，这个类的超类<strong>CallbackRegistry</strong>。此类是管理callback注册，删除，通知的核心类，通过内部<strong>NotifierCallback</strong>类来通知callbacks，此类的代码虽然不多，但是对于我这种算法弱鸡来说看上去的感觉是这样的：<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1487508874434&amp;di=188c6fb1e6fe4e69bf1cab8c82844595&amp;imgtype=0&amp;src=http%3A%2F%2Fwanzao2.b0.upaiyun.com%2Fsystem%2Fpictures%2F31274020%2Foriginal%2F1449639129_500x500.png" alt=""></p>
<p>这个牛逼的算法就不由我这个弱鸡去分析了，它实现了通知Callback的可重入性，就是比方说有两个线程，一个线程执行到通知某个Callback时cpu切到了另一个线程，这个线程把刚才的要通知的Callback给删了，这种情况下切换到之前的线程进行通知是没有任何影响的。如果各位实在想知道这个算法是怎么一回事，请看这篇大牛的文章吧：<a href="https://gold.xitu.io/post/5840e2e3ac502e006cc0ef26" target="_blank" rel="external">回调通知管理器 CallbackRegistry 解析</a></p>
<h3 id="PropertyChangeRegistry"><a href="#PropertyChangeRegistry" class="headerlink" title="PropertyChangeRegistry"></a>PropertyChangeRegistry</h3><p>此类比较简单：</p>
<pre><code>public class PropertyChangeRegistry extends
    CallbackRegistry&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt; {

    private static final CallbackRegistry.NotifierCallback&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt; NOTIFIER_CALLBACK = new CallbackRegistry.NotifierCallback&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt;() {
        @Override
        public void onNotifyCallback(Observable.OnPropertyChangedCallback callback, Observable sender,
                int arg, Void notUsed) {
            callback.onPropertyChanged(sender, arg);
        }
    };

    public PropertyChangeRegistry() {
        super(NOTIFIER_CALLBACK);
    }

    public void notifyChange(Observable observable, int propertyId) {
        notifyCallbacks(observable, propertyId, null);
    }
}
</code></pre><p>Callback类型是<strong>Observable</strong>的内部类<strong>OnPropertyChangedCallback</strong>，Sender类型是<strong>Observable</strong>。NotifierCallback内部的实现仅仅是调用callback的<strong>onPropertyChanged</strong>方法，arg便是<strong>BR</strong>类里面的资源id。<strong>notifyChange</strong>方法是将外层传来的sender以及资源id传给<strong>notifyCallbacks</strong>方法，以此达到了最终调用每一个callback的<strong>onPropertyChanged</strong>的目的。</p>
<h2 id="ViewDataBinding"><a href="#ViewDataBinding" class="headerlink" title="ViewDataBinding"></a>ViewDataBinding</h2><p>系统会根据xml的描述生成此类的子类，我们先看一下自动生成的类的代码，一步一步加以分析。</p>
<p>xml文件：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;data class=&quot;BindingForTest&quot;&gt;
        &lt;variable
            name=&quot;testData&quot;
            type=&quot;com.stephen.learning.databinding.Model&quot;/&gt;
    &lt;/data&gt;

    &lt;LinearLayout
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        tools:context=&quot;com.stephen.learning.databinding.TestActivity&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/main_text_view&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot; /&gt;
        &lt;TextView
            android:id=&quot;@+id/second_text_view&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{testData.testData}&quot;/&gt;
        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{testData.testData}&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre><p>生成的ViewBinding子类：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-19%20%E4%B8%8B%E5%8D%888.36.08.png" alt=""><br>先看构造函数：</p>
<pre><code>public BindingForTest(android.databinding.DataBindingComponent bindingComponent, View root) {
    super(bindingComponent, root, 0);
    final Object[] bindings = mapBindings(bindingComponent, root, 4, sIncludes, sViewsWithIds);
    this.mainTextView = (android.widget.TextView) bindings[3];
    this.mboundView0 = (android.widget.LinearLayout) bindings[0];
    this.mboundView0.setTag(null);
    this.mboundView2 = (android.widget.Button) bindings[2];
    this.mboundView2.setTag(null);
    this.secondTextView = (android.widget.TextView) bindings[1];
    this.secondTextView.setTag(null);
    setRootTag(root);
    // listeners
    invalidateAll();
}
</code></pre><p>先调用超类的静态<strong>mapBindings</strong>方法得到一个<strong>View</strong>数组，再从数组中初始化View成员，View成员有三种：</p>
<ul>
<li>在xml中有id的定义。</li>
<li>在xml中存在数据的绑定。</li>
<li>是根View。</li>
</ul>
<p>满足以上三个条件任意一个便会生成相应的类成员，下面是笔者的类里面的类成员：</p>
<pre><code>//存在id，不存在数据绑定
public final android.widget.TextView mainTextView;
//根View
private final android.widget.LinearLayout mboundView0;
//存在数据绑定，不存在id
private final android.widget.Button mboundView2;
//既存在数据绑定，也存在id
public final android.widget.TextView secondTextView;
</code></pre><p>再来看一下类的静态初始化：</p>
<pre><code>static {
    sIncludes = null;
    sViewsWithIds = new android.util.SparseIntArray();
    sViewsWithIds.put(R.id.main_text_view, 3);
}
</code></pre><p><strong>sIncludes</strong>只有在xml中存在<strong>&lt;include&gt;</strong>标签且存在数据绑定的时候才不为空，在这里笔者暂时没有用到使用数据绑定的<strong>&lt;include&gt;</strong>的需求（觉得也不可能有），而且源码的实现相对简单，这里不太值得分析，有兴趣自己去看。<strong>sViewsWithIds</strong>是一个<strong>SparseIntArray</strong>，这个成员的作用是存放不存在数据绑定但存在id定义的View成员。键是id，值是对应在上面所提在View数组中的索引值。</p>
<p>下面来看<strong>mapBindings</strong>方法：</p>
<pre><code>protected static Object[] mapBindings(DataBindingComponent bindingComponent, View root,
        int numBindings, IncludedLayouts includes, SparseIntArray viewsWithIds) {
    Object[] bindings = new Object[numBindings];
    mapBindings(bindingComponent, root, bindings, includes, viewsWithIds, true);
    return bindings;
}

private static void mapBindings(DataBindingComponent bindingComponent, View view,
        Object[] bindings, IncludedLayouts includes, SparseIntArray viewsWithIds,
        boolean isRoot) {
    final int indexInIncludes;
    final ViewDataBinding existingBinding = getBinding(view);
    //已经绑定过，返回
    if (existingBinding != null) {
        return;
    }

    Object objTag = view.getTag();
    final String tag = (objTag instanceof String) ? (String) objTag : null;
    boolean isBound = false;

    //如果是根View
    if (isRoot &amp;&amp; tag != null &amp;&amp; tag.startsWith(&quot;layout&quot;)) {
        final int underscoreIndex = tag.lastIndexOf(&apos;_&apos;);
        if (underscoreIndex &gt; 0 &amp;&amp; isNumeric(tag, underscoreIndex + 1)) {
            final int index = parseTagInt(tag, underscoreIndex + 1);
            if (bindings[index] == null) {
                bindings[index] = view;
            }
            indexInIncludes = includes == null ? -1 : index;
            isBound = true;
        } else {
            indexInIncludes = -1;
        }
     //如果不是根View
    } else if (tag != null &amp;&amp; tag.startsWith(BINDING_TAG_PREFIX)) {
        int tagIndex = parseTagInt(tag, BINDING_NUMBER_START);
        if (bindings[tagIndex] == null) {
            bindings[tagIndex] = view;
        }
        isBound = true;
        indexInIncludes = includes == null ? -1 : tagIndex;
    } else {
        // Not a bound view
        indexInIncludes = -1;
    }
    //处理存在id但是不存在数据绑定的view成员
    if (!isBound) {
        final int id = view.getId();
        if (id &gt; 0) {
            int index;
            if (viewsWithIds != null &amp;&amp; (index = viewsWithIds.get(id, -1)) &gt;= 0 &amp;&amp;
                    bindings[index] == null) {
                bindings[index] = view;
            }
        }
    }

    if (view instanceof  ViewGroup) {
        final ViewGroup viewGroup = (ViewGroup) view;
        final int count = viewGroup.getChildCount();
        int minInclude = 0;
        for (int i = 0; i &lt; count; i++) {
            final View child = viewGroup.getChildAt(i);
            boolean isInclude = false;
            if (indexInIncludes &gt;= 0 &amp;&amp; child.getTag() instanceof String) {
               ...
            }
            //对每一个子View进行递归处理
            if (!isInclude) {
                mapBindings(bindingComponent, child, bindings, includes, viewsWithIds, false);
            }
        }
    }
}
</code></pre><p>此方法的思想相对简单，先判断是否绑定过，如果已经绑定过，则返回。接下来分成三种情况：</p>
<ul>
<li>根视图。</li>
<li>存在数据绑定的视图。</li>
<li>不存在数据绑定，但是在xml中有id定义。</li>
</ul>
<p>最后如果传入的是一个ViewGroup，则对它的子视图进行递归处理。下面我们来看几个细节：</p>
<p><strong>视图数组索引的判断</strong>  </p>
<p>上文中我们说过用<strong>&lt;layout&gt;</strong>做标记的xml文件在用<strong>LayoutInflater</strong>类inflate出来的根View会有一个<strong>tag</strong>，这个<strong>tag</strong>是一个<strong>String</strong>类型，且设置的规则如下：</p>
<ul>
<li>根视图设置为<strong>layout/[xml文件名]_[在View数组中的索引]</strong></li>
<li>不是根视图，但是存在数据的绑定，则设置为<strong>binding_[在View数组中的索引]</strong></li>
</ul>
<p>根据tag获得数组索引的代码如下：</p>
<pre><code>private static int parseTagInt(String str, int startIndex) {
    final int end = str.length();
    int val = 0;
    for (int i = startIndex; i &lt; end; i++) {
        val *= 10;
        char c = str.charAt(i);
        val += (c - &apos;0&apos;);
    }
    return val;
}
</code></pre><p>这样得出的数组索引便是最后一个”_”后面的数字值。</p>
<p>还有一种情况是不存在数据绑定，但是存在id定义的view成员。上面提到过如果存在这种情况，<strong>ViewDataBinding</strong>在静态初始化的时候会将对应的id和数组索引值放在一个<strong>SparseIntArray</strong>当中，这时候处理过程是这样的：</p>
<pre><code>if (!isBound) {
    final int id = view.getId();
    if (id &gt; 0) {
        int index;
        if (viewsWithIds != null &amp;&amp; (index = viewsWithIds.get(id, -1)) &gt;= 0 &amp;&amp;
                bindings[index] == null) {
            bindings[index] = view;
        }
    }
</code></pre><p>好，现在继续往下看<strong>invalidateAll</strong>方法：</p>
<pre><code>public void invalidateAll() {
    synchronized(this) {
            mDirtyFlags = 0x2L;
    }
    requestRebind();
}
</code></pre><p><strong>requestRebind</strong>:</p>
<pre><code>protected void requestRebind() {
    synchronized (this) {
        if (mPendingRebind) {
            return;
        }
        mPendingRebind = true;
    }
    if (USE_CHOREOGRAPHER) {
        mChoreographer.postFrameCallback(mFrameCallback);
    } else {
        mUIThreadHandler.post(mRebindRunnable);
    }

}
</code></pre><p>其中<strong>USE_CHOREOGRAPHER</strong>是判断当前的SDK是不是16以上版本来决定是否能用<strong>Choreographer</strong>，如果能则直接设置一个<strong>FrameCallback</strong>，不能则在主线程运行一个<strong>Runnable</strong>，我们来看<strong>mFrameCallback</strong>的定义：</p>
<pre><code>mFrameCallback = new Choreographer.FrameCallback() {
            @Override
            public void doFrame(long frameTimeNanos) {
                mRebindRunnable.run();
            }
        };
</code></pre><p><strong>mRebindRunnable</strong>:</p>
<pre><code>private final Runnable mRebindRunnable = new Runnable() {
    @Override
    public void run() {
        synchronized (this) {
            mPendingRebind = false;
        }
        if (VERSION.SDK_INT &gt;= VERSION_CODES.KITKAT) {
            // Nested so that we don&apos;t get a lint warning in IntelliJ
            if (!mRoot.isAttachedToWindow()) {
                // Don&apos;t execute the pending bindings until the View
                // is attached again.
                mRoot.removeOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);
                mRoot.addOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);
                return;
            }
        }
        executePendingBindings();
    }
};
</code></pre><p><strong>ROOT_ REATTACHED_LISTENER</strong>是一个<strong>OnAttachStateChangeListener</strong>，其定义如下：</p>
<pre><code>ROOT_REATTACHED_LISTENER = new OnAttachStateChangeListener() {
            @TargetApi(VERSION_CODES.KITKAT)
            @Override
            public void onViewAttachedToWindow(View v) {
                // execute the pending bindings.
                final ViewDataBinding binding = getBinding(v);
                binding.mRebindRunnable.run();
                v.removeOnAttachStateChangeListener(this);
            }

            @Override
            public void onViewDetachedFromWindow(View v) {
            }
        };
</code></pre><p>很简单，当根视图还没有attach到window上的时候，<strong>mRebindRunnable</strong>直接设置一个<strong>OnAttachStateChangeListener</strong>并返回，当attach到window上的时候重新运行<strong>mRebindRunnable</strong>，此时将运行<strong>executePendingBindings</strong>，定义如下：</p>
<pre><code>public void executePendingBindings() {
    if (mIsExecutingPendingBindings) {
        requestRebind();
        return;
    }
    if (!hasPendingBindings()) {
        return;
    }
    mIsExecutingPendingBindings = true;
    mRebindHalted = false;
    if (mRebindCallbacks != null) {
        mRebindCallbacks.notifyCallbacks(this, REBIND, null);

        // The onRebindListeners will change mPendingHalted
        if (mRebindHalted) {
            mRebindCallbacks.notifyCallbacks(this, HALTED, null);
        }
    }
    if (!mRebindHalted) {
        executeBindings();
        if (mRebindCallbacks != null) {
            mRebindCallbacks.notifyCallbacks(this, REBOUND, null);
        }
    }
    mIsExecutingPendingBindings = false;
}
</code></pre><p>其中<strong>hasPendingBindings</strong>方法是一个抽象方法，一般情况下子类通过其<strong>mDirtyFlags</strong>判断是否有未处理的绑定情况，返回相应的布尔值：</p>
<pre><code>public boolean hasPendingBindings() {
    synchronized(this) {
        if (mDirtyFlags != 0) {
            return true;
        }
    }
    return false;
}
</code></pre><p>接下来便要通知相应的mRebindCallbacks，我们来看它的定义：</p>
<pre><code>private CallbackRegistry&lt;OnRebindCallback, ViewDataBinding, Void&gt; mRebindCallbacks;

public void addOnRebindCallback(OnRebindCallback listener) {
    if (mRebindCallbacks == null) {
        mRebindCallbacks = new CallbackRegistry&lt;OnRebindCallback, ViewDataBinding, Void&gt;(REBIND_NOTIFIER);
    }
    mRebindCallbacks.add(listener);
}
</code></pre><p>它是一个Callback类型是<strong>OnRebindCallback</strong>，Sender类型是<strong>ViewDataBinding</strong>的<strong>CallbackRegistry</strong>类型，下面来看<strong>OnRebindCallback</strong>的定义，它是一个抽象类，里面有三个方法：</p>
<pre><code>public abstract class OnRebindCallback&lt;T extends ViewDataBinding&gt; {
    public boolean onPreBind(T binding) {
        return true;
    }

    public void onCanceled(T binding) {
    }

    public void onBound(T binding) {
    }
}
</code></pre><p>泛型的参数T就是上面的Sender，第一个方法<strong>onPreBind</strong>的返回值决定着rebind是否会继续进行。接着再来看<strong>REBIND_NOTIFIER</strong>:</p>
<pre><code>private static final CallbackRegistry.NotifierCallback&lt;OnRebindCallback, ViewDataBinding, Void&gt;
    REBIND_NOTIFIER = new NotifierCallback&lt;OnRebindCallback, ViewDataBinding, Void&gt;() {
    @Override
    public void onNotifyCallback(OnRebindCallback callback, ViewDataBinding sender, int mode,
            Void arg2) {
        switch (mode) {
            case REBIND:
                if (!callback.onPreBind(sender)) {
                    sender.mRebindHalted = true;
                }
                break;
            case HALTED:
                callback.onCanceled(sender);
                break;
            case REBOUND:
                callback.onBound(sender);
                break;
        }
    }
};
</code></pre><p>现在再来看<strong>executePendingBindings</strong>方法，先是向<strong>mRebindCallbacks</strong>传入<strong>REBIND</strong>参数，进而调用<strong>OnRebindCallback</strong>的<strong>onPreBind</strong>方法，根据其返回的布尔值来决定<strong>mRebindHalted</strong>的值（是否停止）。接下来判断<strong>mRebindHalted</strong>的值，如果是真值的话，则通过向<strong>mRebindCallbacks</strong>传入<strong>HALTED</strong>参数进而调用<strong>OnRebindCallback</strong>的<strong>onCanceled</strong>方法；如果是假值，则先调用<strong>executeBindings</strong>方法，此方法是抽象方法，再通过向<strong>mRebindCallbacks</strong>传入<strong>REBOUND</strong>参数，进而调用<strong>OnRebindCallback</strong>的<strong>onRebound</strong>方法。</p>
<p>下面来看<strong>executeBindings</strong>方法的具体实现：</p>
<pre><code>@Override
protected void executeBindings() {
    long dirtyFlags = 0;
    synchronized(this) {
        //读取mDirtyFlags
        dirtyFlags = mDirtyFlags;
        //重置mDirtyFlags
        mDirtyFlags = 0;
    }
    java.lang.String testDataTestData = null;
    //读取testData
    com.stephen.learning.databinding.Model testData = mTestData;

    if ((dirtyFlags &amp; 0x3L) != 0) {



            if (testData != null) {
                // read testData.testData
                testDataTestData = testData.testData;
            }
    }
    // batch finished
    if ((dirtyFlags &amp; 0x3L) != 0) {
        // api target 1

        android.databinding.adapters.TextViewBindingAdapter.setText(this.mboundView2, testDataTestData);
        android.databinding.adapters.TextViewBindingAdapter.setText(this.secondTextView, testDataTestData);
    }
}
</code></pre><p>方法的最后通过<strong>TextViewBindingAdapter</strong>来实际设置<strong>TextView</strong>的值（<strong>Button</strong>继承于<strong>TextView</strong>），除了<strong>TextViewBindingAdapter</strong>之外，官方还提供了四十多种Adapter用来使数据绑定更加便捷，在这里我就不一一分析了，只说一下大体的形式。一般来说一个Adapter由两部分组成：</p>
<ul>
<li>顶部<strong>BindingMethods</strong>注解，用此注解来说明当发生数据绑定时调用哪个类的哪个方法。</li>
<li>一系列用<strong>BindingAdapter</strong>注释的静态方法，用来供<strong>ViewDataBinding</strong>的子类调用。</li>
</ul>
<p>值得注意的是，xml中的数据绑定并不都是通过Adapter来实现的，下面举一个例子：</p>
<p>将xml文件更改成：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;

    ...

    &lt;LinearLayout
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        tools:context=&quot;com.stephen.learning.databinding.TestActivity&quot;
        android:orientation=&quot;vertical&quot;&gt;

        ...

        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{testData.testData}&quot;
            android:onClick=&quot;@{(v) -&gt; testData.onButtonClick()}&quot;/&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre><p>这个时候rebuild project，<strong>BindingForTest</strong>类变成了这样：</p>
<pre><code>public class BindingForTest extends android.databinding.ViewDataBinding implements android.databinding.generated.callback.OnClickListener.Listener {

    ...

    public BindingForTest(android.databinding.DataBindingComponent bindingComponent, View root) {
        ...
        // listeners
        mCallback1 = new android.databinding.generated.callback.OnClickListener(this, 1);
        invalidateAll();
    }

    @Override
    protected void executeBindings() {
        ...
        if ((dirtyFlags &amp; 0x2L) != 0) {
            // api target 1

            this.mboundView2.setOnClickListener(mCallback1);
        }
    }
    // Listener Stub Implementations
    // callback impls
    public final void _internalCallbackOnClick(int sourceId , android.view.View callbackArg_0) {
        // localize variables for thread safety
        // testData != null
        boolean testDataObjectnull = false;
        // testData
        com.stephen.learning.databinding.Model testData = mTestData;



        testDataObjectnull = (testData) != (null);
        if (testDataObjectnull) {


            testData.onButtonClick();
        }
    }
}
</code></pre><p>在构造函数中初始化了databinding包中的<strong>OnClickListener</strong>，并且实现了其中的<strong>Listener</strong>接口，<strong>OnClickListener</strong>类的定义如下：</p>
<pre><code>public final class OnClickListener implements android.view.View.OnClickListener {
    final Listener mListener;
    final int mSourceId;
    public OnClickListener(Listener listener, int sourceId) {
        mListener = listener;
        mSourceId = sourceId;
    }
    @Override
    public void onClick(android.view.View callbackArg_0) {
        mListener._internalCallbackOnClick(mSourceId , callbackArg_0);
    }
    public interface Listener {
        void _internalCallbackOnClick(int sourceId , android.view.View callbackArg_0);
    }
}
</code></pre><p>它实现了<strong>View</strong>当中的<strong>OnClickListener</strong>接口，其<strong>onClick</strong>方法则调用<strong>mListener</strong>当中的<strong>_internalCallbackOnClick</strong>方法（这个命名怎么这么像native方法）。<strong>BindingForTest</strong>的对此方法的定义如下：</p>
<pre><code>public final void _internalCallbackOnClick(int sourceId , android.view.View callbackArg_0) {
        // localize variables for thread safety
        // testData != null
        boolean testDataObjectnull = false;
        // testData
        com.stephen.learning.databinding.Model testData = mTestData;
        testDataObjectnull = (testData) != (null);
        if (testDataObjectnull) {
            testData.onButtonClick();
        }
    }
</code></pre><p>这边开始调用testData的<strong>onButtonClick</strong>，与xml中的定义对应起来了。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/源码分析/" rel="tag"># 源码分析</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/14/Android-DataBinding（一）：基本使用/" rel="next" title="Android DataBinding（一）：基本使用">
                <i class="fa fa-chevron-left"></i> Android DataBinding（一）：基本使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/16/Mac-OS-Sierra下编译Android-7-1-1/" rel="prev" title="Mac OS Sierra下编译Android 7.1.1">
                Mac OS Sierra下编译Android 7.1.1 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/02/15/Android-DataBinding（二）：源码解析/"
           data-title="Android DataBinding（二）：源码解析" data-url="http://yoursite.com/2017/02/15/Android-DataBinding（二）：源码解析/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/lion.jpg"
               alt="Stephen Zhang" />
          <p class="site-author-name" itemprop="name">Stephen Zhang</p>
          <p class="site-description motion-element" itemprop="description">Stephen Zhang's notes.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#准备工作"><span class="nav-number">1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码解析"><span class="nav-number">2.</span> <span class="nav-text">源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DataBindingUtil"><span class="nav-number">2.1.</span> <span class="nav-text">DataBindingUtil</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataBinderMapper"><span class="nav-number">2.2.</span> <span class="nav-text">DataBinderMapper</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BaseObservable"><span class="nav-number">2.3.</span> <span class="nav-text">BaseObservable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Observable"><span class="nav-number">2.3.1.</span> <span class="nav-text">Observable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CallbackRegistry"><span class="nav-number">2.3.2.</span> <span class="nav-text">CallbackRegistry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PropertyChangeRegistry"><span class="nav-number">2.3.3.</span> <span class="nav-text">PropertyChangeRegistry</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ViewDataBinding"><span class="nav-number">2.4.</span> <span class="nav-text">ViewDataBinding</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Zhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zsrcodingme"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
