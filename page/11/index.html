<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="8OYvD8bSBXPN0nqkEA3YoLXTlwUGZmqTR6FfrPmc9cY" />




  <meta name="baidu-site-verification" content="C2fNg3O37K" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="前进的路上充满着幸福">
<meta property="og:type" content="website">
<meta property="og:title" content="Stephen的小本本">
<meta property="og:url" content="http://www.stephenzhang.me/page/11/index.html">
<meta property="og:site_name" content="Stephen的小本本">
<meta property="og:description" content="前进的路上充满着幸福">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stephen的小本本">
<meta name="twitter:description" content="前进的路上充满着幸福">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.stephenzhang.me/page/11/"/>





  <title> Stephen的小本本 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Stephen的小本本</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.stephenzhang.me/2017/03/14/Java并发编程-二/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen的小本本">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen的小本本" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/Java并发编程-二/" itemprop="url">
                  Java并发编程(二)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-14T20:20:52+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>以下内容均摘自《Java并发编程的艺术》</p>
<h1 id="等待／超时模式"><a href="#等待／超时模式" class="headerlink" title="等待／超时模式"></a>等待／超时模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>等待／超时模式的典型应用场景是，等待一段时间，看是否能得到正确的结果，如果能，则将其返回，不能则返回默认值，其代码如下：</p>
<pre><code>public synchronized Object getObject(long millionSeconds) throws InterruptedException {
    long future = System.currentTimeMillis() + millionSeconds;
    long remainingTime = millionSeconds;
    while (obj == null &amp;&amp; remainingTime &gt; 0) {
        wait(remainingTime);
        remainingTime = future - System.currentTimeMillis();
    }

    return obj;
}
</code></pre><h2 id="应用：数据库连接池"><a href="#应用：数据库连接池" class="headerlink" title="应用：数据库连接池"></a>应用：数据库连接池</h2><p>下面来模拟一个数据库连接池，用来从中获取和释放连接，客户端获取连接被设置为超时等待，程序如下：</p>
<pre><code>public class ConnectionPool {
    private final LinkedList&lt;Connection&gt; connections = new LinkedList&lt;&gt;();

    public ConnectionPool(int initSize) {
        if (initSize &lt;= 0)
            throw new IllegalArgumentException(&quot;Init size must &gt; 0&quot;);
        for (int i = 0; i &lt; initSize; i++) {
            connections.addLast(ConnectionDriver.getConnection());
        }
    }

    public void releaseConnection(Connection connection) {
        synchronized (connections) {
            connections.addLast(connection);
            connections.notifyAll();
        }
    }

    public Connection getConnection(long millionSeconds) throws InterruptedException {
        synchronized (connections) {
            if (millionSeconds &lt;= 0) {
                while (connections.isEmpty()) {
                    connections.wait();
                }
                return connections.removeFirst();
            } else {
                long future = System.currentTimeMillis() + millionSeconds;
                long remaining = millionSeconds;

                while (connections.isEmpty() &amp;&amp; remaining &gt; 0) {
                    connections.wait(remaining);
                    remaining = future - System.currentTimeMillis();
                }

                Connection connection = null;
                if (!connections.isEmpty()) {
                    connection = connections.removeFirst();
                }

                return connection;
            }
        }
    }
}
</code></pre><p>ConnectionDriver通过动态代理技术返回一个Connection:</p>
<pre><code>public class ConnectionDriver {

    public static class ConnectionHandler implements InvocationHandler {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            if (method.getName().equals(&quot;commit&quot;)) {
                Thread.sleep(1000);
            }

            return null;
        }
    }

    public static Connection getConnection() {
        return (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(),
                new Class[] {Connection.class},
                new ConnectionHandler());
    }
}
</code></pre><p>上面的连接池通过构造函数传入的initSize来定义里面的连接数量，通过<strong>release</strong>方法来释放用过的连接，此时连接被重新加入到队列内部，然后通知在<strong>connections</strong>上等待的线程此时有连接可以进行复用。<strong>getConnection</strong>通过制定的参数设置超时时间，并判断队列是否为空，不为空则直接从队列里面取出第一个并返回，不是的话则在<strong>connections</strong>上进行等待，知道超时或者又有复用的connection为止。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.stephenzhang.me/2017/03/13/Java并发编程-一/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen的小本本">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen的小本本" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/Java并发编程-一/" itemprop="url">
                  Java并发编程(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-13T18:46:34+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>一下部分文字图片来自《Java并发编程的艺术》</p>
<h1 id="多线程简介"><a href="#多线程简介" class="headerlink" title="多线程简介"></a>多线程简介</h1><p>线程是现代操作系统调度的最小单元，一个进程可以包含很多线程。在Java的内存区域里面，每一个线程都有自己的程序计数器和虚拟机栈。处理器通过时间切片的方法在各个线程之间来回切换，可以用下面的代码查看JVM运行时各个线程的信息：</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) {
        ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();
        ThreadInfo[] threadInfoArray = mxBean.dumpAllThreads(false, false);

        for (ThreadInfo info : threadInfoArray) {
            System.out.println(&quot;Thread id: &quot; + info.getThreadId() + &quot; Thread name: &quot; +
                    info.getThreadName() + &quot; Thread state: &quot; + info.getThreadState());
        }
    }
}
</code></pre><p>运行结果如下：</p>
<pre><code>Thread id: 9 Thread name: Monitor Ctrl-Break Thread state: RUNNABLE
Thread id: 4 Thread name: Signal Dispatcher Thread state: RUNNABLE
Thread id: 3 Thread name: Finalizer Thread state: WAITING
Thread id: 2 Thread name: Reference Handler Thread state: WAITING
Thread id: 1 Thread name: main Thread state: RUNNABLE
</code></pre><p>也就是说，运行main函数时，不只是main线程在运行，Java天生就是多线程的。</p>
<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>在Java程序里面，线程的优先级通过<strong>setPriority(int priority)</strong>来设置，<strong>priority</strong>的取值范围为1-10，默认为5，线程的优先级越高，处理器对此线程所切的时间片越长，但是不同的操作系统的表现不同，有些会忽略掉线程的优先级，因此，设置优先级不会保证多线程程序的正确性，在实际编程过程中不应该使用。</p>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>线程的状态分为以下几种：</p>
<ul>
<li><strong>NEW</strong> 被创建成功，还没有调用<strong>start()</strong>方法。</li>
<li><strong>RUNNABLE</strong> 正在运行中。</li>
<li><strong>BLOCKED</strong> 正在处于阻塞状态。</li>
<li><strong>WAITING</strong> 等待状态，此线程在等待其他线程做出特定的动作。</li>
<li><strong>TIME_WAITING</strong> 超时等待状态。</li>
<li><strong>TERMINATED</strong> 终止，线程结束。</li>
</ul>
<p>拿上面的运行结果的线程名为<strong>Finalizer</strong>的线程来说，运行时处于<strong>WAITING</strong>状态，它在等待有对象进入它内部持有的<strong>ReferenceQueue</strong>，并执行清理动作，有关Finalizer的更多信息，查看：<a href="http://blog.csdn.net/rsljdkt/article/details/12242007" target="_blank" rel="external">GC执行finalize的过程</a></p>
<p>为了说明各大状态，我先用开几个线程，然后用<a href="http://blog.csdn.net/fenglibing/article/details/6411940" target="_blank" rel="external">jstack</a>指令查看各线程的状态。</p>
<p>代码如下：</p>
<pre><code>class SleepUtils {
    public static void sleep(int millionSeconds) {
        try {
            Thread.sleep(millionSeconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class ThreadStateTest {

    static class TimeWaitingThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                SleepUtils.sleep(100);
            }
        }
    }

    static class PauseThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                long current = System.currentTimeMillis();
                while (System.currentTimeMillis() - current &lt;= 3000);
            }
        }
    }

    static class Waiting implements Runnable {
        @Override
        public void run() {
            while (true) {
                synchronized (Waiting.class) {
                    try {
                        Waiting.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    static class Block implements Runnable {
        @Override
        public void run() {
            synchronized (Block.class) {
                while (true) {
                    SleepUtils.sleep(4000);
                }
            }
        }
    }

    public static void main(String[] args) {
        new Thread(new TimeWaitingThread(), &quot;TimedWaitingThread&quot;).start();
        new Thread(new PauseThread(), &quot;PauseThread&quot;).start();
        new Thread(new Waiting(), &quot;WaitingThread&quot;).start();
        new Thread(new Block(), &quot;Block1&quot;).start();
        new Thread(new Block(), &quot;Block2&quot;).start();
    }
}
</code></pre><p>运行之后，先在终端运行<a href="http://blog.csdn.net/fenglibing/article/details/6411932" target="_blank" rel="external">jps</a>命令，结果如下：</p>
<pre><code>37729 
38982 Launcher
38983 AppMain
38986 Jps
</code></pre><p>其中<strong>AppMain</strong>就是刚才开启的进程pid，现在运行<strong>jstack 38983</strong>，运行结果如下（部分）：</p>
<pre><code>&quot;Block2&quot; #14 prio=5 os_prio=31 tid=0x00007fc65c835000 nid=0x5703 waiting for monitor entry [0x0000700002ba2000]
   java.lang.Thread.State: BLOCKED (on object monitor)
    at com.stephen.ThreadStateTest$Block.run(ThreadStateTest.java:58)
    - waiting to lock &lt;0x00000007956f6ea8&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Block)
    at java.lang.Thread.run(Thread.java:745)

&quot;Block1&quot; #13 prio=5 os_prio=31 tid=0x00007fc65d82a000 nid=0x5503 waiting on condition [0x0000700002a9f000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
    at java.lang.Thread.sleep(Native Method)
    at com.stephen.SleepUtils.sleep(ThreadStateTest.java:10)
    at com.stephen.ThreadStateTest$Block.run(ThreadStateTest.java:58)
    - locked &lt;0x00000007956f6ea8&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Block)
    at java.lang.Thread.run(Thread.java:745)

&quot;WaitingThread&quot; #12 prio=5 os_prio=31 tid=0x00007fc65d82f800 nid=0x5303 in Object.wait() [0x000070000299c000]
   java.lang.Thread.State: WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    - waiting on &lt;0x00000007956f37f0&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Waiting)
    at java.lang.Object.wait(Object.java:502)
    at com.stephen.ThreadStateTest$Waiting.run(ThreadStateTest.java:44)
    - locked &lt;0x00000007956f37f0&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Waiting)
    at java.lang.Thread.run(Thread.java:745)

&quot;PauseThread&quot; #11 prio=5 os_prio=31 tid=0x00007fc65e01e000 nid=0x5103 runnable [0x0000700002899000]
   java.lang.Thread.State: RUNNABLE
    at com.stephen.ThreadStateTest$PauseThread.run(ThreadStateTest.java:33)
    at java.lang.Thread.run(Thread.java:745)

&quot;TimedWaitingThread&quot; #10 prio=5 os_prio=31 tid=0x00007fc65c80e000 nid=0x4f03 waiting on condition [0x0000700002796000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
    at java.lang.Thread.sleep(Native Method)
    at com.stephen.SleepUtils.sleep(ThreadStateTest.java:10)
    at com.stephen.ThreadStateTest$TimeWaitingThread.run(ThreadStateTest.java:23)
    at java.lang.Thread.run(Thread.java:745)
</code></pre><p>现在来逐一解释：</p>
<ul>
<li><strong>Block2</strong>：由于<strong>Block1</strong>已经获得<strong>Block.class</strong>锁，所以此线程处于阻塞状态。</li>
<li><strong>Block1</strong>：此线程不断的进行睡眠，且睡眠操作具有时间限制，因此处在超时等待操作状态。</li>
<li><strong>WaitingThread</strong>：此线程在<strong>Waiting.class</strong>上等待，且没有时间限制，所以处在waiting状态。</li>
<li><strong>PauseThread</strong>：此线程和<strong>TimedWaitingThread</strong>线程达到的效果相同，但是实现的手段不同，没有调用<strong>Thread.sleep(int millionSeconds)</strong>方法，处在<strong>Runnable</strong>状态。</li>
<li><strong>TimedWaitingThread</strong>：此线程不断调用<strong>Thread.sleep(int millionSeconds)</strong>方法，处于超时等待状态。</li>
</ul>
<h1 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h1><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><p>其他线程可以调用另一个线程的<strong>interrupt()</strong>方法来中断线程，可以调用线程的<strong>isInterrupted()</strong>来判断一个线程是否被中断，但是这个方法不总是返回true:</p>
<ul>
<li>当线程终止时，此方法会返回false。</li>
<li>抛出<strong>InterruptedException</strong>的方法，在抛出异常之前，会将标识位设置为false，因此方法也总是返回false。</li>
</ul>
<p>现在用如下程序做出证明：</p>
<pre><code>public class InterruptTest {
    static class SleepThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                SleepUtils.sleep(3000);
            }
        }
    }

    static class NormalThread implements Runnable {
        @Override
        public void run() {
            while (true);
        }
    }

    public static void main(String[] args) {
        Thread sleepThread = new Thread(new SleepThread(), &quot;Sleep&quot;);
        Thread normalThread = new Thread(new NormalThread(), &quot;Normal&quot;);

        sleepThread.start();
        normalThread.start();

        SleepUtils.sleep(2000);

        sleepThread.interrupt();
        normalThread.interrupt();

        System.out.println(&quot;Sleep thread interrupted is &quot; + sleepThread.isInterrupted());
        System.out.println(&quot;Normal thread interrupted is &quot; + normalThread.isInterrupted());
    }
}
</code></pre><p>结果如下：</p>
<pre><code>Sleep thread interrupted is false    
Normal thread interrupted is true
</code></pre><h2 id="设置boolean变量"><a href="#设置boolean变量" class="headerlink" title="设置boolean变量"></a>设置boolean变量</h2><p>还可以设置boolean变量来通知线程的结束，这种方式比上面的<strong>interrupt</strong>方法更为优雅：</p>
<pre><code>public class BooleanFlagThread {
    static class CounterRunnable implements Runnable {
        long i = 0L;
        private volatile boolean isCancelled = false;

        public void cancel() {
            isCancelled = true;
        }

        @Override
        public void run() {
            while (!isCancelled &amp;&amp; !Thread.currentThread().isInterrupted()) {
                i++;
            }
        }
    }

    public static void main(String[] args) {
        CounterRunnable cr = new CounterRunnable();
        Thread countThread = new Thread(cr, &quot;Count&quot;);
        countThread.start();

        SleepUtils.sleep(2000);
        cr.cancel();

        System.out.println(&quot;&quot; + cr.i);
    }
}
</code></pre><h1 id="线程之间的通信：notify-wait"><a href="#线程之间的通信：notify-wait" class="headerlink" title="线程之间的通信：notify(), wait()"></a>线程之间的通信：notify(), wait()</h1><p>线程除了用<strong>synchronized</strong>,<strong>volatile</strong>来进行通信之外，还可以用notify和wait方法，使用这两个方法的前提是某个线程获取了相应对象的锁，典型应用的示例代码如下：</p>
<pre><code>public class NotifyWaitTest {
    static Object lock = new Object();
    static boolean flag = true;

    static class Wait implements Runnable {
        @Override
        public void run() {
            //获取对象的锁
            synchronized (lock) {
                while (flag) { // 2
                    System.out.println(&quot;不满足相应的条件&quot;);
                    try {
                        //进入wait状态，同时释放对象的锁
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(&quot;条件满足&quot;);
            }
        }
    }

    static class Notify implements Runnable {
        @Override
        public void run() {
            //获取对象的锁
            synchronized (lock) {
                if (flag) {
                    flag = false; // 1
                    //通知改变
                    lock.notify();
                }

                System.out.println(&quot;条件已改变&quot;);
            }
        }
    }

    public static void main(String[] args) {
        Thread waitThread = new Thread(new Wait(), &quot;Wait&quot;);
        Thread notifyThread = new Thread(new Notify(), &quot;Notify&quot;);
        waitThread.start();
        //保证wait先执行的方式
        SleepUtils.sleep(2000);
        notifyThread.start();
    }
}
</code></pre><p>输出的结果如下：</p>
<pre><code>不满足相应的条件
条件已改变
条件满足
</code></pre><p>需要注意的是：</p>
<ul>
<li>在调用notify, wait方法之前，要先获得对象的锁。</li>
<li>wait方法，会释放相应的锁。</li>
<li>notify方法会将调用wait的线程从等待队列到同步队列，此时wait线程将从WAITING状态转到BLOCK状态。</li>
<li>只有当notify的线程释放对象锁时，另一个wait线程才会返回继续工作。</li>
<li>notify和wait具有happens-before关系。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.stephenzhang.me/2017/03/13/Java内存模型-三/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen的小本本">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen的小本本" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/Java内存模型-三/" itemprop="url">
                  Java内存模型(三)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-13T18:44:31+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>一下部分文字图片来自《Java并发编程的艺术》</p>
<h1 id="双重检查锁解决方案"><a href="#双重检查锁解决方案" class="headerlink" title="双重检查锁解决方案"></a>双重检查锁解决方案</h1><p>Java程序有时需要用到单例模式，通常用延迟初始化的方式实现单例模式，但是只是简单的延迟初始化可能会有线程安全问题，例如：</p>
<pre><code>public class Instance {
    private static Instance instance;

    public static Instance getInstance() {
        if (instance == null) { //1
            instance = new Instance();
        }

        return instance;
    }
}
</code></pre><p>这段代码有很严重的问题，加入两个线程同时处于1操作并且判断instance为空的话，那么instance就会被初始化两次。</p>
<h2 id="synchronized解决方案"><a href="#synchronized解决方案" class="headerlink" title="synchronized解决方案"></a>synchronized解决方案</h2><p>解决上述问题最简单的方法便是用<strong>synchronized</strong>关键字标注<strong>getInstance</strong>方法：</p>
<pre><code>public synchronized static Instance getInstance() {
    if (instance == null) {
        instance = new Instance();
    }

    return instance;
}
</code></pre><p>此方法解决了多线程冲突的问题，但是如果线程太多且<strong>instance</strong>初始化过程太耗时的话，就会转成重量级锁，性能问题随之而来。</p>
<h2 id="双重检查锁定-Double-Checked-Lock"><a href="#双重检查锁定-Double-Checked-Lock" class="headerlink" title="双重检查锁定(Double Checked Lock)"></a>双重检查锁定(Double Checked Lock)</h2><p>为了解决性能的开销，采取了下述办法来解决：</p>
<pre><code>public class Instance {
    private static Instance instance;

    public static Instance getInstance() {
        if (instance == null) { //1
            synchronized (Instance.class) { //2
                if (instance == null) { //3
                    instance = new Instance();
                }
            }
        }

        return instance;
    }
}
</code></pre><p>采用上述办法不能完美地解决问题，出现的问题是返回的引用可能指向一个未被完全正确初始化的对象，下面来分析一下。</p>
<p>假设初始有两个线程A,B同时调用<strong>getInstance</strong>方法，判断instance为空之后开始竞争<strong>Instance</strong>锁，设B线程首先获得了锁，并在成功初始化<strong>instance</strong>对象之后释放锁，此时线程A再获取锁，根据happens-before关系，此时线程A对<strong>instance</strong>对象的改变是可以看到的，因此整个过程只初始化了一次，截止到现在是没有问题的。</p>
<h3 id="对象的初始化过程"><a href="#对象的初始化过程" class="headerlink" title="对象的初始化过程"></a>对象的初始化过程</h3><p>上述办法的问题来自于对象初始化过程的重排序，<strong>instance</strong>初始化可以分成以下三个过程：</p>
<ul>
<li>分配对象的存储空间。</li>
<li>进行初始化。</li>
<li>将对象的地址赋值给引用。</li>
</ul>
<p>问题来自于第二步和第三步的重排序。加入现在有两个线程A,B同时执行，B 先获得了锁先执行，此时A执行到上面的1操作，但是B线程此刻已经把对象地址赋值给了引用，但是并没有正确的初始化（3和1不具备happens-before）关系，此刻A线程读到的<strong>instance</strong>引用是不为空的，但是对象并没有正确的初始化，便即刻将其暴露给外部，问题就出现了。</p>
<h3 id="基于volatile的解决方案"><a href="#基于volatile的解决方案" class="headerlink" title="基于volatile的解决方案"></a>基于volatile的解决方案</h3><p>在<strong>instance</strong>对象前面加上<strong>volatile</strong>关键字可以禁止上述初始化过程的重排序：</p>
<pre><code>public class Instance {
    private volatile static Instance instance;

    public static Instance getInstance() {
        if (instance == null) {
            synchronized (Instance.class) {
                if (instance == null) {
                    instance = new Instance();
                }
            }
        }

        return instance;
    }
}
</code></pre><p><strong>volatile</strong>关键字保证了读取到引用不为空时对象已经被正确地初始化，问题解决。</p>
<h3 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h3><pre><code>public class Instance {
    private static class InstanceHolder {
        private static Instance instance = new Instance();
    }

    public static Instance getInstance() {
        return InstanceHolder.instance;
    }
}
</code></pre><p>此种方法适合包含无参构造函数的类的单例模式，原理如下：</p>
<p>假设有两个线程A,B当两个线程同时开始访问<strong>Instance</strong>类的时候，开始类的初始化，此时JVM将尝试获取<strong>Instance</strong>类上的锁，防止多个线程同时初始化。</p>
<p>假定线程B获取了初始化的锁，当执行完<strong>instance = new Instance()</strong>语句时，释放锁，线程A执行时将会看到已经初始化的<strong>instance</strong>实例并将其返回，初始化过程的重排序对于线程A此时是不可见的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.stephenzhang.me/2017/03/11/Java内存模型-二/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen的小本本">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen的小本本" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/11/Java内存模型-二/" itemprop="url">
                  Java内存模型(二)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-11T11:08:01+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>一下部分文字图片来自《Java并发编程的艺术》</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>volatile</strong>的典型特性之一是一个线程对<strong>volatile</strong>变量的写入对其他线程来说是立即可见的。假设有以下程序：</p>
<pre><code>public class VolatileFeaturesExample {
    private volatile int a;

    public int getA() {
        return a;
    }

    public void setA(int a) {
        this.a = a;
    }
}
</code></pre><p>与下面这段代码的执行效果是等效的：</p>
<pre><code>public class VolatileFeaturesExample {
    private int a;

    public synchronized void setA(int a) {
        this.a = a;
    }

    public synchronized int getA() {
        return a;
    }
}
</code></pre><p>根据happens-before规则，锁的解锁happens before于此锁被加锁之前，所以一个线程对<strong>a</strong>变量的写入对另一个线程是可见的。</p>
<p>另外，锁的语义决定了<strong>volatile</strong>的读写具备原子性，也就是说即便对于<strong>long</strong>和<strong>double</strong>类型，只要有<strong>volatile</strong>关键字修饰，对其赋值也是原子操作。</p>
<h2 id="限制重排序"><a href="#限制重排序" class="headerlink" title="限制重排序"></a>限制重排序</h2><p>为了实现volatile的内存语义， JMM针对volatile变量制定了一套特殊的重排序规则，规则如下表：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-11%20%E4%B8%8B%E5%8D%884.22.57.png" alt=""></p>
<p>从图中可以看出：</p>
<ul>
<li>若第二个操作是对volatile对象的写操作，那么无论第一个操作是什么，都不会发生重排序。</li>
<li>若第一个操作是对volatile变量的读操作，那么无论第二个操作是什么，都不会发生重排序。</li>
</ul>
<p>上一篇博客曾经提到<strong>volatile</strong>的实现是通过增加内存屏障来实现的，针对<strong>volatile</strong>的内存屏障策略如下：</p>
<ul>
<li>在volatile变量写之前加入store屏障。</li>
<li>在volatile变量写之后加入store-load屏障。</li>
<li>在读操作的后面加上load屏障。</li>
<li>在读操作的后面加上load-store屏障。</li>
</ul>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><p>先看下面这段代码：</p>
<pre><code>public class LockExample {
    private int a;

    public synchronized void increase() { // 1
        a++; // 2
    } // 3

    public synchronized void get() { // 4
        int i = a; // 5
    } // 6
}
</code></pre><p>根据happens-before原则，1发生在2之前，2发生在3之前……最终得出的结论是2发生在5之前，也就是说，两个线程，线程1获得锁之后对所有共享变量的修改，对下一个线程获得锁的时候是可见的。</p>
<h2 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h2><p>锁的内存语义如下：</p>
<ul>
<li>一个线程释放锁，会将本地内存中的变量推送到主内存当中。</li>
<li>一个线程获得锁的时候，会将本地内存的变量设置为无效状态，强制从主内存中读取。</li>
</ul>
<p>可见，锁的内存语义和<strong>volatile</strong>的内存语义差不多，区别就是锁对于共享变量的刷新和重新读取是全局的，volatile是局部的。</p>
<h2 id="内存语义的实现"><a href="#内存语义的实现" class="headerlink" title="内存语义的实现"></a>内存语义的实现</h2><p>下篇再更新，可以先看这篇文章：<a href="http://blog.csdn.net/yuhongye111/article/details/39053067" target="_blank" rel="external">ReentrantLock源码分析</a></p>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h2><p>被final修饰的变量只要在构造器之内进行合理的初始化并且没有发生<a href="http://blog.csdn.net/flysqrlboy/article/details/10607295" target="_blank" rel="external">this引用逃逸</a>，那么此字段对其他线程来说就是可见的。</p>
<h2 id="写重排序规则"><a href="#写重排序规则" class="headerlink" title="写重排序规则"></a>写重排序规则</h2><p>对final域进行写入的重排序规则为：在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给另一个引用，这两个指令不能发生重排序。</p>
<p>如下代码：</p>
<pre><code>public class FinalExample {
    int i = 0;
    final int j;
    static FinalExample fe;

    public FinalExample() {
        i = 1;
        j = 1;
    }

    public static void writer() {
        fe = new FinalExample();
    }

    public static void reader() {
        FinalExample obj = fe; //1
        int a = obj.i; //2
        int b = obj.j; //3
    }
}
</code></pre><p>假设线程A执行writer函数，final的重排序规则保证了在对fe赋值之前j已经得到了合理的初始化，但是对于普通域而言，在fe被赋值时，i可能未被得到合理的初始化，原因是i = 1可能因为重排序的关系放在了构造函数之外。</p>
<h2 id="读重排序规则"><a href="#读重排序规则" class="headerlink" title="读重排序规则"></a>读重排序规则</h2><p>在一个线程中，初次读对象引用和读取对象的final域，这两条指令不能发生重排序。还是上面的代码，若线程B执行reader函数，假设此时fe已经不是null，那么1和3操作就不能发生重排序，b的值便是j的值。但是对于普通域i来说情况就不一定了，因为此时i可能因为重排序的关系，初始化过程还没有进行。</p>
<h2 id="final引用类型"><a href="#final引用类型" class="headerlink" title="final引用类型"></a>final引用类型</h2><p>对于引用类型，final重排序规则如下：</p>
<p>在构造器内对final引用进行修改，与之后将此被构造对象赋值给其他引用，这两个操作不能发生重排序。例如：</p>
<pre><code>public class FinalExample {
    final int[] finalArrayReference;
    static FinalExample fe;

    public FinalExample() {
        finalArrayReference = new int[10];
        finalArrayReference[0] = 1;
    }

    public static void writer() {
        fe = new FinalExample();
    }
}
</code></pre><p>此时若有线程A执行writer函数，那么对于此时fe的finalArrayReference域不为空，其第一个位置的值也得到了初始化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.stephenzhang.me/2017/03/10/Java内存模型-一/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen的小本本">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen的小本本" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/10/Java内存模型-一/" itemprop="url">
                  Java内存模型(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-10T20:06:10+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>一下部分文字图片来自《Java并发编程的艺术》</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JMM(Java Memory Model),即Java内存模型，是Java实现并发的主要机制。多个线程通过JMM共享程序公有状态进而实现隐式通信。</p>
<h1 id="抽象结构"><a href="#抽象结构" class="headerlink" title="抽象结构"></a>抽象结构</h1><p>程序的公有状态，共享变量等储存在主内存(Main Memory)当中。每个线程都有一个本地内存(Local Memory)来储存主内存中共享变量的副本，其结构如下图所示：<br><img src="http://cdn.infoqstatic.com/statics_s1_20170228-0434_4/resource/articles/java-memory-model-1/zh/resources/11.png" alt=""><br>（本图作者为Java资深软件工程师：<a href="http://ifeve.com/author/25622818/" target="_blank" rel="external">程晓明</a>）</p>
<p>此时两个线程A,B的通信流程为：</p>
<ul>
<li>线程A更新本地内存中共享变量的副本，并将其写入主内存。</li>
<li>线程B从主内存中读取更新过的共享变量。</li>
</ul>
<h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><p>重排序是指为了提高程序运行的性能，充分利用并行，来对指令进行重新排序，主要分为编译器优化重排序和指令级并行重排序。关于重排序的更多理解，参见：<a href="http://blog.hesey.net/2011/07/reordering.html" target="_blank" rel="external">理解重排序</a></p>
<h2 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h2><p>数据依赖性分为三种情况：</p>
<ul>
<li>写后读，对一个变量写之后再进行读取。</li>
<li>读后写，对一个变量读取之后再进行写入。</li>
<li>写后写，对一个变量写之后再进行写入。</li>
</ul>
<p>以上三种情况若两个指令发生了重排序，则产生的结果与预期不一致，称以上三个指令对两指令之间存在数据依赖性，存在数据依赖性的两个指令不会发生重排序。</p>
<h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><p><strong>as-if-serial</strong>的含义是指，对于一个单线程而言，无论怎么重排序，其结果与顺序执行的结果一致。为了遵循这个原则，在单线程环境中，如果两个指令指令之间存在数据依赖性，那么这两个指令便不会发生重排序。</p>
<h2 id="对多线程的影响"><a href="#对多线程的影响" class="headerlink" title="对多线程的影响"></a>对多线程的影响</h2><p>假设有以下程序：</p>
<pre><code>public class RecorderExample {
    private boolean flag = false;
    private int i = 0;

    public void write() {
        i = 1;       //1
        flag = true; //2
    }

    public void read() {
        if (flag) {
            int a = i * i; 
        }
    }

    public static void main(String[] args) {
        RecorderExample re = new RecorderExample();
        new Thread(re::write).start();
        new Thread(re::read).start();
    }
}
</code></pre><p>在第一个线程里面，1、2指令由于没有数据依赖，所以可以进行重排序，若两个进行了重排序，<strong>flag</strong>设置成true之后，切换到第二个线程进行条件判断，判断完成后对a进行赋值，此时变量<strong>i</strong>并没有进行设置，所以会发生异常的结果，也就是说，<strong>重排序会破坏多线程的语义</strong>。</p>
<h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>它指的是一组用来实现对内存操作的顺序限制的处理器指令，会根据需求禁止特定类型的重排序。先假定这样一个事实：内存数据被推送到缓冲区，就会有消息协议来保证缓存和内存的数据一致性，这种尽快保证数据可见性的技术称为内存屏障。</p>
<p>内存屏障有三种类型：</p>
<ul>
<li>Store屏障：在该屏障之前的Store指令都会被执行，即写操作都会刷新到主内存当中去。</li>
<li>Load屏障，在该屏障之后的load指令在该屏障之后执行，保证了处理器缓存加载成功后进行读操作。</li>
<li>Full Barrier:即结合了上述两种屏障功能的屏障。</li>
</ul>
<p>一个比较典型的例子是Java当中的<strong>volatile</strong>关键字，对<strong>volatile</strong>变量写指令的后面会加上store屏障，对<strong>volatile</strong>变量读命令的前面会加上load屏障。</p>
<p>关于内存屏障的更多内容，参见<a href="http://www.infoq.com/cn/articles/memory_barriers_jvm_concurrency" target="_blank" rel="external">内存屏障与JVM并发</a></p>
<h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h1><p>如果一个操作的结果对另一个操作是可见的，那么这两个操作必须遵循<strong>happens-before</strong>关系。在这里两个操作可以在同一个线程里面，也可以在不同的线程里面，常见的规则如下：</p>
<ul>
<li>单个线程中的操作，happens-before于其后续操作。</li>
</ul>
<p>这句话很好理解，假定单个线程中的两条指令不存在数据依赖性，那这两条指令则不满足<strong>happens-before</strong>的先决条件；若存在数据的依赖性，则一条指令必定发生在另一条之前。</p>
<ul>
<li>对一个锁的解锁，happens-before于对这个锁的加锁。</li>
<li>对一个<strong>volatile</strong>写操作happens-before于对这个变量的读操作。</li>
</ul>
<h1 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h1><p>是一个理想化的理论模型，主要有两大特征：</p>
<ul>
<li>单个线程的操作必须按照程序的顺序来执行。</li>
<li>每个线程都只有一个单一的执行序列（不管是否同步），且每个操作必须立刻对所有线程可见。</li>
</ul>
<h2 id="JVM的实现"><a href="#JVM的实现" class="headerlink" title="JVM的实现"></a>JVM的实现</h2><h3 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h3><p>还是刚才的RecorderExample,现在修改如下：</p>
<pre><code>public class RecorderExample {
    private boolean flag = false;
    private int i = 0;

    public synchronized void write() {
        i = 1; //1
        flag = true; //2
    }

    public synchronized void read() {
        if (flag) {
            int a = i * i;
        }
    }

    public static void main(String[] args) {
        RecorderExample re = new RecorderExample();
        new Thread(re::write).start();
        new Thread(re::read).start();
    }
}
</code></pre><p>加上<strong>synchronized</strong>关键字之后，<strong>write</strong> happens-before <strong>read</strong>，但是在第一个线程当中，1和2操作是有可能被重排序的，但是对结果没有任何的影响，可以看成是和顺序一致性模型达到了相同的效果。</p>
<h3 id="非同步执行"><a href="#非同步执行" class="headerlink" title="非同步执行"></a>非同步执行</h3><p>非同步的执行结果无法预知，也没有什么实际意义。JVM对非同步执行只提供一种安全性，即在读一个变量的时候，要么是某个其他线程已经设置好的值，要么是零值，这里无需再做分析。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Stephen Zhang" />
          <p class="site-author-name" itemprop="name">Stephen Zhang</p>
          <p class="site-description motion-element" itemprop="description">前进的路上充满着幸福</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">64</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Zhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


</body>
</html>
