<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Stephen Zhang&apos;s notes.">
<meta property="og:type" content="website">
<meta property="og:title" content="Stephen's blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Stephen's blog">
<meta property="og:description" content="Stephen Zhang&apos;s notes.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stephen's blog">
<meta name="twitter:description" content="Stephen Zhang&apos;s notes.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title> Stephen's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Stephen's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/01/iOS-UIView/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/01/iOS-UIView/" itemprop="url">
                  iOS UIView
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-01T20:37:56+08:00">
                2017-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/01/iOS-UIView/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/01/iOS-UIView/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="UIView简介"><a href="#UIView简介" class="headerlink" title="UIView简介"></a>UIView简介</h2><p>官方文档：  </p>
<blockquote>
<p>The UIView class defines a rectangular area on the screen and the interfaces for managing the content in that area.  </p>
</blockquote>
<p>说白了就是一块展现内容还能处理交互的矩形区域，比如一个按钮，一个输入框，重要性不再多说。  </p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p><strong>设置外观</strong><br>这个没什么好说的，常见的有backgroundColor(背景色)，isHidden(是否隐藏)，alpha(透明度)等等。一个比较重要的属性是layer，这个稍后再谈。  </p>
<p><strong>frame, bounds</strong><br>先贴上一篇讲的非常好的博客：<br><a href="http://www.jianshu.com/p/964313cfbdaa" target="_blank" rel="external">frame和bounds的区别</a><br>通俗的讲，frame是针对superview来说的，bounds是针对subview来说的，下面来写一个小程序验证一下有什么作用:<br>代码如下：  </p>
<pre><code>private var subView: UIView?
private var subViewsSubView: UIView?

override func viewDidLoad() {
    super.viewDidLoad()
    setUp()
}

private func setUp() {
    setUpControllButtons()
    setUpSubviews()
} 
    private func setUp() {
    setUpControllButtons()
    setUpSubviews()
}

private func setUpSubviews() {
    subView = UIView(frame: CGRect(x: 40.0, y: 40.0, width: 200, height: 300))
    subViewsSubView = UIView(frame: CGRect(x: 20.0, y: 20.0, width: 50, height: 50))
    subViewsSubView?.backgroundColor = UIColor.yellow
    subView?.backgroundColor = UIColor.blue
    view.addSubview(subView!)
    subView?.addSubview(subViewsSubView!)
}

private func setUpControllButtons() {
    let cb1 = UIButton(frame: CGRect(x: 50.0, y: 500.0, width: 100, height: 100))
    let cb2 = UIButton(frame: CGRect(x: 250.0, y: 500.0, width: 100, height: 100))

    ......

    cb1.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(ViewController.onCb1Click)))
    cb2.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(ViewController.onCb2Click)))

    view.addSubview(cb1)
    view.addSubview(cb2)
}

func onCb1Click() {
    if let subView = self.subView {
        subView.frame = CGRect(x: subView.frame.minX, y: subView.frame.minY, width: subView.frame.width + 10, height: subView.frame.height + 10)
    }
}

func onCb2Click() {
    if let subView = self.subView {
        subView.bounds = CGRect(x: subView.bounds.minX + 10, y: subView.bounds.minY + 10, width: subView.bounds.width, height: subView.bounds.height)
    }
}
</code></pre><p>程序很简单，先是创建一个subView，设置其在父view(即Controller的RootView)的坐标(40.0, 40.0)，宽200，高300。再往subView里面添加子视图subViewsSubView，其相对于subView的坐标为(20.0, 20.0)。两个控制的按钮，一个title为frame，点击的效果是将subView的frame宽高都加10，效果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/screen1.gif" alt=""><br>可见frame的宽和高便是控件实际的宽高，而且改变之后，整个矩形区域的左上角的位置不发生改变，宽和高加长，现在修改onCb1Click()方法：</p>
<pre><code>func onCb1Click() {
    if let subView = self.subView {
        subView.frame = CGRect(x: subView.frame.minX + 10, y: subView.frame.minY + 10, width: subView.frame.width, height: subView.frame.height)
    }
}
</code></pre><p>运行效果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/screen2.gif" alt=""><br>可见frame的minX, minY是矩形区域左上角在父view的坐标，当其改变时，它在父view的位置便发生了改变。<br>下面来看bounds按钮点击的效果：<br><img src="http://ok34fi9ya.bkt.clouddn.com/screen3.gif" alt=""><br>当bounds的宽高改变的时候，view的宽高也会改变，不同的是frame的宽高改变的时候不动点在左上角，而bounds的宽高改变的时候不动点在view初始的center。改变onCb2Click()方法如下：</p>
<pre><code>func onCb2Click() {
    if let subView = self.subView {
        subView.bounds = CGRect(x: subView.bounds.minX - 10, y: subView.bounds.minY - 10, width: subView.bounds.width, height: subView.bounds.height)
    }
}
</code></pre><p>运行效果如图：<br><img src="http://ok34fi9ya.bkt.clouddn.com/screen4.gif" alt=""><br>这里应该这么想，初始的时候bounds的minX, minY都是0(坐标原点)，现在将其都剪去10，那么左上角变成了(-10, -10)，坐标原点向右下角移动，子view的位置是根据坐标原点的位置确定的，所以子view也跟着右下角移动了。</p>
<p><strong>处理交互事件</strong><br>UIView继承于UIResponder，若想自定义的view按照自己的逻辑处理交互事件的话，需要重写四个方法：  </p>
<pre><code>func touchesBegan(Set&lt;UITouch&gt;, with: UIEvent?)
func touchesMoved(Set&lt;UITouch&gt;, with: UIEvent?)
func touchesEnded(Set&lt;UITouch&gt;, with: UIEvent?)
func touchesCancelled(Set&lt;UITouch&gt;, with: UIEvent?)
</code></pre><p>这四个具体怎么用请看官方文档（我就是懒）<br>还有一种简单一点的办法，是在view初始化的时候给它注册GestureRecogniser，这时候target是自己就可以了。  </p>
<p><strong>layer属性</strong><br>这是个比较重要的属性，可以控制view的外观，像圆角，阴影，渐变背景色都可以通过它来设置（搞不懂为什么view可以直接设置背景色向外暴露backgroundColor属性，不优雅），不过我认为它并不如安卓那样通过xml来控制简单方便。它是一个CALayer类，几个常用的属性：  </p>
<pre><code>var cornerRadius: CGFloat { get set } //设置圆角
var borderWidth: CGFloat { get set } //边框的宽度
var borderColor: CGColor? { get set } //边框的颜色
var backgroundColor: CGColor? { get set } //背景色
</code></pre><p>此外，它还有一系列的子类，例如CAGradientLayer(设置渐变色)，CATextLayer, CAShapeLayer。下面画一个拥有渐变色背景的Button吧！ 代码如下：  </p>
<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    setUp()
}

private func setUp() {
    let button = UIButton()
    button.frame = CGRect(x: 40.0, y: 40.0, width: 300, height: 200)
    view.addSubview(button)

    let backgroundLayer = CAGradientLayer()
    //设置frame，不要忽略这一步！
    backgroundLayer.frame = button.layer.bounds
    //设置起点和终点, 范围是(0,0) -&gt; (1, 1)
    backgroundLayer.startPoint = CGPoint(x: 0.5, y: 1.0)
    backgroundLayer.endPoint = CGPoint(x: 0.5, y: 0.0)
    //渐变颜色数组
    backgroundLayer.colors = [ UIColor.blue.cgColor, UIColor.red.cgColor ]
    button.layer.addSublayer(backgroundLayer)

    button.layer.cornerRadius = 10
}
</code></pre><p>运行效果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/IMG_2159.PNG" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/01/iOS-ViewController/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/01/iOS-ViewController/" itemprop="url">
                  iOS ViewController
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-01T18:56:10+08:00">
                2017-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/01/iOS-ViewController/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/01/iOS-ViewController/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="UIViewController简介"><a href="#UIViewController简介" class="headerlink" title="UIViewController简介"></a>UIViewController简介</h2><p>官方文档：  </p>
<blockquote>
<p>The UIViewController class provides the infrastructure for managing the views of your iOS apps. A view controller manages a set of views that make up a portion of your app’s user interface. It is responsible for loading and disposing of those views, for managing interactions with those views, and for coordinating responses with any appropriate data objects. View controllers also coordinate their efforts with other controller objects—including other view controllers—and help manage your app’s overall interface.</p>
</blockquote>
<p>用通俗的话来讲，他就是mvc层的c(Controller)，用于View层和Model层的通信，跟Android里面的Activity十分类似，但是比其要灵活不少，貌似还不是很臃肿……</p>
<h2 id="UIViewController生命周期"><a href="#UIViewController生命周期" class="headerlink" title="UIViewController生命周期"></a>UIViewController生命周期</h2><p>主要是这几个部分：  </p>
<ol>
<li>初始化  </li>
<li>如果是通过其他ViewController通过segue导航而来的话，那就根据segue的要求进行初始化  </li>
<li>Outlet设置  </li>
<li>viewDidLoad()</li>
<li>viewWillAppear()  </li>
<li>viewWillLayoutSubviews()  </li>
<li>viewDidLayoutSubviews()  </li>
<li>(6,7步多次调用之后) viewDidAppear()  </li>
<li>(界面离开屏幕)viewWillDisappear()  </li>
<li>(6,7步多次调用)viewDidDisappear()<br>这几个函数的顺序我就不验证了，懒，值得注意的地方在于第二步和第三步的顺序不能颠倒，也就是说，如果在prepare()阶段通过segue的destination来修改目标Controller的Outlet标签成员的话，会崩溃的。  <h2 id="UIViewController的主要职责"><a href="#UIViewController的主要职责" class="headerlink" title="UIViewController的主要职责"></a>UIViewController的主要职责</h2><strong>管理views</strong><br><img src="http://ok34fi9ya.bkt.clouddn.com/ViewController1.png" alt=""><br>UIViewController有一个view属性，便是上图中的RootView，RootView的子视图也可以交给Controller来进行管理，例如Outlet标签标记的视图。  </li>
</ol>
<p><strong>管理子Controller</strong><br><img src="http://ok34fi9ya.bkt.clouddn.com/ViewController2.png" alt=""><br>上图中，SplitViewController管理着两个子Controller，分别是master controller和detail controller，这两个Controller的内容是包裹在父Controller的Container里面的（只能在iPad上面看到全部的内容）。  </p>
<p><strong>处理与用户交互有关的事件</strong><br>Controller可以处理与其管理的views有关的交互事件（触摸，点击，滑动……）实现的方式有两种。一种就是直接从Storyboard按住ctrl拖(既不优雅也没效率)，实现一个标记IAction属性的方法，这种方法通常是用来处理单一的例如Touch up inside的单一事件。另一种实现方式是在管理的view上面添加GestureRecogniser，iOS sdk自己给出的几个recogniser真是太好用了，这里给出一段示例代码：</p>
<pre><code>- (void)viewDidLoad {
     [super viewDidLoad];

     // 创建TabGestureRecogniser
     UITapGestureRecognizer *tapRecognizer = [[UITapGestureRecognizer alloc]
      initWithTarget:self action:@selector(respondToTapGesture:)];

     // 配置TabGestureRecogniser
     tapRecognizer.numberOfTapsRequired = 1;

     // 为view添加GestureRecogniser
     [self.view addGestureRecognizer:tapRecognizer];
}
</code></pre><p>接下来Controller只需要实现selector里面的方法就可以了，个人感觉这真是太优雅了，比安卓提供的丰富多彩很多（安卓好像就几个ClickListener）  </p>
<p><strong>作为管理的view的委托类</strong><br>一个典型示例便是UITableViewController，它的内部持有一个tableView，在这个view加载的时候，便调用其delegate属性的一系列方法，例如获取sections的个数，获取每一个section有多少行，每行的高度是多少等等。而管理它的Controller便实现了UITableView的委托协议，这样我们就可以在Controller内部实现相应的方法，进而管理tableView。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/22/Java-ReferenceQueue实战/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/22/Java-ReferenceQueue实战/" itemprop="url">
                  Java ReferenceQueue实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-22T22:28:09+08:00">
                2017-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/22/Java-ReferenceQueue实战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/22/Java-ReferenceQueue实战/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="浅谈ReferenceQueue"><a href="#浅谈ReferenceQueue" class="headerlink" title="浅谈ReferenceQueue"></a>浅谈ReferenceQueue</h2><p>先看官方文档对这个类的介绍：  </p>
<blockquote>
<p>Reference queues, to which registered reference objects are appended by the<br>garbage collector after the appropriate reachability changes are detected.  </p>
</blockquote>
<p>这个的大体意思是这样的，当一个Reference类所指向的实际对象被回收的时候，这个Referece便会加入到这个队列里面，这个队列提供了三个操作：</p>
<pre><code>public Reference&lt;? extends T&gt; poll();

public Reference&lt;? extends T&gt; remove(long timeout);

public Reference&lt;? extends T&gt; remove();
</code></pre><p>三个都是出队操作，后两个remove是阻塞方法，具体请看官方文档，懒得解释。</p>
<h2 id="ReferenceQueue实战"><a href="#ReferenceQueue实战" class="headerlink" title="ReferenceQueue实战"></a>ReferenceQueue实战</h2><p>笔者将用一个简单粗暴的例子来解释这个类的实际用途。假设在一个公司的内部，有员工(Staff)，有事务(Work)，每一个事务都必须对应一个员工去做。假如这个员工突然有急事请假了，或者工作太累不小心嗝屁了（相应的Staff类实例被回收了），那这个Work类实例可以做一些清理工作，或者通知其他相关类它所对应的Staff已经被回收。那么这个模型就可以完美地应用ReferenceQueue，下面是代码实现：</p>
<p>Work类：</p>
<pre><code>public class Work {
    static class StaffWeakReference extends WeakReference&lt;Staff&gt; {
        Work work;

        public StaffWeakReference(Work work, Staff referent, ReferenceQueue&lt;? super Staff&gt; q) {
            super(referent, q);
            this.work = work;
        }
    }

    StaffWeakReference swReference;

    Work(Staff staff, ReferenceQueue&lt;? super Staff&gt; referenceQueue) {
        swReference = new StaffWeakReference(this, staff, referenceQueue);
    }

    public void cancel() {
        // 可以做一些清理工作，或者通知其他相关类它所对应的Staff已经被回收
    }
}
</code></pre><p>Company类：</p>
<pre><code>public class Company {

    static class CleanUpThread extends Thread {
        ReferenceQueue&lt;?&gt; referenceQueue;
        static final long TIME_OUT = 1000;

        CleanUpThread(ReferenceQueue&lt;?&gt; referenceQueue) {
            this.referenceQueue = referenceQueue;
        }

        @Override
        public void run() {
            while (true) {
                try {
                    Work.StaffWeakReference reference = (Work.StaffWeakReference) referenceQueue.remove(TIME_OUT);
                    if (reference != null) {
                        reference.work.cancel();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        ReferenceQueue&lt;Staff&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
        CleanUpThread cleanUpThread = new CleanUpThread(referenceQueue);
        cleanUpThread.start();
        Staff staff = new Staff();
        Work work = new Work(staff, referenceQueue);
        ...
        ...
    }
}
</code></pre><p>当main开始运行的时候，先开启一个CleanUpThread，这个类的run方法内部则是不断的从传入的ReferenceQueue当中读取所指向Staff对象已经被回收的引用，如果某个Staff已经被回收，那它在对应的Work里面对应的弱引用便会读取出来，这时候就可以调用读出的弱引用对应的Staff已经被回收的Work的cancel方法了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/20/Picasso源码分析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/20/Picasso源码分析/" itemprop="url">
                  Picasso源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-20T19:03:32+08:00">
                2017-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/20/Picasso源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/20/Picasso源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Picasso简介"><a href="#Picasso简介" class="headerlink" title="Picasso简介"></a>Picasso简介</h2><p>Picasso是大名鼎鼎的Square公司推出的安卓图片下载，缓存的第三方库。上手简单，功能强大。在此本文就不介绍它具体是怎么使用的了，给出几个已经讲的很好的博文地址即可：  </p>
<p>Github地址： <a href="http://square.github.io/picasso/" target="_blank" rel="external">http://square.github.io/picasso/</a><br>Picasso使用详解： <a href="http://www.jianshu.com/p/ae8e6ed18e23" target="_blank" rel="external">http://www.jianshu.com/p/ae8e6ed18e23</a>  </p>
<p>Github上的源码中的示例代码是个不错的学习资源哦！</p>
<h2 id="Picasso工作原理"><a href="#Picasso工作原理" class="headerlink" title="Picasso工作原理"></a>Picasso工作原理</h2><p>工作原理如图所示，图中所标记的类下文会一一进行剖析。（笔者的图确实画的不怎么样，见谅）  </p>
<p><img src="http://ok34fi9ya.bkt.clouddn.com/picasso_structure.png" alt="Picasso Structure"> </p>
<p><strong>注：</strong> 图中没有列出像LruCache, OkHttpDownloader等涉及到大量技术细节的类，没有什么值得讨论的，感兴趣的可以自行看源码。</p>
<p><strong>Picasso</strong>类<br>提供给用户使用的顶层类，通过一个依附在主线程（mainThread)的Handler与Dispatcher中的DispatcherThread的Handler交互，其主要类成员和方法为：  </p>
<pre><code>Map&lt;Object, Action&gt; targetToAction; //Picasso管理Action的工具
Map&lt;ImageView, DeferredRequestCreator&gt; targetToRequestCreator; //管理ImageView
Handler HANDLER = new Handler(Looper.getMainLooper()) { ... } //用于通知Action图片加载成功（或者失败），以及重新提交Action(resumeAction)
Dispatcher dispatcher; //用于处理提交（submit)和取消（cancel)操作

...

Picasso.with(Context); //单例模式提供默认的Picasso类
picasso.load(Uri); //向外提供一个RequestCreator
picasso.enqueueAndSubmit(Action); //提交Action给Dispatcher处理
picasso.resumeAction(Action); //重新提交Action给Dispatcher
picasso.complete(BitmapHunter); //从中获取Action，通知主线程图片加载失败或者成功
picasso.deliverAction(Action); //通知主线程图片加载成功（action.complete)或者失败(action.error)
picasso.cancelExistingRequest(Object); //通过Tag从targetToAction中获取到Action, 并通知dispatcher取消此action， 如果Target是ImageView的话还会从targetToRequestCreator中得到DeferredRequestCreator并通知起取消。
</code></pre><p><strong>Dispatcher类</strong><br>dispatcher，顾名思义，掌管“事件”的奋发，Picasso通过它来取消或者提交Action，BitmapHunter通过它来与Picasso当中的HANDLER进行通信。其内部有一个DispatcherThread和相应的DispatcherHandler，在此线程内处理各种事件。其主要的类成员和方法为： </p>
<pre><code>Map&lt;String, BitmapHunter&gt; hunterMap; // String是key类型，从Action.getKey()获取
Map&lt;Object, Action&gt; failedAction; // 失败的Action
Map&lt;Object, Action&gt; pausedAction; //处在暂停状态的Action
Handler handler; //即DispatcherThread的Handler
Handler mainThreadHandler; //即Picasso维持的主线程的Handler

...

dispatchSubmit(Action); //提交Action
dispatchCancel(Action); //取消Action
dispatchPauseTag(Object); //根据Tag暂停相应的Action
dispatchResumeTag(Object); //根据相应的Tag重新开始相应的Action
dispatchComplete(BitmapHunter); //BitmapHunter成功抓取图片回调
dispatchFailed(BitmapHunter); //BitmapHunter抓取图片失败回调
</code></pre><p><strong>Action类</strong><br>在笔者看来，这个类代表着从开始请求到请求成功或者失败的“动作”，在这整个流程里面，包括一开始使用的Picasso, 还有所构造出来的Request, 所使用的存储策略(memoryPolicy)、网络策略(networkPolicy),失败时的默认图片，以及标志这个动作的Tag都包含在里面。代表成功或者失败则是两个抽象方法：</p>
<pre><code>abstract void complete(Bitmap result, Picasso.LoadedFrom from);

abstract void error(Exception e);
</code></pre><p>这两个方法由它的子类具体来实现，典型的<a href="https://zh.wikipedia.org/wiki/策略模式" target="_blank" rel="external">策略模式</a>，其主要类成员如下所示：</p>
<pre><code>Picasso picasso;
Request request;
WeakReference&lt;T&gt; target;
int memoryPolicy;
int networkPolicy;
int errorResId;
Drawable errorDrawable;
String key;     //一个key对应一个相应的BitmapHunter
Object tag;        //标志此Action
</code></pre><p><strong>BitmapHunter类</strong><br>这个嘛，顾名思义（英文好是多么重要），就是用来抓图的，它是一个Runnable，并且通过key和一个（或者一些）Action关联起来。当Dispatcher调用perform(Action)这个方法的时候，会通过Action的key找到相应的BitmapHunter， 并且通过从Picasso传来的ExcutorService来运行这个Hunter，抓取成功或者失败后则会通知其内部持有的Dispatcher。主要的成员及方法如下：</p>
<pre><code>Dispatcher dispatcher;
String key;
Action action; //当前处理的Action
List&lt;Action&gt; actions; //key相同的actions.
Future&lt;?&gt; future; //提交到ExcutorService后对应的Future，可以用来取消请求

...

hunt(); //抓取图片
forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats, Action action); //静态方法构造Hunter.
attach(Action); //将其加入到actions当中
detach(Action); //与上述方法对应
cancel(); //取消此请求
</code></pre><p>hunt()方法源码为：</p>
<pre><code>Bitmap hunt() throws IOException {
    Bitmap bitmap = null;

    //是否能从缓存读取
    if (shouldReadFromMemoryCache(memoryPolicy)) {
        bitmap = cache.get(key);
        if (bitmap != null) {
            stats.dispatchCacheHit();
            loadedFrom = MEMORY;
            ...
            ...
            return bitmap;
        }
    }

    data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;
    //通过requetHandler来处理请求
    RequestHandler.Result result = requestHandler.load(data, networkPolicy);
    if (result != null) {
        loadedFrom = result.getLoadedFrom();
        exifOrientation = result.getExifOrientation();
        bitmap = result.getBitmap();

        // If there was no Bitmap then we need to decode it from the stream.
        if (bitmap == null) {
            InputStream is = result.getStream();
            try {
                bitmap = decodeStream(is, data);
            } finally {
                Utils.closeQuietly(is);
            }
        }
    }

    if (bitmap != null) {
       ...
       ...
       ... //对其进行相应的转换操作
    }

    return bitmap;
}
</code></pre><p><strong>Request类</strong><br>此类包含着请求的数据，包括请求的Uri，对图片所要进行的转换（Transformation)，是否进行centerCrop，centerInside，是否进行旋转，旋转的角度……太简单不必细说。</p>
<p><strong>RequestCreator类</strong><br>此类由Picasso.load(Uri)方法暴露给用户，提供各种方法，如resize(), centerCrop(), centerInside(), fit()来记录用户对图片的需求，并且更新内部所持有的Request，还提供了三个很重要的方法， fetch(), get(), into(Target)，这三个方法最后都是根据实际情况了构造了不同的Action，并且同Picasso通信，通知Picasso将Action发送出去（即通知Dispatcher来处理它）。</p>
<p><strong>RequestHandler类</strong><br>注意这个可不是安卓线程通信所使用的Handler，这是用来处理请求的，其内部类RequestHandler.Result表示处理的结果，其结构为：</p>
<pre><code>Picasso.LoadedFrom loadedFrom;
Bitmap bitmap;
InputStream stream;
int exifOrientation;

//构造函数
Result(
            @Nullable Bitmap bitmap,
            @Nullable InputStream stream,
            @NonNull Picasso.LoadedFrom loadedFrom,
            int exifOrientation) {
        //两个至少一个不为空
        if ((bitmap != null) == (stream != null)) {
            throw new AssertionError();
        }
        this.bitmap = bitmap;
        this.stream = stream;
        this.loadedFrom = checkNotNull(loadedFrom, &quot;loadedFrom == null&quot;);
        this.exifOrientation = exifOrientation;
    }
</code></pre><p>可以通过这个类来实现自己加载图片的逻辑，需要实现两个抽象方法：</p>
<pre><code>abstract boolean canHandleRequest(Request data);

abstract Result load(Request request, int networkPolicy)；
</code></pre><p>此外，Picasso库也给我们提供了一系列内置的RequestHandler，如NetworkRequestHandler, MediaStoreRequestHandler, FileRequestHandler,分别用来处理不同类型的请求，这些内置的RequestHandler将默认提供给Picasso类。</p>
<p><strong>Target类</strong><br>这是一个接口，可以看作是一个简单的图片加载的监听器，内部有三个方法：</p>
<pre><code>void onBitmapLoaded(Bitmap bitmap, LoadedFrom from);

void onBitmapFailed(Exception e, Drawable errorDrawable);

void onPrepareLoad(Drawable placeHolderDrawable);
</code></pre><p>一看名字就知道是干什么的，不必多说。需要注意的一点就是ImageView可以看作是一种特殊的Target，但是IamgeView没有实现Target接口，因此Picasso库针对ImageView有特殊的处理。</p>
<p><strong>DeferredRequestHandler</strong><br>这个既和线程通信没有联系，也和之前的RequestHandler没有联系，它实现了<a href="https://developer.android.com/reference/android/view/ViewTreeObserver.OnDrawListener.html" target="_blank" rel="external">ViewTreeObserver.OnPreDrawListener</a>这个接口。这个就是上文所说Picasso库针对ImageView的情况提供的特殊的类。当我们调用RequestCreator.fit()的时候，会触发RequestCreator中的defer标志，最后在调用into(ImageView)的时候会对目标ImageView的<a href="https://developer.android.com/reference/android/view/ViewTreeObserver.html" target="_blank" rel="external">ViewTreeObserver</a>注册一个DeferredRequestCreator，这样便在目标ImageView加入到所属的ViewTree的时候在preDraw过程中对其进行处理，处理的大致逻辑如下所示：</p>
<pre><code>public boolean onPreDraw() {
    ...
    ...
    int width = target.getWidth();
    int height = target.getHeight();

    if (width &lt;= 0 || height &lt;= 0 || target.isLayoutRequested()) {
        return true;
    }

    vto.removeOnPreDrawListener(this);
    this.target.clear();

    this.creator.unfit().resize(width, height).into(target, callback);
    return true;
}
</code></pre><p>最后还是回归到RequestCreator的resize操作，来达到所谓的”fit exactly”的效果。</p>
<h2 id="Picasso工作流程源码分析"><a href="#Picasso工作流程源码分析" class="headerlink" title="Picasso工作流程源码分析"></a>Picasso工作流程源码分析</h2><p>首先，我们从最基本的操作开始，一步一步加以分析。</p>
<pre><code>Picasso.with(Context)
      .load(Uri)
      ....
      .into(Target);
</code></pre><p><strong>注：</strong>第三行的…对应的是RequestCreator的各种“操作符”，由于数量太多，这里不一一列举。  </p>
<p><strong>Picasso.with(context)</strong><br>源码如下：</p>
<pre><code>public static Picasso with(@NonNull Context context) {
    if (context == null) {
        throw new IllegalArgumentException(&quot;context == null&quot;);
    }
    if (singleton == null) {
        synchronized (Picasso.class) {
            if (singleton == null) {
                //默认使用OkHttp3Downloader和LruCache.
                singleton = new Builder(context).build();
            }
        }
    }
    return singleton;
}
</code></pre><p>这个不需要过多的解释，经典的DCL单例模式，其中需要注意的是Builder里面的build()方法：</p>
<pre><code>public Picasso build() {
        Context context = this.context;

        if (downloader == null) {
            downloader = new OkHttp3Downloader(context);
        }
        if (cache == null) {
            cache = new LruCache(context);
        }
        if (service == null) {
            service = new PicassoExecutorService();
        }
        if (transformer == null) {
            transformer = RequestTransformer.IDENTITY;
        }

        Stats stats = new Stats(cache);

        Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);

        return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,
                defaultBitmapConfig, indicatorsEnabled, loggingEnabled);
    }
</code></pre><p>由此可以看出如果采用默认的Picasso类的话，会采用OkHttp3Downloader, LruCache和PicassoExcutorService，这些便是默认配置。</p>
<p><strong>picasso.load(Uri)</strong><br>不论调用的是picasso.load(String)也好，还是picasso.load(File)也好都会调用picasso.load(Uri)方法(picasso.load(int)除外)，只不过是将String和File转成Uri而已，其源码也比较简单，就是构造一个RequestCreator返回而已，不再细谈。</p>
<p><strong>RequestCreator的各种“操作符”</strong><br>由于操作符实在是太多，这里只粘出几个具有代表性的：</p>
<pre><code>public RequestCreator resize(int targetWidth, int targetHeight) {
    data.resize(targetWidth, targetHeight);
    return this;
}

public RequestCreator centerCrop() {
    data.centerCrop(Gravity.CENTER);
    return this;
}

public RequestCreator error(@DrawableRes int errorResId) {
    if (errorResId == 0) {
        throw new IllegalArgumentException(&quot;Error image resource invalid.&quot;);
    }
    if (errorDrawable != null) {
        throw new IllegalStateException(&quot;Error image already set.&quot;);
    }
    this.errorResId = errorResId;
    return this;
}

public RequestCreator fit() {
    deferred = true;
    return this;
}
...
</code></pre><p>可以看到，有些操作是改变的RequestCreator本身具有的一些属性（error(), fit())，还有一些便是将参数传给了data，这个data类型是一个Request.Builder，RequestCreator在这个时候便充当了“中介人”的角色吧。</p>
<p><strong>RequestCreator.into(…)</strong><br>这个方法便是根据参数的类型来构造一个Action并通知Picasso类发送出去。</p>
<pre><code>public void into(@NonNull Target target) {
    ...
    ...

    Request request = createRequest(started);
    String requestKey = createKey(request);

    //先判断能否从缓存当中读取
    if (shouldReadFromMemoryCache(memoryPolicy)) {
        Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);
        if (bitmap != null) {
            picasso.cancelRequest(target);
            target.onBitmapLoaded(bitmap, MEMORY);
            return;
        }
    }

    target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : null);

    //构造Action并发送
    Action action =
            new TargetAction(picasso, target, request, memoryPolicy, networkPolicy, errorDrawable,
                    requestKey, tag, errorResId);
    picasso.enqueueAndSubmit(action);
}
</code></pre><p>当参数为ImageView的时候有特殊情况：</p>
<pre><code>public void into(ImageView target, Callback callback) {
    ...
    ...

    if (deferred) {
        if (data.hasSize()) {
            throw new IllegalStateException(&quot;Fit cannot be used with resize.&quot;);
        }
        int width = target.getWidth();
        int height = target.getHeight();
        if (width == 0 || height == 0 || target.isLayoutRequested()) {
            if (setPlaceholder) {
                setPlaceholder(target, getPlaceholderDrawable());
            }
            picasso.defer(target, new DeferredRequestCreator(this, target, callback));
            return;
        }
        data.resize(width, height);
    }

    ...
    ...

    Action action =
            new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,
                    errorDrawable, requestKey, tag, callback, noFade);

    picasso.enqueueAndSubmit(action);
}
</code></pre><p>如果之前调用过fit方法的时候，deferred标志位就会开启，这个时候就会构造一个DeferredRequestCreator，并注册到目标ImageView的ViewTreeObserver当中，并且将其写入picasso所持有的targetToDeferredRequestCreator当中。</p>
<p><strong>Picasso.enqueueAndSubmit(Action)</strong><br>正如上面看到的，RequestCreator.into(…)到最后一步都是构建对应的Action并调用picasso.enqueueAndSubmit(action)方法，下面就顺着这个方法进行分析：</p>
<pre><code>void enqueueAndSubmit(Action action) {
    Object target = action.getTarget();
    if (target != null &amp;&amp; targetToAction.get(target) != action) {
        // This will also check we are on the main thread.
        cancelExistingRequest(target);
        targetToAction.put(target, action);
    }
    submit(action);
}
</code></pre><p>先判断以传进来的的action的target作为键在targetToAction中得来的的action值是不是当前传进来的action，如果不是，则先取消target的请求，再将target和当前传递的action键值对传到字典当中，最后调用submit方法，submit方法如下：</p>
<pre><code>void submit(Action action) {
    dispatcher.dispatchSubmit(action);
}
</code></pre><p>很简单粗暴地就调用了dispatcher的dispatchSubmit(action)方法来处理此action，下面来分析dispatcher.dispatchSubmit(action)方法。</p>
<p><strong>dispatcher.dispatchSubmit(action)</strong><br>源码如下：</p>
<pre><code>void dispatchSubmit(Action action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));
}
</code></pre><p>一层一层往下看，最终调用的是performSubmit(Action)方法：  </p>
<pre><code>void performSubmit(Action action) {
    performSubmit(action, true);
  }

  void performSubmit(Action action, boolean dismissFailed) {
        if (pausedTags.contains(action.getTag())) {
          pausedActions.put(action.getTarget(), action);
          ...
          ...
          return;
    }

    BitmapHunter hunter = hunterMap.get(action.getKey());
    if (hunter != null) {
          hunter.attach(action);
          return;
    }

    if (service.isShutdown()) {
          ...
          ...
          return;
    }

    hunter = forRequest(action.getPicasso(), this, cache, stats, action);
    hunter.future = service.submit(hunter);
    hunterMap.put(action.getKey(), hunter);
    if (dismissFailed) {
          failedActions.remove(action.getTarget());
    }
    ...
    ...
}
</code></pre><p>逻辑也不是多么的复杂，如果标记Action的Tag在pausedTag当中的话（下面会讲tag对应的操作），便直接返回不做处理。再判断hunterMap中是不是有传入的action的key对应的BitmapHunter，如果有，便调用attach方法并返回。attach方法较简单，更新BitmapHunter当前的action或者将其加入到List<action>当中。下一步判断ExcutorService是不是已经处在关闭的状态，这是为下面一步做准备。如果没有，便构造出一个BitmapHunter，并将这个Hunter（本身便是一个Runnable)加入到service当中，最后更新hunterMap。</action></p>
<p><strong>dispatcher.dispatchComplete(BitmapHunter) dispatcher.dispatchFailed(BitmapHunter)</strong><br>当此Runnable加入到ExcutorService当中后便开始运行，其run方法如下所示：</p>
<pre><code>public void run() {
    try {
        updateThreadName(data);

        ...
        ...

        result = hunt();

        if (result == null) {
            dispatcher.dispatchFailed(this);
        } else {
            dispatcher.dispatchComplete(this);
        }
    } ...
     finally {
        Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);
    }
}
</code></pre><p>每一个catch字句最后都会调用dispatcher.dispatchFailed(BitmapHunter)，逻辑比较简单，这里省去。run()方法内部还是比较直观的，先是更新当前线程的名称，再调用hunt()方法获取到一个Bitmap，如果为空就调用dispatchFailed，不为空就调用dispatchComplete。  </p>
<p>同样，两个dispatch方法也只是通过DispatcherThreadHandler通知DispatcherThread进行相应的操作，最后调用的是performComplete(BitmapHunter)和performError(BitmapHunter)方法，源码如下：</p>
<pre><code>void performComplete(BitmapHunter hunter) {
    //是否应该写入缓存
    if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) {
          cache.set(hunter.getKey(), hunter.getResult());
    }
    hunterMap.remove(hunter.getKey());
    batch(hunter);
  }

  void performError(BitmapHunter hunter, boolean willReplay) {
       hunterMap.remove(hunter.getKey());
    batch(hunter);
   }
</code></pre><p>逻辑比较简单，两者共同的操作是更新hunterMap和调用batch(hunter)，区别就是performComplete方法第一步先判断是否要写入缓存。batch(BitmapHunter)方法源码如下：</p>
<pre><code>private void batch(BitmapHunter hunter) {
    if (hunter.isCancelled()) {
          return;
    }
    batch.add(hunter);
    if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) {
          handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);
    }
  }
</code></pre><p>逻辑也是比较直观的，其中batch是一个List<bitmaphunter>，这个和下面sendEmptyMessageDelayed方法结合在一块用，起到了一定的缓存的作用。这个消息发送出去之后，最终调用的是performBatchComplete()，源码如下：</bitmaphunter></p>
<pre><code>void performBatchComplete() {
    List&lt;BitmapHunter&gt; copy = new ArrayList&lt;&gt;(batch);
    batch.clear();
    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));
  }
</code></pre><p>此方法先将缓存复制一份，再将缓存清空，最后通知主线程开始处理复制好的缓存数据，最终调用的是Picasso当中的complete(BitmapHunter)方法。</p>
<p><strong>Picasso.complete(BitmapHunter)</strong><br>源码如下：</p>
<pre><code>void complete(BitmapHunter hunter) {
    Action single = hunter.getAction();
    List&lt;Action&gt; joined = hunter.getActions();

    boolean hasMultiple = joined != null &amp;&amp; !joined.isEmpty();
    boolean shouldDeliver = single != null || hasMultiple;

    if (!shouldDeliver) {
        return;
    }

    Uri uri = hunter.getData().uri;
    Exception exception = hunter.getException();
    Bitmap result = hunter.getResult();
    LoadedFrom from = hunter.getLoadedFrom();

    if (single != null) {
        deliverAction(result, from, single, exception);
    }

    if (hasMultiple) {
        //noinspection ForLoopReplaceableByForEach
        for (int i = 0, n = joined.size(); i &lt; n; i++) {
            Action join = joined.get(i);
            deliverAction(result, from, join, exception);
        }
    }

    if (listener != null &amp;&amp; exception != null) {
        listener.onImageLoadFailed(this, uri, exception);
    }
}
</code></pre><p>如果这个Hunter只有一个那就调用一次deliverAction(…)，如果获得的joined列表不为空，那就对其中的Action依次调用deliverAction(…)， deliverAction(…)源码如下：</p>
<pre><code>private void deliverAction(Bitmap result, LoadedFrom from, Action action, Exception e) {
    ...
    ...
    if (result != null) {
        ...
        action.complete(result, from);
        ...
    } else {
        action.error(e);
        ...
    }
}
</code></pre><p>不必多说，最后根据result是否为空调用action的complete或者error方法。就拿ImageViewAction来说吧，成功的话，就会将图片加载到对应的ImageView中去（此时ImageView是此Action的Target)，失败则加载errorImage，整个工作流程就此结束。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/lion.jpg"
               alt="Stephen Zhang" />
          <p class="site-author-name" itemprop="name">Stephen Zhang</p>
          <p class="site-description motion-element" itemprop="description">Stephen Zhang's notes.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Zhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zsrcodingme"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
