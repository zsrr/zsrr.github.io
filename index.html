<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="zsr的小本本">
<meta property="og:type" content="website">
<meta property="og:title" content="Stephen's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Stephen's blog">
<meta property="og:description" content="zsr的小本本">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stephen's blog">
<meta name="twitter:description" content="zsr的小本本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Stephen's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Stephen's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/22/Java非阻塞算法/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/22/Java非阻塞算法/" itemprop="url">
                  Java非阻塞算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-22T16:18:13+08:00">
                2017-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/22/Java非阻塞算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/22/Java非阻塞算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>啊，于今日可算是看完了《Java并发编程实战》这本书。</p>
<h1 id="非阻塞算法简介"><a href="#非阻塞算法简介" class="headerlink" title="非阻塞算法简介"></a>非阻塞算法简介</h1><p>在基于锁的并发实现中，如果一个线程在持有锁时发生阻塞I/O，socket阻塞等等状况，那可能其他等待获取锁的线程都不能执行下去。如果某种算法使线程的失败不会导致此线程挂起或着阻塞至条件为真，只是单纯地返回，那么此算法称为非阻塞算法，通常在硬件层面得到支持。非阻塞算法在中低下的竞争环境下比锁的性能要好得多。</p>
<h1 id="基于CAS的非阻塞算法"><a href="#基于CAS的非阻塞算法" class="headerlink" title="基于CAS的非阻塞算法"></a>基于CAS的非阻塞算法</h1><p>在大多数的处理器架构中采用比较并交换（Compare And Swap）的方法实现非阻塞算法。CAS包含了三个操作数——需要读写的内存位置V，进行的比较的值A和要设置的值B，只有当V中的值为A时，CAS才会通过原子的方式将V中的值设置为B。<strong>java.util.concurrent.atomic</strong>包下的各种原子类都提供了CAS操作。</p>
<p>下面通过实现一个非阻塞计数器来说明CAS非阻塞算法的用法：</p>
<pre><code>public class CASCounter {
    private AtomicInteger counter = new AtomicInteger(0);

    public int getValue() {
        return counter.get();
    }

    public void increase() {
        int v;
        do {
            v = counter.get();
        } while (!counter.compareAndSet(v, v + 1));
    }
}
</code></pre><p>如果其他线程比当前线程提前更新了counter的值，那么将会导致此线程进行重试。CAS算法一个麻烦的地方就是要自己手动写重试的条件及内容。</p>
<h1 id="非阻塞数据结构"><a href="#非阻塞数据结构" class="headerlink" title="非阻塞数据结构"></a>非阻塞数据结构</h1><p>在使用过程中不会使当前线程发生阻塞的数据结构为非阻塞数据结构。如<strong>ArrayBlockingQueue</strong>为阻塞数据结构，<strong>ConcurrentLinkedQueue</strong>为非阻塞数据结构。</p>
<p>非阻塞数据结构一般设计起来比较困难，需要专业算法工程师进行操作，下面通过两个简单的例子来说明非阻塞数据结构的设计使用。</p>
<h2 id="非阻塞栈"><a href="#非阻塞栈" class="headerlink" title="非阻塞栈"></a>非阻塞栈</h2><p>下面通过<strong>Treiber</strong>算法实现一个非阻塞的栈：</p>
<pre><code>public class ConcurrentStack&lt;E&gt; {

    AtomicReference&lt;Node&lt;E&gt;&gt; top = new AtomicReference&lt;&gt;();

    public void push(E item) {
        Node&lt;E&gt; newHead = new Node&lt;&gt;(item);
        Node&lt;E&gt; oldHead = null;
        do {
            oldHead = top.get();
            newHead.next = oldHead;
        } while (!top.compareAndSet(oldHead, newHead));
    }

    public E pop() {
        Node&lt;E&gt; oldHead, newHead;
        do {
            oldHead = top.get();
            if (oldHead == null)
                return null;
            newHead = oldHead.next;
        } while (!top.compareAndSet(oldHead, newHead));
        return oldHead.item;
    }

    private static class Node&lt;E&gt; {
        final E item;
        Node&lt;E&gt; next;

        Node(E item) {
            this.item = item;
        }
    }
}
</code></pre><p>栈是一种最简单的链式结构，无需多说，特别简单。</p>
<p>非阻塞栈和之前的技术器很好地说明了CAS的基本使用模式：在更新某个值时存在不确定性，尝试失败后重新尝试。技巧在于：将执行原子修改的范围缩小到单个变量上。</p>
<h2 id="非阻塞链表"><a href="#非阻塞链表" class="headerlink" title="非阻塞链表"></a>非阻塞链表</h2><p>链表的实现比栈更加复杂，插入元素的时候，最后一个元素节点（尾节点）以及最后一个元素的下一个节点都需要更新。乍看起来，这两步操作不能通过原子变量来实现，这里需要两个技巧：第一个技巧是，即便在一个包含多个步骤的更新操作当中，需要确保数据结构处于一致的状态。当线程B到达时，如果发现线程A正在执行更新，那么线程B不能立即执行自己的更新操作；第二个技巧是，如果线程B发现线程A正在更新数据结构，那么线程B可以“帮助”线程A完成更新操作。代码如下：</p>
<pre><code>public class ConcurrentLinkedQueue&lt;E&gt; {
    private static class Node&lt;E&gt; {
        final E item;
        final AtomicReference&lt;Node&lt;E&gt;&gt; next;

        public Node(E item, Node&lt;E&gt; next) {
            this.item = item;
            this.next = new AtomicReference&lt;&gt;(next);
        }
    }

    private final Node&lt;E&gt; dummy = new Node&lt;&gt;(null, null);
    private final AtomicReference&lt;Node&lt;E&gt;&gt; head = new AtomicReference&lt;&gt;(dummy);
    private final AtomicReference&lt;Node&lt;E&gt;&gt; tail = new AtomicReference&lt;&gt;(dummy);

    private void push(E item) {
        Node&lt;E&gt; newNode = new Node&lt;&gt;(item, null);
        while (true) {
            Node&lt;E&gt; curTail = tail.get();
            Node&lt;E&gt; tailNext = curTail.next.get();

            if (curTail == tail.get()) {
                //当前处于中间状态，此时其余线程正在修改数据结构
                if (tailNext != null) {
                    //尝试完成其他线程的工作
                    tail.compareAndSet(curTail, tailNext);
                } else {
                    //尝试插入新节点
                    if (curTail.next.compareAndSet(null, newNode)) {
                        //推进旧节点
                        tail.compareAndSet(curTail, newNode);
                        return;
                    }
                }
            }
        }
    }
}
</code></pre><h1 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h1><p>在CAS算法当中，如果在内存V处的值A先变成B，然后再变成A，那么普通的方式会认为没有发生改变，那么就不会发生交换操作，但实际上已经发生了改变，属于CAS的一种异常情况。</p>
<p>常见的解决方案是通过版本号来标识对象，即便对象从A到B再到A，其版本号也是不同的。<strong>AtomicStampedReference</strong>支持在两个变量上执行原子的条件更新，通过更新引用的版本号，可以避免ABA问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/21/Hibernate基本使用——值类型映射/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/21/Hibernate基本使用——值类型映射/" itemprop="url">
                  Hibernate基本使用——值类型映射
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-21T09:11:03+08:00">
                2017-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ORM/" itemprop="url" rel="index">
                    <span itemprop="name">ORM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/21/Hibernate基本使用——值类型映射/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/21/Hibernate基本使用——值类型映射/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇讲了实体映射及主键生成策略，这一篇主要讲持久化类属性的映射策略。</p>
<h1 id="映射基本属性"><a href="#映射基本属性" class="headerlink" title="映射基本属性"></a>映射基本属性</h1><h2 id="基本类型映射"><a href="#基本类型映射" class="headerlink" title="基本类型映射"></a>基本类型映射</h2><p>基本类型的映射规则如下：</p>
<ul>
<li>如果属性是基元或者基元包装器，如String, BigInteger, BigDecimal, Date, Calendar, byte[], char[]，则它们会被自动持久化。</li>
<li>如果属性所属的类标记为<strong>@Embeddable</strong>，那么Hibernate会将其映射为多列，稍后再说。</li>
<li>如果属性的类是<strong>java.io.Serializable</strong>，那么Hibernate会将其值以序列化的方式存储，此时存储的是一系列字节（很蠢）。</li>
</ul>
<h2 id="Column注解"><a href="#Column注解" class="headerlink" title="@Column注解"></a>@Column注解</h2><p>此注解会更改属性的默认设置，通常用作给属性添加<strong>NOT NULL</strong>约束，<br>或者设置映射到数据库表的列的名称，用法如下：</p>
<pre><code>@Column(name = &quot;PRICE&quot;, nullable = false)
protected BigDecimal price;
</code></pre><p>此时的price属性将会映射到表中名为”PRICE”的列，且试图添加一个price属性为null的记录将会得到异常。</p>
<p>此外要和Bean Validation中的<strong>@NotNull</strong>注解区分开来，此注解在运行时检查所标注的属性是否为空，并不能在SQL中为相应的列添加<strong>NOT NULL</strong>注解。</p>
<h2 id="自定义属性访问"><a href="#自定义属性访问" class="headerlink" title="自定义属性访问"></a>自定义属性访问</h2><p>在默认情况下，如果一个持久化类的<strong>@Id</strong>注解位于字段上，那么之后Hibernate存储和加载类实例时会直接访问字段。如果<strong>@Id</strong>位于get方法上，那么Hibernate之后会通过访问器间接访问字段。</p>
<p>如果要修改默认设置，那么可以通过@Access注解来标记字段或访问方法。</p>
<pre><code>@Entity
public class Item {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    protected Long id;

    @Access(AccessType.PROPERTY)
    @Column(name = &quot;ITEM_NAME&quot;, nullable = false)
    protected String name;

    public String getName() {
        return name;
    }
}
</code></pre><p>此后对name属性的更改就会通过访问器的方式，而非直接访问该字段。</p>
<h2 id="派生属性"><a href="#派生属性" class="headerlink" title="派生属性"></a>派生属性</h2><p>采用<strong>@org.hibernate.annotations.Formula</strong>注解来声明派生属性，派生属性在持久化类被检索的时候根据SQL语句进行估算，如下所示：</p>
<pre><code>@org.hibernate.annotations.Formula(
    &quot;substr(DESCRIPTION, 1, 12) || &apos;...&apos;&quot;
)
protected String shortDescription;

@org.hibernate.annotations.Formula(
    &quot;select avg(b.AMOUNT) from BID b where b.ITEM_ID = ID&quot;
)
protected BigDecimal averageBidAmount;
</code></pre><p>注意的是，估算的属性是只读的，其只能出现在<strong>select</strong>语句当中，绝不会出现在<strong>update</strong>和<strong>insert</strong>当中。</p>
<h2 id="转换列值"><a href="#转换列值" class="headerlink" title="转换列值"></a>转换列值</h2><p>假设数据库表中有一个<strong>YUAN</strong>的数据库列，现在将其映射到持久化类的属性当中，我们希望能够以分的形式来呈现。当然，在数据检索出来之后手动转换是一个不错的选择，但是我们可以利用<strong>@org.hibernate.annotations.ColumnTransformer</strong>注解进行列转换，如下所示：</p>
<pre><code>@Column(name = &quot;YUAN&quot;)
@org.hibernate.annotations.ColumnTransformer(
        read = &quot;YUAN * 10.0&quot;,
        write = &quot;? / 10.0&quot;
)
protected BigDecimal price;
</code></pre><h2 id="生成默认值"><a href="#生成默认值" class="headerlink" title="生成默认值"></a>生成默认值</h2><p>有关生成默认值的博文地址如下：<a href="http://blog.csdn.net/fhd001/article/details/5878498" target="_blank" rel="external">hibernate之生成的和默认的属性值(使用generated刷新实体)</a>，不过经过笔者的实践，这个貌似在MySQL环境当中存在着问题，具体请参见：<a href="https://stackoverflow.com/questions/44593294/hibernate-generated-annotation-doesnt-work-well" target="_blank" rel="external">Hibernate @Generated annotation doesn’t work well</a></p>
<h2 id="枚举映射"><a href="#枚举映射" class="headerlink" title="枚举映射"></a>枚举映射</h2><p>可以通过以下方式映射一个枚举属性：</p>
<pre><code>public enum Type {
    BOOK,
    CAR,
    FOOD
}

@NotNull
@Enumerated(EnumType.STRING)
protected Type type;
</code></pre><p>type会以字符串的形式存到数据库表当中。</p>
<h1 id="映射可嵌入组件"><a href="#映射可嵌入组件" class="headerlink" title="映射可嵌入组件"></a>映射可嵌入组件</h1><p>可以用<strong>@Embeddable</strong>注解声明一个类是可嵌入的，可嵌入的类的每个属性将会被映射到外层持久化类所映射的表的单个列当中。举个例子，想要在USER表当中存储关于用户的信息，其中有其地址信息，地址可以作为一个可嵌入类来定义：</p>
<pre><code>@Embeddable
public class Address {
    @Column(nullable = false)
    protected String city;

    @Column(nullable = false)
    protected String zipCode;

    @Column(nullable = false)
    protected String street;

    public Address() {
    }

    public Address(String city, String zipCode, String street) {
        this.city = city;
        this.zipCode = zipCode;
        this.street = street;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    public String getStreet() {
        return street;
    }

    public void setStreet(String street) {
        this.street = street;
    }
}
</code></pre><p>User定义：</p>
<pre><code>@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    protected Long id;

    @Column(nullable = false)
    String name;

    protected Address address;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public Long getId() {
        return id;
    }
}
</code></pre><p>此时USER表的结构是这样的：</p>
<pre><code>SHOW CREATE TABLE USER;

CREATE TABLE `USER` (
  `id` bigint(20) NOT NULL,
  `city` varchar(255) NOT NULL,
  `street` varchar(255) NOT NULL,
  `zipCode` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=gbk
</code></pre><h2 id="重写嵌入属性"><a href="#重写嵌入属性" class="headerlink" title="重写嵌入属性"></a>重写嵌入属性</h2><p>可以通过以下方式重写嵌入的属性：</p>
<pre><code>@AttributeOverrides({
        @AttributeOverride(name = &quot;street&quot;, column = @Column(name = &quot;USER_STREET&quot;)),
        @AttributeOverride(name = &quot;zipCode&quot;, column = @Column(name = &quot;USER_ZIP_CODE&quot;)),
        @AttributeOverride(name = &quot;city&quot;, column = @Column(name = &quot;USER_CITY&quot;))
})
protected Address address;
</code></pre><p><strong>@AttributeOverride</strong>当中name对应的是Address的属性名，column对应的是要重新映射的列的信息。</p>
<h1 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h1><p>我们已经知道在映射<strong>java.lang.String</strong>等基本类型的时候，Hibernate会将其映射到SQL基本类型，除了基本内置类型之外，可以定义转换器和用户类型。</p>
<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>常见的内置类型如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>Java类型</th>
<th>ANSISQL类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>integer</td>
<td>java.lang.Integer</td>
<td>INTEGER</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>float</td>
<td>java.lang.Float</td>
<td>FLOAT</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
<td>DOUBLE</td>
</tr>
<tr>
<td>boolean</td>
<td>java.lang.Boolean</td>
<td>BOOLEAN</td>
</tr>
<tr>
<td>big_decimal</td>
<td>java.lang.BigDecimal</td>
<td>NUMERIC</td>
</tr>
<tr>
<td>big_integer</td>
<td>java.lang.BigInteger</td>
<td>NUMERIC</td>
</tr>
<tr>
<td>String</td>
<td>java.lang.String</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>yes_no</td>
<td>java.lang.Boolean</td>
<td>CHAR(1), ‘Y’ or ‘N’</td>
</tr>
<tr>
<td>class</td>
<td>java.lang.Class</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>currency</td>
<td>java.util.Currency</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>date</td>
<td>java.util.Date,java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>time</td>
<td>java.util.Date,java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>timestamp</td>
<td>java.util.Date,java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>calendar</td>
<td>java.util.Calendar</td>
<td>TIMESTAMP</td>
</tr>
</tbody>
</table>
<p>名称为Hibernate特有，用于自定义类型映射，如：</p>
<pre><code>@org.hibernate.annotations.Type(type = &quot;yes_no&quot;)
protected boolean verified;
</code></pre><p>现在VERIFIED所对应的SQL类型应该为CHAR(1)，且其值为’Y’或’N’。</p>
<h2 id="JPA转换器"><a href="#JPA转换器" class="headerlink" title="JPA转换器"></a>JPA转换器</h2><p>可以使用JPA原生转换器来完成自定义类型到另一个基本类型的转换，如下所示：</p>
<p>MonetaryAmount类：</p>
<pre><code>public class MonetaryAmount implements Serializable {
    static final long serialVersionUID = 1L;

    protected final BigDecimal value;
    protected final Currency currency;

    public MonetaryAmount(BigDecimal value, Currency currency) {
        this.value = value;
        this.currency = currency;
    }

    public BigDecimal getValue() {
        return value;
    }

    public Currency getCurrency() {
        return currency;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        MonetaryAmount that = (MonetaryAmount) o;

        if (!value.equals(that.value)) return false;
        return currency.equals(that.currency);
    }

    @Override
    public int hashCode() {
        int result = value.hashCode();
        result = 31 * result + currency.hashCode();
        return result;
    }

    @Override
    public String toString() {
        return value + &quot; &quot; + currency;
    }

    public static MonetaryAmount fromString(String str) {
        String[] split = str.split(&quot; &quot;);
        return new MonetaryAmount(new BigDecimal(split[0]), Currency.getInstance(split[1]));
    }
}
</code></pre><p>MonetaryAmountConverter:</p>
<pre><code>@Converter(autoApply = true)
public class MonetaryAmountConverter implements AttributeConverter&lt;MonetaryAmount, String&gt; {

    @Override
    public String convertToDatabaseColumn(MonetaryAmount monetaryAmount) {
        return monetaryAmount.toString();
    }

    @Override
    public MonetaryAmount convertToEntityAttribute(String s) {
        return MonetaryAmount.fromString(s);
    }
}
</code></pre><p>则在持久化类里面可以这样定义：</p>
<pre><code>@NotNull
//可选，因为设置了autoApply
@Convert(converter = MonetaryAmountConverter.class)
@Column(name = &quot;PRICE&quot;)
protected MonetaryAmount ma;
</code></pre><p>此时Hibernate便会先将此属性转成相应的字符串再将其存到数据库中。</p>
<h2 id="UserType扩展"><a href="#UserType扩展" class="headerlink" title="UserType扩展"></a>UserType扩展</h2><p>JPA转换器存在诸多限制。其不支持单值到多个列的转换，另一个限制是与查询引擎的集成，不能够在HQL查询语句当中直接访问被转换类型的属性，如：<br><strong>“select i from Item i where i.ma.value &gt; 100”</strong>。如果需要更加灵活的扩展，那就需要Hibernate提供的扩展接口。</p>
<p>可以在org.hibernate.usertype包下找到合适的扩展接口，常见接口如下：</p>
<ul>
<li><strong>UserType</strong>——可以通过与底层JDBC的PreparedStatement和ResultSet交互来转换值。</li>
<li><strong>CompositeUserType</strong>——扩展了上述的<strong>UserType</strong>接口，提供了更多与适配类的相关的信息。例如，可以告知MonetaryAmount有两个属性：value, currency，然后就可以在select查询语句当中引用这些属性。</li>
<li><strong>ParameterizedUserType</strong>——提供对适配器参数的设置。</li>
<li><strong>DynamicParameterizedUserType</strong>——允许访问适配器的动态信息，如映射列和表名称，可以替代<strong>ParameterizedUserType</strong>。</li>
</ul>
<h3 id="定义用户类型"><a href="#定义用户类型" class="headerlink" title="定义用户类型"></a>定义用户类型</h3><p>如下定义了<strong>MonetaryAmount</strong>类的UserType，如下所示：</p>
<pre><code>public class MonetaryAmountType implements CompositeUserType {

    // 获取类内部属性的名字
    @Override
    public String[] getPropertyNames() {
        System.out.println(&quot;getPropertyNames() called&quot;);
        return new String[]{ &quot;value&quot;, &quot;currency&quot; };
    }

    // 得到属性的类型
    @Override
    public Type[] getPropertyTypes() {
        System.out.println(&quot;getPropertyTypes() called&quot;);
        return new Type[]{ StandardBasicTypes.BIG_DECIMAL, StandardBasicTypes.CURRENCY };
    }

    // 获取指定位置上属性的值
    @Override
    public Object getPropertyValue(Object o, int i) throws HibernateException {
        System.out.println(&quot;getPropertyValue() called, and i is &quot; + i);
        MonetaryAmount ma = (MonetaryAmount) o;
        if (i == 0)
            return ma.getValue();
        return ma.getCurrency().toString();
    }

    @Override
    public void setPropertyValue(Object o, int i, Object o1) throws HibernateException {
        throw new UnsupportedOperationException(&quot;setProperty() cannot be called&quot;);
    }

    // 返回要转化的类型
    @Override
    public Class returnedClass() {
        System.out.println(&quot;returnedClass() called&quot;);
        return MonetaryAmount.class;
    }

    // 判断两对象是否相同
    @Override
    public boolean equals(Object o, Object o1) throws HibernateException {
        System.out.println(&quot;equals() called&quot;);
        return o.equals(o1);
    }

    @Override
    public int hashCode(Object o) throws HibernateException {
        System.out.println(&quot;hashCode() called&quot;);
        return o.hashCode();
    }

    // 查询的结果集到相应类的转变
    @Override
    public Object nullSafeGet(ResultSet resultSet, String[] strings, SharedSessionContractImplementor sharedSessionContractImplementor, Object o) throws HibernateException, SQLException {
        System.out.println(&quot;nullSafeGet() called&quot;);
        if (resultSet.wasNull())
            return null;
        BigDecimal value = resultSet.getBigDecimal(strings[0]);
        Currency currency = Currency.getInstance(resultSet.getString(strings[1]));
        return new MonetaryAmount(value, currency);
    }

    @Override
    public void nullSafeSet(PreparedStatement preparedStatement, Object o, int i, SharedSessionContractImplementor sharedSessionContractImplementor) throws HibernateException, SQLException {
        System.out.println(&quot;nullSafeSet() called and i is &quot; + i);
        if (o == null) {
            preparedStatement.setNull(i, StandardBasicTypes.BIG_DECIMAL.sqlType());
            preparedStatement.setNull(i + 1, StandardBasicTypes.CURRENCY.sqlType());
        } else {
            MonetaryAmount ma = (MonetaryAmount) o;
            preparedStatement.setBigDecimal(i, ma.getValue());
            preparedStatement.setString(i + 1, ma.getCurrency().toString());
        }
    }

    // 用于获取值的副本，不可变对象返回本身即可
    @Override
    public Object deepCopy(Object o) throws HibernateException {
        return o;
    }

    // 如果对象是不可变的，Hibernate会采取优化措施
    @Override
    public boolean isMutable() {
        return false;
    }

    // 返回序列化表示的值
    @Override
    public Serializable disassemble(Object o, SharedSessionContractImplementor sharedSessionContractImplementor) throws HibernateException {
        System.out.println(&quot;disassemble() called&quot;);
        return o.toString();
    }

    // 用序列化的值创造对象
    @Override
    public Object assemble(Serializable serializable, SharedSessionContractImplementor sharedSessionContractImplementor, Object o) throws HibernateException {
        System.out.println(&quot;assemble() called&quot;);
        return MonetaryAmount.fromString((String) serializable);
    }

    // 在EntityManager#merge()操作期间调用，需要返回原始对象的副本
    @Override
    public Object replace(Object o, Object o1, SharedSessionContractImplementor sharedSessionContractImplementor, Object o2) throws HibernateException {
        return o;
    }
}
</code></pre><p>以上代码有注释，不再细说。</p>
<h3 id="使用用户类型"><a href="#使用用户类型" class="headerlink" title="使用用户类型"></a>使用用户类型</h3><p>使用用户类型时，可以先用包级注释声明类型：</p>
<pre><code>@org.hibernate.annotations.TypeDefs(
    @org.hibernate.annotations.TypeDef(name = &quot;monetary_amount_type&quot;,
            typeClass = com.stephen.hibernatepractice.converter.MonetaryAmountType.class)
)
package com.stephen.hibernatepractice;
</code></pre><p>在实体类中引用：</p>
<pre><code>@NotNull
@org.hibernate.annotations.Type(type = &quot;monetary_amount_type&quot;)
@org.hibernate.annotations.Columns(columns = {
        @Column(name = &quot;PRICE&quot;),
        @Column(name = &quot;CURRENCY&quot;, length = 3)
}
)
protected MonetaryAmount monetaryAmount;
</code></pre><p>则monetaryAmount属性的value映射为PRICE列，currency映射为CURRENCY列，并且此时可以在HQL select语句里面引用monetaryAmount属性的属性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/19/Hibernate基本使用——实体映射/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/19/Hibernate基本使用——实体映射/" itemprop="url">
                  Hibernate基本使用——实体映射
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-19T19:44:51+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ORM/" itemprop="url" rel="index">
                    <span itemprop="name">ORM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/19/Hibernate基本使用——实体映射/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/19/Hibernate基本使用——实体映射/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇记录Hibernate实体映射的基础，采用IntelliJ Idea搭建Hibernate项目，具体如何搭建参见：<a href="http://www.jianshu.com/p/50e0a7a28b53" target="_blank" rel="external">IntelliJ IDEA Hibernate 从入门到填坑</a></p>
<h1 id="实体类和映射"><a href="#实体类和映射" class="headerlink" title="实体类和映射"></a>实体类和映射</h1><p>一个实体类代表着数据库中的一个表，用<strong>@Entity</strong>进行标记，同时，一个持久化类内部要有一个id(主键)，用@Id进行注解，关于主键如何选择，参见：<a href="http://www.cnblogs.com/chuncn/archive/2009/04/22/1440901.html" target="_blank" rel="external">数据库中主键的选择和使用</a>。如下所示：</p>
<pre><code>@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    protected Long id;

    public Long getId() {
        return id;
    }
}
</code></pre><p>将<strong>@Id</strong>注解在字段上，之后Hibernate存储和加载实例的时候，会直接访问类相应的字段，如果注解在访问器方法上，那之后Hibernate会访问相应的访问器方法。</p>
<h2 id="配置键生成器"><a href="#配置键生成器" class="headerlink" title="配置键生成器"></a>配置键生成器</h2><h3 id="GenerationType"><a href="#GenerationType" class="headerlink" title="GenerationType"></a>GenerationType</h3><p>通常需要Hibernate自动生成一个代理键值，可以通过<strong>@GeneratedValue(strategy = …)</strong>来指定，其中strategy是<strong>GenerationType</strong>类型的枚举值，其枚举值如下：</p>
<ul>
<li><strong>GenerationType.AUTO</strong> ： Hibernate会根据hibernate.cfg.xml文件当中配置的数据库方言自动选择一种合适的策略，是默认的配置。</li>
<li><strong>GenerationType.SEQUENCE</strong> ： Hibernate会在数据库中创建一个名为HIBERNATE_SEQUENCE的序列，如果数据库不支持序列的话，那么Hibernate将会创建一个只有一个列的表来模拟序列的行为，该序列会在INSERT之前调用，用来生成唯一的主键。</li>
<li><strong>GenerationType.IDENTITY</strong> ： Hibernate会在建表的DDL语句当中生成一个自增长列，用于生成代理键。</li>
<li><strong>GenerationType.TABLE</strong> ： Hibernate通过创建额外的表来单独保存主键值。</li>
</ul>
<h3 id="自定义Generator"><a href="#自定义Generator" class="headerlink" title="自定义Generator"></a>自定义Generator</h3><p>可以通过<strong>@GenericGenerator</strong>注解来自定义生成器，一般放在package-info.java中作为包级元注解，如下所示：</p>
<pre><code>@org.hibernate.annotations.GenericGenerator(
    name = &quot;CUSTOM_GENERATOR&quot;,
    strategy = &quot;enhanced-sequence&quot;,
    parameters = {
            @org.hibernate.annotations.Parameter(
                    name = &quot;sequence_name&quot;,
                    value = &quot;custom_sequence&quot;
            ),
            @org.hibernate.annotations.Parameter(
                    name = &quot;initial_value&quot;,
                    value = &quot;1000&quot;
            )
    }
)
package com.stephen.hibernatepractice;
</code></pre><p>其中strategy对应的是标识符生成器策略，名为”sequence_name”的参数代表着序列的名称（如果数据库不支持序列则代表序列表的名称），initial_value代表的是生成键的初始值，以后以此值为基础进行递增。</p>
<h4 id="生成器策略"><a href="#生成器策略" class="headerlink" title="生成器策略"></a>生成器策略</h4><p>对于生成器策略，如果想让Hibernate自动进行选择，那么可以开启GenerationType.AUTO，Hibernate会根据设置的数据库方言选择合适的解决方案，最有可能是序列或者是标识，但是可能不是最佳的可移植方案。如果需要灵活的可移植行为，则可以采用上述的”enhanced-sequence”。关于完整的主键生成策略，可以参见：<a href="http://www.cnblogs.com/flyoung2008/articles/2165759.html" target="_blank" rel="external">Hibernate主键生成策略</a>。</p>
<p>需要注意的是，对于某些生成器策略，主键id并不能立即生成，有可能是在INSERT之后才生成，因此可能存在<strong>em.persist(something)</strong>之后，<strong>something.getId()</strong>为空，因此应当尽量选择插入前生成策略的主键生成策略，一般情况下”enhanced-sequence”是最好的选择。</p>
<h2 id="实体映射选项"><a href="#实体映射选项" class="headerlink" title="实体映射选项"></a>实体映射选项</h2><h3 id="控制名称"><a href="#控制名称" class="headerlink" title="控制名称"></a>控制名称</h3><p>可以通过下列方式控制生成的表的名称，默认情况下生成的表名称为类名的大写：</p>
<pre><code>@Entity
@Table(name = &quot;USERS&quot;)
public class User {
    ...
}
</code></pre><h3 id="动态SQL生成"><a href="#动态SQL生成" class="headerlink" title="动态SQL生成"></a>动态SQL生成</h3><p>默认情况下，Hibernate会为每一个持久化单元生成CRUD语句并缓存起来，如果一个表的结构非常巨大，那么这种缓存将影响性能。对于UPDATE语句来说，由于更新的列是未知的，那Hibernate在启动时将会生成对所有列进行更新的UPDATE语句，对于没有变化的值来说，Hibernate会将其设置为旧值。</p>
<p>如果需要动态生成SQL语句，可以通过<strong>@DynamicInsert</strong>和<strong>@DynamicUpdate</strong>注解来标识持久化类。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/10/MySQL锁机制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/10/MySQL锁机制/" itemprop="url">
                  MySQL锁机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-10T17:55:11+08:00">
                2017-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/10/MySQL锁机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/10/MySQL锁机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇将介绍MySQL锁机制的特点，主要拿MyISAM，InnoDB引擎进行分析。</p>
<h1 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h1><p>MyISAM引擎只支持表锁，这种锁的特点是加锁快，开销小，锁发生冲突的概率比较高，并行度较低。</p>
<h2 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h2><p>表级锁有两种模式：共享读锁和独占写锁，类似Java中的ReadWriteLock。多个线程可以共享一把读锁，但是会堵塞写线程的请求。当写锁被一个线程占有时，其他线程的读和写请求都会被堵塞。</p>
<h2 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h2><h3 id="自动加表锁"><a href="#自动加表锁" class="headerlink" title="自动加表锁"></a>自动加表锁</h3><p>MyISAM存储引擎在执行SELECT, UPDATE, INSERT, DELETE之前，会自动获取相应的所有的表锁，执行完毕之后，自动释放所有的表锁，这个过程不需要显式指定，用起来比较方便。</p>
<h3 id="手动加锁"><a href="#手动加锁" class="headerlink" title="手动加锁"></a>手动加锁</h3><p>手动加锁一般是为了模拟事务操作，要注意以下几点。</p>
<ol>
<li>在执行Lock Tables之后，只能访问加锁的表，自动更新也是如此。</li>
<li>获取读锁之后不能进行更新和插入操作。</li>
<li>同一个表在SQL中出现多少次，就需要对相同的别名锁定多少次。</li>
</ol>
<h2 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h2><p>MyISAM允许读写操作并发进行，存在系统变量concurrent_insert，专门控制并发插入的行为，其值有0，1，2。</p>
<ul>
<li>当设置为0时，不允许并发插入。</li>
<li>当设置为1时，如果表的中间没有被删除，那就允许其他用户在表的末尾并发插入。</li>
<li>当设置为2时，无论表是否存在空洞，都可以在表的末尾进行插入。</li>
</ul>
<h2 id="锁调度"><a href="#锁调度" class="headerlink" title="锁调度"></a>锁调度</h2><p>MyISAM默认给予写操作更高的优先级，这意味着如果一个读线程和一个写线程同时分别获得读锁和写锁，那写线程将会优先进行。即便读请求先到锁的等待队列，之后到达的写请求也会“插队”。要想降低写线程的优先级，可以采取以下办法：</p>
<ul>
<li>制定启动参数low-priority-updates，使存储引擎给写线程以更低的优先级。</li>
<li>设置参数LOW_PRIORITY_UPDATES = 1。</li>
<li>通过制定INSERT, UPDATE, DELETE语句的LOW_PRIORITY属性，降低语句的优先级。</li>
</ul>
<h1 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h1><p>InnoDB引擎支持事务，因此请先查看<a href="http://zsrr.coding.me/2017/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/" target="_blank" rel="external">数据库事务</a>。</p>
<p>InnoDB的锁类型这里不再赘述，有关内容请查看：<a href="http://www.zrray.com/art/247" target="_blank" rel="external">InnoDB锁模式</a></p>
<p>在这里主要记录以下几点：</p>
<h2 id="共享锁-S"><a href="#共享锁-S" class="headerlink" title="共享锁(S)"></a>共享锁(S)</h2><p>通过<strong>SELECT * FROM table_name WHERE … LOCK IN SHARE MODE</strong>获得共享锁，主要是确保一个事务在读取这些记录的时候，另一个事务对这些数据集的修改需等到前一个事务提交或回滚后进行。</p>
<h2 id="排他锁-X"><a href="#排他锁-X" class="headerlink" title="排他锁(X)"></a>排他锁(X)</h2><p>通过<strong>SELECT * FROM table_name WHERE … FOR UPDATE</strong>来获取。一个事务对一个数据集进行加锁之后，另一个事务对这个数据集的更新，删除，以及试图获取其共享锁的操作都会被阻塞，但是普通的SELECT操作不会被阻塞（返回的只是数据集的快照）。</p>
<h2 id="InnoDB行锁的实现方式"><a href="#InnoDB行锁的实现方式" class="headerlink" title="InnoDB行锁的实现方式"></a>InnoDB行锁的实现方式</h2><p>主要有三种实现方式：</p>
<ul>
<li><strong>Record Lock</strong> 对索引项进行加锁。</li>
<li><strong>Gap Lock</strong> 对索引项的“间隙”，第一条记录前的“间隙”或者最后一条记录后的“间隙”进行加锁。</li>
<li><strong>Next-key Lock</strong> 前两种的组合。</li>
</ul>
<p>InnoDB这种行锁实现方式意味着，如果不通过索引检索数据，那么InnoDB将对所有记录进行加锁，实际上的效果和表锁一样。</p>
<h2 id="行锁的注意事项"><a href="#行锁的注意事项" class="headerlink" title="行锁的注意事项"></a>行锁的注意事项</h2><h3 id="不通过索引检索数据，InnoDB会锁定表中的所有记录"><a href="#不通过索引检索数据，InnoDB会锁定表中的所有记录" class="headerlink" title="不通过索引检索数据，InnoDB会锁定表中的所有记录"></a>不通过索引检索数据，InnoDB会锁定表中的所有记录</h3><h3 id="InnoDB行锁针对索引加锁，不是根据记录加的锁"><a href="#InnoDB行锁针对索引加锁，不是根据记录加的锁" class="headerlink" title="InnoDB行锁针对索引加锁，不是根据记录加的锁"></a>InnoDB行锁针对索引加锁，不是根据记录加的锁</h3><p>访问不同行的记录，但是使用的是相同的索引键，会发生锁竞争，如下例所示：</p>
<pre><code>create table tab_with_index( id int not null, name varchar(30));
create index index_id on tab_with_index(id);

insert into tab_with_index values(1, &apos;1&apos;), (1, &apos;2&apos;);

...

# session1
select * from tab_with_index where id = 1 and name = &apos;1&apos; for update;

...

# session2
select * from tab_with_index where id = 1 and name = &apos;2&apos; for update;
# 等待
</code></pre><p>在上例中，由于id为1（id为索引）的记录在事务1中被加锁，因此尽管事务2访问的是不同行，也会被阻塞。</p>
<h3 id="不同的事务可以根据不同的索引获得不同的锁"><a href="#不同的事务可以根据不同的索引获得不同的锁" class="headerlink" title="不同的事务可以根据不同的索引获得不同的锁"></a>不同的事务可以根据不同的索引获得不同的锁</h3><p>如下例所示：</p>
<pre><code>create index name on tab_with_index(name);

insert into tab_with_index values(2, &apos;4&apos;);

# session1
select * from tab_with_index where id = 1 for update;

# session2
select * from tab_with_index where name = &apos;4&apos; for update;
# 立即返回数据，不会被阻塞。

select * from tab_with_index where name = &apos;2&apos; for update;
# 被阻塞，事务1对此数据集加了排他锁。
</code></pre><h3 id="Next-key-“间隙”加锁"><a href="#Next-key-“间隙”加锁" class="headerlink" title="Next-key “间隙”加锁"></a>Next-key “间隙”加锁</h3><p>“间隙”(Gap)的定义为：键值在条件范围内但是并不存在的记录，用在对键值进行范围条件查找时。</p>
<p>举个例子，假如test表中只有100条记录，其id值为1，2，3…100。这时在一个事务中执行如下语句：</p>
<pre><code>select * from test where id &gt;= 100 for update;
</code></pre><p>这时InnoDB不仅对id为100的实际存在的记录进行加锁，而且对id大于100但是实际上不存在的记录进行加锁。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/09/SQL优化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/09/SQL优化/" itemprop="url">
                  SQL优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-09T14:41:57+08:00">
                2017-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/09/SQL优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/09/SQL优化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇详细记录SQL优化的一般步骤，以MySQL为例。</p>
<h1 id="通过EXPLAIN语句分析SQL"><a href="#通过EXPLAIN语句分析SQL" class="headerlink" title="通过EXPLAIN语句分析SQL"></a>通过EXPLAIN语句分析SQL</h1><p>EXPLAIN通常用来分析select子句，返回的数据格式为：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>select标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>select类型</td>
</tr>
<tr>
<td>type</td>
<td>访问类型</td>
</tr>
<tr>
<td>possible_keys</td>
<td>查询设计到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引</td>
</tr>
<tr>
<td>key_length</td>
<td>使用的索引的长度</td>
</tr>
<tr>
<td>ref</td>
<td>哪些列或常量用于匹配索引的值</td>
</tr>
<tr>
<td>extra</td>
<td>关于查询的详细信息</td>
</tr>
</tbody>
</table>
<h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><p>此列记录了select的类型，主要有以下几种：</p>
<ul>
<li><strong>SIMPLE</strong> 简单查询，不使用<strong>UNION</strong>和子查询。</li>
<li><strong>PRIMARY</strong> 若查询中包括子查询，则此项说明是最外边的查询。</li>
<li><strong>UNION</strong> UNION中第二个SELECT语句。</li>
<li><strong>SUBQUERY</strong> 子查询中第一个SELECT。</li>
<li><strong>DERIVED</strong> FROM子句中的子查询。</li>
</ul>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>访问类型，性能从好到坏排序可以分成以下几个部分：</p>
<ul>
<li><strong>system</strong> 表中只有一行。</li>
<li><strong>const</strong> 单表中至多有一个数据项可以匹配，用在PRIMARY KEY和UNIQUE INDEX和常量进行”=”比较的情况。</li>
<li><strong>eq_ref</strong> 在多表连接当中，使用PRIMARY KEY或者UNIQUE INDEX进行比较。</li>
<li><strong>ref</strong> 与eq_ref类似，但是不使用PRIMARY KEY和UNIQUE INDEX。</li>
<li><strong>range</strong> 根据索引进行范围内搜索。</li>
<li><strong>index</strong> 遍历索引就能获得相应的数据，通常比遍历整个表要快，但是也不一定，当数据量较小的时候MySQL可能仍会选择遍历整个表。</li>
<li><strong>all</strong> 遍历整个表，通常比较慢，当数据量较大的时候需要优化。</li>
</ul>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>ref是记录了哪些列或者常量被用来和索引进行比较，如果值为func的话，那就是从某个函数返回的值进行比较。</p>
<h1 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h1><p>可以通过<strong>show profile</strong>语句来查看一个query语句消耗了多长时间。要想查询特定的查询语句，需要先执行<strong>show profiles</strong>（先将profiling变量设置为1），执行的结果如图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-09%20%E4%B8%8B%E5%8D%8810.49.40.png" alt=""><br>上图列出了之前查询语句的id，耗时和语句详情，要想查看一个具体的查询语句的耗时情况，执行show profile for query [<em>query_id</em>]:</p>
<pre><code>show profile for query 7;
</code></pre><p>执行结果如图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-09%20%E4%B8%8B%E5%8D%8811.01.04.png" alt=""></p>
<p><strong>注：</strong>上图中sending data过程是MySQL从表中读取数据并把结果返回给客户的过程，往往是整个过程最耗时的操作。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="使用索引的情况"><a href="#使用索引的情况" class="headerlink" title="使用索引的情况"></a>使用索引的情况</h2><h3 id="匹配全值"><a href="#匹配全值" class="headerlink" title="匹配全值"></a>匹配全值</h3><p>即对where子句中所有的索引列指定一个具体值。</p>
<h3 id="匹配值的范围查询"><a href="#匹配值的范围查询" class="headerlink" title="匹配值的范围查询"></a>匹配值的范围查询</h3><p>对索引的值能够进行范围查找（Hash索引不支持）。</p>
<h3 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h3><p>仅仅使用复合索引的最左边列进行查找，如有col1 + col2 + col3的复合索引，可以针对col1, col1 + col2, col1 + col2 + col3, col1 + col3进行查找，但是不能对col2, col3, col2 + col3进行查找，这是B-Tree索引使用时的首要准则。</p>
<h3 id="仅仅对索引进行查询"><a href="#仅仅对索引进行查询" class="headerlink" title="仅仅对索引进行查询"></a>仅仅对索引进行查询</h3><p>当要查询的列都是索引的时候，MySQL会在索引中直接查找，因为索引的大小通常比原表小得多，所以查询的速度要比原表要快，此时Extra信息中会提示：Using index。</p>
<h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>仅仅匹配索引第一列的部分，前缀索引不适合<strong>order by group by</strong>子句</p>
<h3 id="ICP特性"><a href="#ICP特性" class="headerlink" title="ICP特性"></a>ICP特性</h3><p>MySQL 5.6引入了Index Condition Pushdown特性，将操作过滤（下放）到存储引擎。</p>
<p>如有一复合索引col1 + col2，查询条件为：col1 = … and col2 &gt; …，那么在MySQL 5.6之前的版本，数据库先根据复合索引的首字段col1来过滤出满足第一个条件的记录，然后回表查找记录（此时为Using where），最后根据第二个条件过滤之前查找的记录。MySQL 5.6之后，则把col2的过滤下放到底层存储引擎层来完成，这样能减少不必要的io操作，提高性能。</p>
<h2 id="存在索引但是不能使用索引的情况"><a href="#存在索引但是不能使用索引的情况" class="headerlink" title="存在索引但是不能使用索引的情况"></a>存在索引但是不能使用索引的情况</h2><h3 id="以-开头的like查询不能够使用B-Tree索引"><a href="#以-开头的like查询不能够使用B-Tree索引" class="headerlink" title="以%开头的like查询不能够使用B-Tree索引"></a>以%开头的like查询不能够使用B-Tree索引</h3><p>由于B-Tree索引的结构，以%开头的like查询不能够使用B-Tree索引，一般采用<a href="http://www.cnblogs.com/tommy-huang/p/4483684.html" target="_blank" rel="external">全文索引</a>来解决此类问题。</p>
<h3 id="数据出现隐式转换的时候不能使用索引"><a href="#数据出现隐式转换的时候不能使用索引" class="headerlink" title="数据出现隐式转换的时候不能使用索引"></a>数据出现隐式转换的时候不能使用索引</h3><p>例如：</p>
<pre><code>select * from actor where name = 1;
</code></pre><p>name为varchar类型，但是给予的比较常量是一个int类型，这时候即便name是一个索引，查询仍不能使用此索引。</p>
<h3 id="复合索引不满足最左原则的情况下不能够被使用"><a href="#复合索引不满足最左原则的情况下不能够被使用" class="headerlink" title="复合索引不满足最左原则的情况下不能够被使用"></a>复合索引不满足最左原则的情况下不能够被使用</h3><h3 id="如果查找索引比查找表更慢，那么索引不会被使用"><a href="#如果查找索引比查找表更慢，那么索引不会被使用" class="headerlink" title="如果查找索引比查找表更慢，那么索引不会被使用"></a>如果查找索引比查找表更慢，那么索引不会被使用</h3><p>在数据量较小或者索引比表大的情况下（极少出现），扫描索引会比直接扫描表更慢，这时索引不会被使用。</p>
<h3 id="用or分隔开的条件，前面有索引而后面没有，索引不被使用"><a href="#用or分隔开的条件，前面有索引而后面没有，索引不被使用" class="headerlink" title="用or分隔开的条件，前面有索引而后面没有，索引不被使用"></a>用or分隔开的条件，前面有索引而后面没有，索引不被使用</h3><h1 id="常用的优化方法"><a href="#常用的优化方法" class="headerlink" title="常用的优化方法"></a>常用的优化方法</h1><h2 id="定期优化表"><a href="#定期优化表" class="headerlink" title="定期优化表"></a>定期优化表</h2><p>如果表中绝大部分数据已经被删除，并且包含可变长度的列，那么可以通过OPTIMIZE TABLE [TABLE_NAME]进行优化，这个命令可以将表中空间碎片进行整合，消除由于删除更新而带来的空间浪费。</p>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="大量导入数据"><a href="#大量导入数据" class="headerlink" title="大量导入数据"></a>大量导入数据</h3><p>对于MyISAM的表来说，可以通过以下方式快速导入数据：</p>
<pre><code>ALTER TABLE tab_name DISABLE KEYS;
#load data
ALTER TABLE tab_name ENABLE KEYS;
</code></pre><p>再导入数据前先关闭非唯一索引的更新，导入完成后再打开。</p>
<p>对于InnoDB表来说，导入的数据按照主键进行排序，可以有效地提高数据导入的效率。</p>
<p>在导入数据之前，关闭唯一性检验（SET UNIQUE_CHECK = 0），导入完成后打开，可以提高数据导入的效率。</p>
<h3 id="优化INSERT语句"><a href="#优化INSERT语句" class="headerlink" title="优化INSERT语句"></a>优化INSERT语句</h3><p>当插入很多行是，应尽量使用多个值表的INSERT语句，比单个INSERT语句执行快得多。</p>
<p>当导入大量数据时，从文本中导入数据比INSERT语句快得多。</p>
<h3 id="优化ORDER-BY子句"><a href="#优化ORDER-BY子句" class="headerlink" title="优化ORDER BY子句"></a>优化ORDER BY子句</h3><h4 id="MySQL排序方式"><a href="#MySQL排序方式" class="headerlink" title="MySQL排序方式"></a>MySQL排序方式</h4><h5 id="索引顺序扫描"><a href="#索引顺序扫描" class="headerlink" title="索引顺序扫描"></a>索引顺序扫描</h5><p>通过有序索引顺序扫描直接返回有效的数据，操作效率高。</p>
<h5 id="Filesort排序"><a href="#Filesort排序" class="headerlink" title="Filesort排序"></a>Filesort排序</h5><p>对返回数据进行排序，所有不是通过索引直接返回排序结果的排序都是Filesort排序，此时Extra信息中存在Using filesort。</p>
<p>所以，应尽量保证索引顺序和ORDER BY后面的顺序相同，避免Filesort排序，有关Filesort的详细信息及底层算法，参见：<a href="http://www.cnblogs.com/cchust/p/5304594.html" target="_blank" rel="external">MySQL排序原理与案例分析</a></p>
<p>总结： </p>
<p>下列情况可以使用索引：</p>
<pre><code>SELECT * FROM TABLE_NAME ORDER BY KET_PART_1, KEY_PART2...;
SELECT * FROM TABLE_NAME WHERE KEY_PART_1 = XXX ORDER BY KEY_PART_2;
SELECT * FROM TABLE_NAME WHERE KEY = XXX ORDER BY KEY;
SELECT * FROM TABLE_NAME WHERE KEY_PART_1 = XXX ORDER BY KEY_PART_1 DESC, KEY_PART_2 DESC;
</code></pre><p>以下情况不可以：</p>
<pre><code>SELECT * FROM TABLE_NAME ORDER BY KEY_PART_1 DESC, KEY_PART_2 ASC;
SELECT * FROM TABLE_NAME WHERE KEY1 = XXX ORDER BY KEY2;
SELECT * FROM TABLE_NAME ORDER BY KEY1, KEY2;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/数据库事务/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/15/数据库事务/" itemprop="url">
                  数据库事务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-15T19:14:29+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/15/数据库事务/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/15/数据库事务/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库事务的基本概念"><a href="#数据库事务的基本概念" class="headerlink" title="数据库事务的基本概念"></a>数据库事务的基本概念</h1><p>一个数据库事务包含了一系列对数据库的读／写操作。事务的回滚提供了从失败状态中恢复到正常状态的方法，同时隔离方法为并发访问数据库提供了可能。</p>
<h1 id="ACID性质"><a href="#ACID性质" class="headerlink" title="ACID性质"></a>ACID性质</h1><ul>
<li>原子性(Atomicity)：事务作为一个整体被提交，要么全部执行，要么全部不执行。</li>
<li>一致性(Consistency)：事务的提交确保数据库从一个一致状态转移到另外一个一致状态，一致状态是指数据库中的数据应该满足完整性约束。</li>
<li>隔离性(Isolation)：在事务隔离的状态下，一个事务的执行不影响其他事务的执行。</li>
<li>持久性(Durability)：事务中包含的更改在数据库中永久保存。</li>
</ul>
<h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><p>光靠几个概念是不能掌握数据库事务的，在这里通过MySQL来探查数据库事务。</p>
<p><strong>注：MySQL中只有开启了Innodb引擎的数据库或者表才支持事务操作</strong></p>
<p>在终端开启MySQL，执行下列测试:</p>
<pre><code>mysql&gt; use transaction;
Database changed

mysql&gt; create table transaction_test(
    -&gt;   id int
    -&gt; ) engine = innodb;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into transaction_test values(5);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into transaction_test values(10);
Query OK, 1 row affected (0.00 sec)

mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from transaction_test;
+------+
| id   |
+------+
|    5 |
|   10 |
+------+
2 rows in set (0.00 sec)

mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into transaction_test values(11);
Query OK, 1 row affected (0.00 sec)

mysql&gt; rollback;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into transaction_test values(12);
Query OK, 1 row affected (0.01 sec)

mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from transaction_test;
+------+
| id   |
+------+
|    5 |
|   10 |
|   12 |
+------+
3 rows in set (0.00 sec)
</code></pre><h1 id="事务隔离等级"><a href="#事务隔离等级" class="headerlink" title="事务隔离等级"></a>事务隔离等级</h1><p>事务隔离定义了一个事务操作的结果何时对另一个事务可见。事务的隔离等级是为了防止以下几种不正常的读现象发生：</p>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>当一个事务允许读到另一个事务更改但未提交的数据时，会发生脏读。</p>
<p>假如有以下名为persons的表格：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>zsr</td>
<td>19</td>
</tr>
<tr>
<td>cjr</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>有两个事务：</p>
<p>事务一：</p>
<pre><code>select age from persons where name = &apos;zsr&apos;; #2
</code></pre><p>事务二：</p>
<pre><code>update persons set age = 20 where name = &apos;zsr&apos;; #1

rollback; #3
</code></pre><p>注释后面的数字代表执行的顺序，事务二更新语句执行之后事务一读到的年龄是20，此时事务二进行回滚，那么事务一读到的便是一个脏数据。</p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>和脏读类似，其定义是一个事务重复读取同一行但是获得了不同的数据。</p>
<p>接着上一个表格，有两个事务：</p>
<p>事务一：</p>
<pre><code>select age from persons where name = &apos;zsr&apos;; #1

select age from persons where name = &apos;zsr&apos;; #4
</code></pre><p>事务二：</p>
<pre><code>update persons set age = 20 where name = &apos;zsr&apos;; #2

commit; #3
</code></pre><p>语句后面的数字代表执行顺序，事务一读取同一行获得了不同的数据。</p>
<h2 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h2><p>当一个事务对某个表格插入／删除行时，此行位于另一个事务查询的范围，这时另一个事务执行两次相同的查询产生两个不同的结果集，问题的产生是以表为单位的。</p>
<p>接着上面的表格，有两个事务：</p>
<p>事务一：</p>
<pre><code>select * from persons where age between 19 and 21; #1

select * from persons where age between 19 and 21; #4
</code></pre><p>事务二：</p>
<pre><code>insert into persons values (&apos;zxq&apos;, 20); #2
commit; #3
</code></pre><p>除了不正常的读现象之外，还有丢失更新的异常。丢失更新是指多个事务基于同一行的数据进行更改，最后一个事务提交的更新会覆盖另一个事务已经提交的更新。</p>
<h2 id="隔离等级"><a href="#隔离等级" class="headerlink" title="隔离等级"></a>隔离等级</h2><p>数据库为事务提供了四个隔离等级，如下所示：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻象读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITED</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>READ COMMITED</td>
<td>不允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>REPEATEDLY READ</td>
<td>不允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
</tbody>
</table>
<p>隔离等级和并发性是相对的，一般来说，隔离等级越高并发性越低。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/24/Android-Proguard/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/Android-Proguard/" itemprop="url">
                  Android ProGuard
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-24T11:06:25+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/24/Android-Proguard/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/24/Android-Proguard/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先附上一个github地址： <a href="https://github.com/krschultz/android-proguard-snippets" target="_blank" rel="external">android-proguard-snippets</a>，里面记录了各种库的ProGuard规则。</p>
<h1 id="ProGuard简介"><a href="#ProGuard简介" class="headerlink" title="ProGuard简介"></a>ProGuard简介</h1><p>ProGuard是用来压缩，最优化，混淆，预检验Java代码的工具，能够防止class文件被反编译以及减小最终生成的程序的大小，其工作流程图如下图所示(图片来自官方文档):</p>
<p><img src="https://www.guardsquare.com/files/media/guardsquare2016/Website/ProGuard/ProGuard_build_process.png" alt=""></p>
<p>ProGuard要求制定Library jars，以此来重新组织class文件的依赖关系，Library jars通常是保持不变的。</p>
<p>代码的某些地方不能被混淆，如main方法，这些地方称为入口点(Entry Points)。反射时用到的类、方法、属性名也不能被混淆。</p>
<h1 id="ProGuard的使用"><a href="#ProGuard的使用" class="headerlink" title="ProGuard的使用"></a>ProGuard的使用</h1><p>先附上下载地址：<a href="http://ok34fi9ya.bkt.clouddn.com/proguard5.3.3.zip" target="_blank" rel="external">ProGuard 5.3.3下载地址</a></p>
<p>下载完成之后切换到bin目录，在终端执行：</p>
<pre><code>sh proguard.sh [options]
</code></pre><p>也可以运行proguardgui.sh来开启图形界面。</p>
<h2 id="ProGuard-Options"><a href="#ProGuard-Options" class="headerlink" title="ProGuard Options"></a>ProGuard Options</h2><p>options通常写在一个单独的configuration file里面，并且可以递归地读取配置文件，下面来介绍几个最常见的Options。</p>
<h3 id="Input-Output-Options"><a href="#Input-Output-Options" class="headerlink" title="Input/Output Options"></a>Input/Output Options</h3><h4 id="inlcude-filename"><a href="#inlcude-filename" class="headerlink" title="-inlcude filename"></a>-inlcude <em>filename</em></h4><p>读取配置文件，可以在配置文件中声明表示递归地读取。</p>
<h4 id="basedirectory-directoryname"><a href="#basedirectory-directoryname" class="headerlink" title="-basedirectory directoryname"></a>-basedirectory <em>directoryname</em></h4><p>声明配置文件的相对位置。</p>
<h4 id="injars-class-path"><a href="#injars-class-path" class="headerlink" title="-injars class_path"></a>-injars <em>class_path</em></h4><p>指定需要处理的jar文件。jar中的class文件将被处理，并将处理之后的class文件写到output jars。默认情况下非class文件将只进行复制处理。</p>
<h4 id="outjars-class-path"><a href="#outjars-class-path" class="headerlink" title="-outjars class_path"></a>-outjars <em>class_path</em></h4><p>指定output jars的名字，应该避免output jars重写掉input files。</p>
<h4 id="libraryjars-class-path"><a href="#libraryjars-class-path" class="headerlink" title="-libraryjars class_path"></a>-libraryjars <em>class_path</em></h4><p>指定应用的库文件，这些文件不会再output jars里面出现。被应用中的类继承的class需要被指定，用到的class不用被指定，但是指定它们有助于最优化代码。</p>
<h4 id="skipnonpubliclibraryclasses"><a href="#skipnonpubliclibraryclasses" class="headerlink" title="-skipnonpubliclibraryclasses"></a>-skipnonpubliclibraryclasses</h4><p>用来指定处理Library jars的时候跳过非公有类，以此来节省ProGuard运行时所占的时间和空间，但是不能总是指定这个选项，例如当某些类库中的非公有类被公有类继承的时候。</p>
<h4 id="dontskipnonpubliclibraryclasses"><a href="#dontskipnonpubliclibraryclasses" class="headerlink" title="-dontskipnonpubliclibraryclasses"></a>-dontskipnonpubliclibraryclasses</h4><p>上一个选项的反义词，从版本4.5开始这是默认选项。</p>
<h4 id="dontskipnonpubliclibraryclassmembers"><a href="#dontskipnonpubliclibraryclassmembers" class="headerlink" title="-dontskipnonpubliclibraryclassmembers"></a>-dontskipnonpubliclibraryclassmembers</h4><p>指定不要忽略包级私有类的成员（属性和方法）。由于这些类不经常被应用程序所引用，因此忽略它们是ProGuard的默认选项，但是在某些情况下不能忽略，例如应用程序的类与它们处在同一个包中，这时候被引用的包级私有类不能被忽略。</p>
<h4 id="keepdirectories-directory-filter"><a href="#keepdirectories-directory-filter" class="headerlink" title="-keepdirectories [directory_filter]"></a>-keepdirectories [<em>directory_filter</em>]</h4><p>指定需要在Output jars里面保留的文件夹名。如果directory_filter为空，那么所有的文件夹都将被保存。</p>
<h4 id="target-version"><a href="#target-version" class="headerlink" title="-target version"></a>-target <em>version</em></h4><p>指定class文件的级别。</p>
<h4 id="forceprocessing"><a href="#forceprocessing" class="headerlink" title="-forceprocessing"></a>-forceprocessing</h4><p>对class文件进行强制处理，即便输出看起来是过时的。</p>
<h3 id="Keep-Options"><a href="#Keep-Options" class="headerlink" title="Keep Options"></a>Keep Options</h3><h4 id="keep-modifier-…-class-specification"><a href="#keep-modifier-…-class-specification" class="headerlink" title="-keep [,modifier,…] class_specification"></a>-keep [,<em>modifier</em>,…] <em>class_specification</em></h4><p>指定类和类的成员当作入口点，例如一个Java应用程序的入口类以及main方法，对于类库来说，所有的public元素都应该当作入口点。此指令会保护类和其成员不被混淆和删除。</p>
<h4 id="keepclassmembers-modifier-…-class-specification"><a href="#keepclassmembers-modifier-…-class-specification" class="headerlink" title="-keepclassmembers [,modifier,…] class_specification"></a>-keepclassmembers [,<em>modifier</em>,…] <em>class_specification</em></h4><p>指定保护类的成员，例如，实现了Serializable接口的用于序列化的类成员应该被保护。此指令会保证类成员不会被混淆和删除。</p>
<h4 id="keepclasseswithmembers-modifier-…-class-specification"><a href="#keepclasseswithmembers-modifier-…-class-specification" class="headerlink" title="-keepclasseswithmembers [,modifier,…] class_specification"></a>-keepclasseswithmembers [,<em>modifier</em>,…] <em>class_specification</em></h4><p>指定保护拥有指定类成员的类及指定类成员。如在一个Java程序中，要保护拥有main方法的类，可以用这个指令，而不用一一列举。</p>
<h4 id="keepnames-class-specification"><a href="#keepnames-class-specification" class="headerlink" title="-keepnames class_specification"></a>-keepnames <em>class_specification</em></h4><p>指定类的名称不会被混淆，前提是在压缩代码的时候此类仍然存在，仅在混淆阶段起作用。</p>
<h4 id="keepclassmembernames-class-specification"><a href="#keepclassmembernames-class-specification" class="headerlink" title="-keepclassmembernames class_specification"></a>-keepclassmembernames <em>class_specification</em></h4><p>指定类成员的名字不会被混淆。仅在混淆阶段起作用，前提是Shrink过后类成员仍然存在。</p>
<h4 id="keepclasseswithmembernames-class-specification"><a href="#keepclasseswithmembernames-class-specification" class="headerlink" title="-keepclasseswithmembernames class_specification"></a>-keepclasseswithmembernames <em>class_specification</em></h4><p>指定拥有指定类成员的类及指定类成员的名字不会被混淆，如要保护一个拥有本地方法的类名和其本地方法的名字不被混淆。仅在混淆阶段起作用。</p>
<p>关于以上几个 -keep选项，详见下表：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%884.21.32.png" alt="来自官方文档"></p>
<h3 id="Shirinking-Options（非重点）"><a href="#Shirinking-Options（非重点）" class="headerlink" title="Shirinking Options（非重点）"></a>Shirinking Options（非重点）</h3><h4 id="dontshrink"><a href="#dontshrink" class="headerlink" title="-dontshrink"></a>-dontshrink</h4><p>指定不压缩代码，默认情况下，除了被上述多样的 -keep选项保护起来的类和类成员，以及它们直接或者间接依赖的类不被压缩外，其余的都不会被保留。</p>
<h3 id="Optimization-options（非重点）"><a href="#Optimization-options（非重点）" class="headerlink" title="Optimization options（非重点）"></a>Optimization options（非重点）</h3><h4 id="dontoptimize"><a href="#dontoptimize" class="headerlink" title="-dontoptimize"></a>-dontoptimize</h4><p>指定不进行最优化，默认开启。</p>
<h4 id="optimizationpasses-n"><a href="#optimizationpasses-n" class="headerlink" title="-optimizationpasses n"></a>-optimizationpasses n</h4><p>指定ProGuard进行对代码进行最优化的次数。</p>
<h4 id="optimizations"><a href="#optimizations" class="headerlink" title="-optimizations"></a>-optimizations</h4><p>指定优化时所采取的算法，属于高级选项，关于optimizations filter，请查看：<a href="https://www.guardsquare.com/en/proguard/manual/optimizations" target="_blank" rel="external">optimizations</a></p>
<h4 id="assumenosideeffects-class-specification"><a href="#assumenosideeffects-class-specification" class="headerlink" title="-assumenosideeffects class_specification"></a>-assumenosideeffects <em>class_specification</em></h4><p>指定无关紧要的方法，ProGuard会在优化阶段去除对此方法所有的调用，例如可以去除打log的方法调用，注意此举是危险的，除非我们能够确定一个方法在整个应用程序中是绝对没有用处的，否则不要轻易指定。</p>
<h4 id="mergeinterfacesaggressively"><a href="#mergeinterfacesaggressively" class="headerlink" title="-mergeinterfacesaggressively"></a>-mergeinterfacesaggressively</h4><p>合并接口，能够减少最终输出类的数目，缩小体积。不过在某些Java虚拟机上会带来性能的损失。</p>
<p><strong>注：</strong>Android Studio默认的配置文件最优化是不开启的，因为Android Java虚拟机对于优化和预检验的代码不友好。</p>
<h3 id="Obfuscation-options"><a href="#Obfuscation-options" class="headerlink" title="Obfuscation options"></a>Obfuscation options</h3><h4 id="dontobfuscate"><a href="#dontobfuscate" class="headerlink" title="-dontobfuscate"></a>-dontobfuscate</h4><p>指定关闭混淆，混淆默认是开启的，除了被 -keep选项保护起来的类和类成员，其余的类和类成员都被赋予了随机的名字。</p>
<h4 id="applymapping-filename"><a href="#applymapping-filename" class="headerlink" title="-applymapping filename"></a>-applymapping <em>filename</em></h4><p>重新利用指定file中的映射集，在此文件中列出的类和类成员被赋予映射集文件中指定的名字，没有在其中列举的但出现在输入中的类和类成员被赋予新的名字。</p>
<h4 id="overloadaggressively"><a href="#overloadaggressively" class="headerlink" title="-overloadaggressively"></a>-overloadaggressively</h4><p>允许重载，很多类属性和方法会得到相同的名称，只要方法的参数名不同或者返回值不同（遵守Java的约定），这会使得输出的体积更小，不过很多虚拟机并不支持此选项，小心使用。</p>
<h4 id="useuniqueclassmembernames"><a href="#useuniqueclassmembernames" class="headerlink" title="-useuniqueclassmembernames"></a>-useuniqueclassmembernames</h4><p>为名字相同的类成员指派相同的混淆名</p>
<h4 id="dontusemixedcaseclassnames"><a href="#dontusemixedcaseclassnames" class="headerlink" title="-dontusemixedcaseclassnames"></a>-dontusemixedcaseclassnames</h4><p>指定不用大小写混合的混淆名，这在大小写不敏感的操作系统（如Mac OS）上尤其有用。</p>
<h4 id="keeppackagenames-package-filter"><a href="#keeppackagenames-package-filter" class="headerlink" title="-keeppackagenames [package_filter]"></a>-keeppackagenames [<em>package_filter</em>]</h4><p>指定的包名不会被混淆。</p>
<h4 id="keepattributes-attribute-filter"><a href="#keepattributes-attribute-filter" class="headerlink" title="-keepattributes [attribute_filter]"></a>-keepattributes [<em>attribute_filter</em>]</h4><p>指定不会被混淆的属性，具体支持的属性，请查看：<a href="https://www.guardsquare.com/en/proguard/manual/attributes" target="_blank" rel="external">属性列表</a> </p>
<p>例如，为了便于调试，需要保存异常信息，则需要以下选项：</p>
<pre><code>-keepattributes SourceFile,LineNumberTable
</code></pre><h4 id="keepparameternames"><a href="#keepparameternames" class="headerlink" title="-keepparameternames"></a>-keepparameternames</h4><p>保证方法的参数名不被混淆。</p>
<h3 id="Preverification-options"><a href="#Preverification-options" class="headerlink" title="Preverification options"></a>Preverification options</h3><p>Android Java虚拟机对其支持的不友好，默认关闭，在此不再列举该选项。</p>
<p><strong>以上内容大部分为常用的，ProGuard的用法实在是太多了，没有必要在这里一一列举，混淆和保存选项是重要内容，其余请查看官方文档。</strong></p>
<h3 id="class-specification"><a href="#class-specification" class="headerlink" title="class_specification"></a>class_specification</h3><p>用来指定类和其成员的语句，用在 -keep选项和 -assumenosideeffects选项当中，模板设计的风格非常像Java，还有很多通配符，具体的格式如下：</p>
<pre><code>[@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname
[extends|implements [@annotationtype] classname]
[{
    [@annotationtype] [[!]public|private|protected|static|volatile|transient ...] &lt;fields&gt; |
                                                                      (fieldtype fieldname);
    [@annotationtype] [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...] &lt;methods&gt; |
                                                                                           &lt;init&gt;(argumenttype,...) |
                                                                                           classname(argumenttype,...) |
                                                                                           (returntype methodname(argumenttype,...));
    [@annotationtype] [[!]public|private|protected|static ... ] *;
    ...
}]
</code></pre><p>方括号[]代表内部的内容是可选的。</p>
<p>…代表前面几个是可以进行多个选择的。</p>
<p>classame必须写全称，例如java.lang.String。对于内部类来讲，类名前面和外部类后面要有”$”分隔。例如：<code>java.lang.Thread$State</code>。classname里面可以有如下的通配符：</p>
<ul>
<li>?：匹配任意一个字符。</li>
<li>*：匹配任何不带.的语句，不能够匹配带有.号的包名。</li>
<li>**：可以匹配带有.的语句，专门用来匹配带有.的包名。</li>
</ul>
<p>@annotationtype代表限制被注解类型注释的类，annotationtype和上述classname的规则是一样的。</p>
<p>属性和方法名大部分和Java中是一样的，除了方法中参数列表只包含参数类型不包含参数名称，属性和方法名还可以包含以下通配符：</p>
<ul>
<li>&lt;init&gt; 匹配所有的构造函数。</li>
<li>&lt;fields&gt; 匹配所有的属性。</li>
<li>&lt;methods&gt; 匹配所有的方法。</li>
<li><ul>
<li>匹配所有的方法和属性。</li>
</ul>
</li>
</ul>
<p>类型描述符可以包含以下通配符：</p>
<ul>
<li>% 匹配任何值类型，如boolean, int等等。</li>
<li>？ 匹配引用类型中的单个字符。</li>
<li><ul>
<li>匹配不带.的引用类型。</li>
</ul>
</li>
<li>** 匹配带有包名的引用类型，但不匹配数组类型。</li>
<li><em>*</em> 匹配任何类型，包括值类型和引用类型，以及数组类型。</li>
<li>… 匹配任意数量的任意类型。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/14/Java-ORM解决方案/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/14/Java-ORM解决方案/" itemprop="url">
                  Java ORM解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-14T15:31:14+08:00">
                2017-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/14/Java-ORM解决方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/14/Java-ORM解决方案/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>此篇部分内容，图片来自<a href="http://ok34fi9ya.bkt.clouddn.com/jpa_tutorial.pdf" target="_blank" rel="external">JPA Tutorial</a></p>
<h1 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h1><p>对象关系映射(Object Relational Mapping)，用面向对象的语言实现了数据的转换，存储等操作。</p>
<h1 id="Java-ORM解决方案"><a href="#Java-ORM解决方案" class="headerlink" title="Java ORM解决方案"></a>Java ORM解决方案</h1><h2 id="Java-Persistence-Api"><a href="#Java-Persistence-Api" class="headerlink" title="Java Persistence Api"></a>Java Persistence Api</h2><p>Java持久化API（以下简称JPA），是从EJB发展而来的Java ORM框架。</p>
<h3 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h3><p>其主要结构如下图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.11.50.png" alt=""><br>主要组成部分有下面几个：</p>
<ul>
<li><strong>POJO class</strong>此种类定义了像id, name等等基本属性，相当于关系数据库的表。</li>
<li><strong>Service class</strong>此种类实现了与数据库进行操作，包括获取对象，删除对象，更新对象等操作。</li>
<li><strong>JPA Provider</strong>由各大厂商提供的对JPA的具体实现，如Eclipselink, Toplink, Hibernate等等。</li>
<li><strong>Mapping file</strong>用来定义POJO class和关系数据库的映射关系。</li>
</ul>
<p>除了Mapping file，JPA还提供了各种形式的注解来定义POJO class和关系数据库之间的映射关系，主要的几个注解如下：</p>
<ul>
<li><strong>@Entity</strong>用来声明一个将要和关系数据库发生映射的POJO class。</li>
<li><strong>@Table</strong>用来声明此类对应的表名, schema和catalog。</li>
<li><strong>@Basic</strong>通常用来声明属性的加载方式。</li>
<li><strong>@Id</strong>用来声明POJO class对应的表的主键。</li>
<li><strong>@GeneratedValue</strong>用来指定主键的生成策略。</li>
<li><strong>@Column</strong>用来声明属性对应的列。</li>
</ul>
<p>此外，POJO class应该具备Java Bean的标准形式。</p>
<h3 id="用IntelliJ-IDEA建立JPA项目"><a href="#用IntelliJ-IDEA建立JPA项目" class="headerlink" title="用IntelliJ IDEA建立JPA项目"></a>用IntelliJ IDEA建立JPA项目</h3><p>笔者采用的环境是IDEA 2017.1.1，Hibernate 5.2.9，JPA 2.1。注意Hibernate的版本要和JPA的版本对应，不然会出错。</p>
<h4 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h4><p><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.37.05.png" alt=""><br>勾选JavaEE Persistence项目，下面指定JPA的版本为2.1，Provider为Hibernate，建好项目后整个项目的结构如图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.42.46.png" alt=""></p>
<h4 id="加入Hibernate以及数据库驱动依赖"><a href="#加入Hibernate以及数据库驱动依赖" class="headerlink" title="加入Hibernate以及数据库驱动依赖"></a>加入Hibernate以及数据库驱动依赖</h4><p>笔者采用的是h2数据库，将相应的依赖包放在lib目录下，对用的jar依赖包的下载地址：<a href="http://ok34fi9ya.bkt.clouddn.com/jpa-with-hibernate.zip" target="_blank" rel="external">h2以及Hibernate依赖包</a></p>
<p>将jar包放在lib文件夹之后，打开Project Struture，找到项目对应的Module，为其添加dependicies:<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.59.23.png" alt=""></p>
<h4 id="配置persistence-xml文件"><a href="#配置persistence-xml文件" class="headerlink" title="配置persistence.xml文件"></a>配置persistence.xml文件</h4><p>此文件定义了数据源，映射类等基本信息，且一定要在项目类路径下的META-INF文件夹下，笔者采用的是h2数据库，配置如下：</p>
<pre><code>&lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; version=&quot;2.1&quot;&gt;

    &lt;persistence-unit name=&quot;HibernatePersistenceUnit&quot;&gt;
        &lt;!--定义Provider--&gt;
        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
        &lt;properties&gt;
            &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:h2:~/test/test&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;org.h2.Driver&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;sa&quot;/&gt;
            &lt;!--&lt;property name=&quot;hibernate.connection.password&quot; value=&quot;&quot;/&gt;--&gt;
            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot;/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</code></pre><p>注意，笔者采用的是h2嵌入式数据库，因此不用提供用户的密码，还要注意里面的hbm2ddl.auto属性，此属性的值在这里是create，意味着应用程序每次启动都会创建一个新的表格，而上一次启动创建的表格将不复存在，关于此属性更多的内容，请见：<a href="http://blog.csdn.net/kjfcpua/article/details/4272415" target="_blank" rel="external">hibernate.hbm2ddl.auto属性配置</a></p>
<p>至此，项目的基本配置完毕。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>此小节通过小小的例子来阐述JPA的基本使用。</p>
<p>Employee.java:</p>
<pre><code>@Entity
@Table(name = &quot;Employee&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Employee {
    @Id
    private int eid;
    private String ename;
    private double salary;
    private String deg;

    public Employee(String ename, double salary, String deg) {
        this.ename = ename;
        this.salary = salary;
        this.deg = deg;
    }

    public Employee() {

    }

    public int getEid() {
        return eid;
    }

    public void setEid(int eid) {
        this.eid = eid;
    }

    public String getEname() {
        return ename;
    }

    public void setEname(String ename) {
        this.ename = ename;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public String getDeg() {
        return deg;
    }

    public void setDeg(String deg) {
        this.deg = deg;
    }

    @Override
    public String toString() {
        return &quot;Employee{&quot; +
                &quot;eid=&quot; + eid +
                &quot;, ename=&apos;&quot; + ename + &apos;\&apos;&apos; +
                &quot;, salary=&quot; + salary +
                &quot;, deg=&apos;&quot; + deg + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);

    private static void createAnEmployee(Employee employee) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        manager.persist(employee);
        transaction.commit();
        manager.close();
    }

    private static Employee findEmployee(int eid) {
        EntityManager manager = factory.createEntityManager();
        try {
            return manager.find(Employee.class, eid);
        } finally {
            manager.close();
        }
    }

    private static void deleteEmployee(int eid) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        Employee employee = manager.find(Employee.class, eid);
        manager.remove(employee);
        transaction.commit();
        manager.close();
    }

    private static void updateEmployeeSalary(int eid, double salary) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        Employee employee = manager.find(Employee.class, eid);
        System.out.println(employee);
        employee.setSalary(salary);
        transaction.commit();
        manager.close();
    }


    public static void main(String[] args) {
        Employee employee = new Employee();

        employee.setEid(100);
        employee.setEname(&quot;zsr&quot;);
        employee.setSalary(3000);
        employee.setDeg(&quot;Student&quot;);

        createAnEmployee(employee);
        System.out.println(findEmployee(100));
        updateEmployeeSalary(100, 5000);
        System.out.println(findEmployee(100));
        deleteEmployee(100);
        factory.close();
    }
}
</code></pre><p>结果如下：</p>
<pre><code>Employee{eid=100, ename=&apos;zsr&apos;, salary=3000.0, deg=&apos;Student&apos;}
Employee{eid=100, ename=&apos;zsr&apos;, salary=3000.0, deg=&apos;Student&apos;}
Employee{eid=100, ename=&apos;zsr&apos;, salary=5000.0, deg=&apos;Student&apos;}
</code></pre><p>需要注意的是：如果要手动指定主键，就不要用<strong>@GeneratedValue</strong>去注释主键，否则会出现detached entity passed to persist异常。</p>
<p>以上主要用到的类有下面几个：</p>
<ul>
<li><strong>EntityManagerFactory</strong>  EntityManager的工厂类，与EntityManager是一对多的关系。</li>
<li><strong>EntityManager</strong> 用来执行对象持久化的类，是<strong>Query</strong>类的工厂类。</li>
<li><strong>EntityTransaction</strong> 与EntityManager是一对一的关系，作用在EntityManager上更新表的操作存储在其中，最后用其commit()方法才正式生效。</li>
<li><strong>Persistence</strong> 提供静态方法用来生成EntityManagerFactory对象。</li>
</ul>
<p>关系如下图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%889.35.54.png" alt=""></p>
<h3 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h3><p>JPQL是在SQL语句基础之上建立起来的标准语句，能够执行对表中对象的<strong>SELECT, UPDATE, DELETE</strong>。</p>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>main方法改成如下代码：</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
public static void main(String[] args) {
    Employee employee1 = new Employee(100, &quot;Gopal&quot;, 40000, &quot;Technical Manager&quot;);
    Employee employee2 = new Employee(101, &quot;Manisha&quot;, 35000, &quot;Reader&quot;);
    Employee employee3 = new Employee(102, &quot;Masthanvali&quot;, 37000, &quot;Teacher&quot;);
    Employee employee4 = new Employee(103, &quot;Satish&quot;, 30000, &quot;Student&quot;);
    Employee employee5 = new Employee(104, &quot;Krishna&quot;, 31000, &quot;Tutor&quot;);
    Employee employee6 = new Employee(105, &quot;Kiran&quot;, 32000, &quot;Drinker&quot;);

    createAnEmployee(employee1);
    createAnEmployee(employee2);
    createAnEmployee(employee3);
    createAnEmployee(employee4);
    createAnEmployee(employee5);
    createAnEmployee(employee6);

    EntityManager manager = factory.createEntityManager();

    Query betweenQuery = manager.createQuery(&quot;select e from Employee e where e.salary between 30000 and 35000&quot;);
    List&lt;Employee&gt; salaryQueryEmployees = (List&lt;Employee&gt;) betweenQuery.getResultList();

    for (Employee employee : salaryQueryEmployees) {
        System.out.println(employee);
    }

    System.out.println();

    Query likeQuery = manager.createQuery(&quot;select  e from Employee e where e.ename like &apos;M%&apos;&quot;);
    List&lt;Employee&gt; likeQueryResults = (List&lt;Employee&gt;) likeQuery.getResultList();

    for (Employee employee : likeQueryResults) {
        System.out.println(employee);
    }

    manager.close();
    factory.close();
}
</code></pre><p>运行结果：</p>
<pre><code>Employee{eid=101, ename=&apos;Manisha&apos;, salary=35000.0, deg=&apos;Reader&apos;}
Employee{eid=103, ename=&apos;Satish&apos;, salary=30000.0, deg=&apos;Student&apos;}
Employee{eid=104, ename=&apos;Krishna&apos;, salary=31000.0, deg=&apos;Tutor&apos;}
Employee{eid=105, ename=&apos;Kiran&apos;, salary=32000.0, deg=&apos;Drinker&apos;}

Employee{eid=101, ename=&apos;Manisha&apos;, salary=35000.0, deg=&apos;Reader&apos;}
Employee{eid=102, ename=&apos;Masthanvali&apos;, salary=37000.0, deg=&apos;Teacher&apos;}
</code></pre><p>sql语法实在是繁多，这里不再一一详细列举。</p>
<h4 id="NamedQuery"><a href="#NamedQuery" class="headerlink" title="NamedQuery"></a>NamedQuery</h4><p><strong>@NamedQuery</strong>注解用实现定义好的且不可变的query语句来执行查询操作，这个query语句中含有未知的参数可以在别处指定，用法如下：</p>
<p>Employee.java:</p>
<pre><code>@Entity
@Table(name = &quot;Employee&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
@NamedQuery(query = &quot;select e from Employee e where e.eid = :id&quot;, name = &quot;find employee by id&quot;)
public class Employee {
    ...
}
</code></pre><p>main函数：</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
public static void main(String[] args) {
    ...

    EntityManager manager = factory.createEntityManager();

    Query query = manager.createNamedQuery(&quot;find employee by id&quot;);
    query.setParameter(&quot;id&quot;, 103);

    Employee employee = (Employee) query.getSingleResult();
    System.out.println(employee);

    manager.close();
    factory.close();
}
</code></pre><h3 id="JPA对继承的处理"><a href="#JPA对继承的处理" class="headerlink" title="JPA对继承的处理"></a>JPA对继承的处理</h3><p>Java对象之间存在错综复杂的继承关系，而关系数据库没有继承这种概念，JPA对这种情况提供了多种解决方案。</p>
<p>考虑如下的继承关系：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8810.25.29.png" alt=""></p>
<h4 id="单一表策略"><a href="#单一表策略" class="headerlink" title="单一表策略"></a>单一表策略</h4><p>单一表策略是指将不同的对象（存在继承关系）放在一个表当中，代码如下：</p>
<p>Staff.java:</p>
<pre><code>@Entity
@Table(name = &quot;Staff&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = &quot;type&quot;)
public class Staff {
    @Id
    private int sid;
    private String sname;

    public Staff(int sid, String sname) {
        this.sid = sid;
        this.sname = sname;
    }

    public Staff() {

    }

    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }
}
</code></pre><p>TeachingStaff.java:</p>
<pre><code>@Entity
@DiscriminatorValue(value = &quot;TS&quot;)
public class TeachingStaff extends Staff {
    private String qualification;
    private String subjectexpertise;

    public TeachingStaff(int sid, String sname, String qualification, String subjectexpertise) {
        super(sid, sname);
        this.qualification = qualification;
        this.subjectexpertise = subjectexpertise;
    }

    public TeachingStaff() {
        super();
    }

    public String getQualification() {
        return qualification;
    }

    public void setQualification(String qualification) {
        this.qualification = qualification;
    }

    public String getSubjectexpertise() {
        return subjectexpertise;
    }

    public void setSubjectexpertise(String subjectexpertise) {
        this.subjectexpertise = subjectexpertise;
    }
}
</code></pre><p>NonTeachingStaff.java:</p>
<pre><code>@Entity
@DiscriminatorValue(value = &quot;NST&quot;)
public class NonTeachingStaff extends Staff {
    private String areaexpertise;

    public NonTeachingStaff(int sid, String sname, String areaexpertise) {
        super(sid, sname);
        this.areaexpertise = areaexpertise;
    }

    public NonTeachingStaff() {
        super();
    }

    public String getAreaexpertise() {
        return areaexpertise;
    }

    public void setAreaexpertise(String areaexpertise) {
        this.areaexpertise = areaexpertise;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    @SuppressWarnings(&quot;unchecked&quot;)
    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        TeachingStaff ts1 = new TeachingStaff(100, &quot;zsr&quot;, &quot;fine&quot;, &quot;a&quot;);
        TeachingStaff ts2 = new TeachingStaff(101, &quot;zx&quot;, &quot;good&quot;, &quot;a&quot;);

        NonTeachingStaff nts1 = new NonTeachingStaff(102, &quot;zy&quot;, &quot;a&quot;);
        NonTeachingStaff nts2 = new NonTeachingStaff(103, &quot;zu&quot;, &quot;b&quot;);

        manager.persist(ts1);
        manager.persist(ts2);
        manager.persist(nts1);
        manager.persist(nts2);

        transaction.commit();

        manager.close();
        factory.close();
    }
}
</code></pre><p>运行结束后打开h2 console，执行:</p>
<pre><code>SELECT * FROM STAFF;
</code></pre><p>运行结果：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8810.51.27.png" alt=""></p>
<h4 id="合并表策略"><a href="#合并表策略" class="headerlink" title="合并表策略"></a>合并表策略</h4><p>合并表策略（不知道怎么翻译才是对的，原文是Joined Table Strategy）是指将几个对象模型中共有的东西抽出来，在此基础上为子类分别建表，代码如下：</p>
<p>Staff.java:</p>
<pre><code>@Entity
@Table(name = &quot;Staff&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
@Inheritance(strategy = InheritanceType.JOINED)
public class Staff {
    ...
}
</code></pre><p>TeachingStaff.java:</p>
<pre><code>@Entity
@PrimaryKeyJoinColumn(referencedColumnName = &quot;sid&quot;)
public class TeachingStaff extends Staff {
    ...
}
</code></pre><p>NonTeachingStaff的变化与TeachingStaff的相同，不再展示。</p>
<p>main方法不变，执行完毕之后，打开h2 console，运行如下指令：</p>
<pre><code>SELECT * FROM STAFF;
SELECT * FROM TEACHINGSTAFF;
SELECT * FROM NONTEACHINGSTAFF;
</code></pre><p>结果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8811.12.43.png" alt=""></p>
<h4 id="一类一表策略"><a href="#一类一表策略" class="headerlink" title="一类一表策略"></a>一类一表策略</h4><p>顾名思义就是为每一个类都产生一个表，此方法不再做展示。</p>
<h3 id="实体间关系"><a href="#实体间关系" class="headerlink" title="实体间关系"></a>实体间关系</h3><p>除了继承，实体之间也有很多复杂的组合关系，JPA为实体之间的关系提供了四种注解：<strong>@OneToOne @OneToMany @ManyToOne @ManyToMany</strong></p>
<h4 id="ManyToOne"><a href="#ManyToOne" class="headerlink" title="ManyToOne"></a>ManyToOne</h4><p>考虑下面的模型：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8811.28.37.png" alt=""><br>此时多个Employee可以对应一个Department，在关系数据库里面，Employee的did便是一个外键，且指向Department的id。</p>
<p>代码如下：</p>
<p>Employee.java:</p>
<pre><code>@Entity
@Table(name = &quot;Employee&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Employee {
    @Id
    private int eid;
    private String ename;
    private double salary;
    private String deg;
    @ManyToOne
    private Department department;

    ...

}
</code></pre><p>Department.java:</p>
<pre><code>@Entity
public class Department {
    @Id
    private int did;
    private String dname;

    public Department(int did, String dname) {
        this.did = did;
        this.dname = dname;
    }

    public Department() {
    }

    public int getDid() {
        return did;
    }

    public void setDid(int did) {
        this.did = did;
    }

    public String getDname() {
        return dname;
    }

    public void setDname(String dname) {
        this.dname = dname;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    @SuppressWarnings(&quot;unchecked&quot;)
    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        Department department = new Department(10, &quot;DingXiang&quot;);
        manager.persist(department);

        Employee employee1 = new Employee(100, &quot;zsr&quot;, 4000, &quot;Student&quot;);
        employee1.setDepartment(department);

        Employee employee2 = new Employee(101, &quot;yui&quot;, 4000, &quot;Student&quot;);
        employee2.setDepartment(department);

        Employee employee3 = new Employee(102, &quot;yuo&quot;, 4000, &quot;Student&quot;);
        employee3.setDepartment(department);

        manager.persist(employee1);
        manager.persist(employee2);
        manager.persist(employee3);

        transaction.commit();

        manager.close();
        factory.close();
    }
} 
</code></pre><p>执行结束后，打开h2 console，查看Employee和Department表，结果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8811.47.43.png" alt=""></p>
<h4 id="OneToMany"><a href="#OneToMany" class="headerlink" title="OneToMany"></a>OneToMany</h4><p>上面的反过来说，一个Department可以对应多个Employee，代码修改如下：</p>
<p>Department.java:</p>
<pre><code>@Entity
public class Department {
    @Id
    private int did;
    private String dname;
    @OneToMany(targetEntity = Employee.class)
    private List&lt;Employee&gt; employeeList;

    public Department(int did, String dname) {
        this.did = did;
        this.dname = dname;
    }

    public Department() {
    }

    public List&lt;Employee&gt; getEmployeeList() {
        return employeeList;
    }

    public void setEmployeeList(List&lt;Employee&gt; employeeList) {
        this.employeeList = employeeList;
    }

    public int getDid() {
        return did;
    }

    public void setDid(int did) {
        this.did = did;
    }

    public String getDname() {
        return dname;
    }

    public void setDname(String dname) {
        this.dname = dname;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        Department department = new Department(10, &quot;DingXiang&quot;);

        Employee employee1 = new Employee(100, &quot;zsr&quot;, 4000, &quot;Student&quot;);
        Employee employee2 = new Employee(101, &quot;yui&quot;, 4000, &quot;Student&quot;);
        Employee employee3 = new Employee(102, &quot;yuo&quot;, 4000, &quot;Student&quot;);

        manager.persist(employee1);
        manager.persist(employee2);
        manager.persist(employee3);

        List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();
        employees.add(employee1);
        employees.add(employee2);
        employees.add(employee3);

        department.setEmployeeList(employees);

        manager.persist(department);

        transaction.commit();

        manager.close();
        factory.close();
    }
}
</code></pre><p>执行完毕之后，打开h2 console，查看表信息，如下所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-16%20%E4%B8%8A%E5%8D%8812.00.54.png" alt=""></p>
<h4 id="OneToOne"><a href="#OneToOne" class="headerlink" title="OneToOne"></a>OneToOne</h4><p>假设上述Employee类和Department类是一一对应的关系，只需要把ManyToOne小节下Employee类中对department成员上的注解修改成<strong>@OneToOne</strong>，再在main方法中为每个Employee提供一个Department即可，执行完毕后，生成的表的格式和ManyToOne的格式相同，这里不再展示。</p>
<h4 id="ManyToMany"><a href="#ManyToMany" class="headerlink" title="ManyToMany"></a>ManyToMany</h4><p>考虑下面的模型：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-16%20%E4%B8%8A%E5%8D%8812.13.46.png" alt=""><br>一个课程可以有多个老师同时教学，一个老师也可以教多个课程，代码如下：</p>
<p>Clazz.java:</p>
<pre><code>@Entity
@Table(name = &quot;Clazz&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Clazz {
    @Id
    private int cid;
    private String cname;

    @ManyToMany(targetEntity = Teacher.class)
    private Set&lt;Teacher&gt; teachers;

    public Clazz() {
    }

    public Clazz(int cid, String cname) {
        this.cid = cid;
        this.cname = cname;
    }

    public Set&lt;Teacher&gt; getTeachers() {
        return teachers;
    }

    public void setTeachers(Set&lt;Teacher&gt; teachers) {
        this.teachers = teachers;
    }

    public int getCid() {
        return cid;
    }

    public void setCid(int cid) {
        this.cid = cid;
    }

    public String getCname() {
        return cname;
    }

    public void setCname(String cname) {
        this.cname = cname;
    }
}
</code></pre><p>Teacher.java:</p>
<pre><code>@Entity
@Table(name = &quot;Teacher&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Teacher {
    @Id
    private int tid;
    private String tname;

    @ManyToMany(targetEntity = Clazz.class)
    Set&lt;Clazz&gt; clazzes;

    public Teacher(int tid, String tname) {
        this.tid = tid;
        this.tname = tname;
    }

    public Teacher() {
    }

    public int getTid() {
        return tid;
    }

    public void setTid(int tid) {
        this.tid = tid;
    }

    public String getTname() {
        return tname;
    }

    public void setTname(String tname) {
        this.tname = tname;
    }

    public Set&lt;Clazz&gt; getClazzes() {
        return clazzes;
    }

    public void setClazzes(Set&lt;Clazz&gt; clazzes) {
        this.clazzes = clazzes;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        Clazz clazz = new Clazz(10, &quot;Chinese&quot;);
        Clazz clazz1 = new Clazz(11, &quot;Math&quot;);
        Clazz clazz2 = new Clazz(12, &quot;English&quot;);

        manager.persist(clazz);
        manager.persist(clazz1);
        manager.persist(clazz2);

        Set&lt;Clazz&gt; clazzes = new HashSet&lt;&gt;();
        clazzes.add(clazz);
        clazzes.add(clazz1);
        clazzes.add(clazz2);

        Set&lt;Clazz&gt; clazzes1 = new HashSet&lt;&gt;(clazzes);
        Set&lt;Clazz&gt; clazzes2 = new HashSet&lt;&gt;(clazzes);

        Teacher teacher1 = new Teacher(1, &quot;zsr&quot;);
        Teacher teacher2 = new Teacher(2, &quot;zx&quot;);
        Teacher teacher3 = new Teacher(3, &quot;zo&quot;);

        teacher1.setClazzes(clazzes);
        teacher2.setClazzes(clazzes1);
        teacher3.setClazzes(clazzes2);

        manager.persist(teacher1);
        manager.persist(teacher2);
        manager.persist(teacher3);

        transaction.commit();

        manager.close();
        factory.close();
    }
}
</code></pre><p>执行完毕之后打开h2 console查看表，结果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-16%20%E4%B8%8A%E5%8D%8812.33.02.png" alt=""></p>
<h3 id="Criteria-Api"><a href="#Criteria-Api" class="headerlink" title="Criteria Api"></a>Criteria Api</h3><p>Criteria Api是用来执行标准查询的api，其用法遵循以下流程：</p>
<pre><code>EntityManager em = ...;
CriteriaBuilder cb = em.getCriteriaBuilder(); CriteriaQuery&lt;Entity class&gt; cq = cb.createQuery(Entity.class); 
Root&lt;Entity&gt; from = cq.from(Entity.class);
cq.select(Entity);
TypedQuery&lt;Entity&gt; q = em.createQuery(cq);
List&lt;Entity&gt; allitems = q.getResultList();
</code></pre><p>还是拿JPQL小节的数据当例子，代码如下：</p>
<p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);

    private static void createAnEmployee(EntityManager manager, Employee employee) {
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        manager.persist(employee);
        transaction.commit();
    }


    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();


        Employee employee1 = new Employee(100, &quot;Gopal&quot;, 40000, &quot;Technical Manager&quot;);
        Employee employee2 = new Employee(101, &quot;Manisha&quot;, 35000, &quot;Reader&quot;);
        Employee employee3 = new Employee(102, &quot;Masthanvali&quot;, 37000, &quot;Teacher&quot;);
        Employee employee4 = new Employee(103, &quot;Satish&quot;, 30000, &quot;Student&quot;);
        Employee employee5 = new Employee(104, &quot;Krishna&quot;, 31000, &quot;Tutor&quot;);
        Employee employee6 = new Employee(105, &quot;Kiran&quot;, 32000, &quot;Drinker&quot;);

        createAnEmployee(manager, employee1);
        createAnEmployee(manager, employee2);
        createAnEmployee(manager, employee3);
        createAnEmployee(manager, employee4);
        createAnEmployee(manager, employee5);
        createAnEmployee(manager, employee6);

        CriteriaBuilder criteriaBuilder = manager.getCriteriaBuilder();
        CriteriaQuery&lt;Employee&gt; employeeCriteriaQuery = criteriaBuilder.createQuery(Employee.class);
        Root&lt;Employee&gt; from = employeeCriteriaQuery.from(Employee.class);

        CriteriaQuery&lt;Employee&gt; betweenSelect = employeeCriteriaQuery.select(from)
                .where(criteriaBuilder.between(from.get(&quot;salary&quot;), 30000, 35000));
        TypedQuery&lt;Employee&gt; betweenSelectTypedQuery = manager.createQuery(betweenSelect);
        List&lt;Employee&gt; betweenSelectResults = betweenSelectTypedQuery.getResultList();

        for (Employee employee : betweenSelectResults) {
            System.out.println(employee);
        }

        manager.close();
        factory.close();
    }
}
</code></pre><p>输出和JPQL小节的输出效果相同，可以看出Criteria更加面向对象。</p>
<h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>上面再配置JPA项目的时候我们用Hibernate作为Provider。Hibernate是一个优秀的开源Java ORM框架，既可以适配JPA也可以拿出来单独使用，有了上面的基础其使用也就变的简单自然。Hibernate还提供了缓存和检索服务，拥有拦截功能，其具体使用请查看官方文档，教程推荐: <a href="http://wiki.jikexueyuan.com/project/hibernate/" target="_blank" rel="external">Hibernate教程</a></p>
<p>另外，IntelliJ IDEA也可以直接建立Hibernate项目省去了配置的麻烦…</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/08/用PopupWindow实现键盘之上的悬浮窗/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/08/用PopupWindow实现键盘之上的悬浮窗/" itemprop="url">
                  用PopupWindow实现键盘之上的悬浮窗
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-08T20:22:23+08:00">
                2017-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/08/用PopupWindow实现键盘之上的悬浮窗/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/08/用PopupWindow实现键盘之上的悬浮窗/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近遇到一个写评论的需求，就是点击一个写评论的按钮跳出软键盘，软键盘之上有一个输入框和发送按钮，想了好半天决定采用悬浮窗，其主要想法来自：<a href="http://www.itdadao.com/articles/c15a380342p0.html" target="_blank" rel="external">模仿微信，QQ评论输入框</a>，其效果图如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/Screenshot_1491657613.png" alt=""></p>
<h1 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h1><h2 id="activity-main"><a href="#activity-main" class="headerlink" title="activity_main:"></a>activity_main:</h2><pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.stephen.popupwindowedittext.MainActivity&quot;
    android:id=&quot;@+id/root&quot;&gt;

    &lt;LinearLayout
        android:id=&quot;@+id/comment_part&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:orientation=&quot;horizontal&quot;
        android:padding=&quot;12dp&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/comment&quot;
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_weight=&quot;1&quot;
            android:textStyle=&quot;bold&quot;
            android:text=&quot;评论&quot;
            android:textSize=&quot;14sp&quot;/&gt;
        &lt;Button
            android:id=&quot;@+id/write_comment_button&quot;
            android:background=&quot;@drawable/bg_write_comment_button&quot;
            android:layout_width=&quot;48dp&quot;
            android:layout_height=&quot;24dp&quot;
            android:text=&quot;写评论&quot;
            android:textSize=&quot;10sp&quot;
            android:textColor=&quot;@android:color/white&quot;/&gt;
    &lt;/LinearLayout&gt;

    &lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/comments_list&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@id/comment_part&quot;/&gt;
&lt;/RelativeLayout&gt;
</code></pre><h2 id="window-edittext"><a href="#window-edittext" class="headerlink" title="window_edittext"></a>window_edittext</h2><pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;horizontal&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:paddingLeft=&quot;12dp&quot;
    android:paddingRight=&quot;12dp&quot;&gt;

    &lt;EditText
        android:id=&quot;@+id/main_edit_text&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_weight=&quot;1&quot;/&gt;
    &lt;Button
        android:background=&quot;@drawable/bg_send_button&quot;
        android:id=&quot;@+id/send_button&quot;
        android:layout_width=&quot;52dp&quot;
        android:layout_height=&quot;24dp&quot;
        android:layout_marginLeft=&quot;8dp&quot;
        android:text=&quot;发送&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;12sp&quot;/&gt;
&lt;/LinearLayout&gt;
</code></pre><h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity:"></a>MainActivity:</h2><pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    private List&lt;String&gt; data = new ArrayList&lt;&gt;();
    private RecyclerView rv;
    private InputMethodManager imm;

    private View commentPatternView;
    private PopupWindow commentPatternWindow;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);

        initView();
    }

    private void initView() {
        findViewById(R.id.write_comment_button).setOnClickListener(this);
        rv = (RecyclerView) findViewById(R.id.comments_list);
        rv.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));
        rv.setAdapter(new CommentsListAdapter(data));
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.write_comment_button: {
                showCommentPattern();
                break;
            }
            case R.id.send_button: {
                sendComment();
                if (commentPatternWindow != null) {
                    commentPatternWindow.dismiss();
                }
                break;
            }
        }
    }

    private void sendComment() {
        String content = ((EditText) commentPatternView.findViewById(R.id.main_edit_text)).getText().toString();
        data.add(content);
        rv.getAdapter().notifyItemInserted(data.size() - 1);
    }

    private void showCommentPattern() {
        View parent = findViewById(R.id.root);

        if (commentPatternView == null) {
            commentPatternView = getLayoutInflater().inflate(R.layout.window_edit_text, null);
            commentPatternView.findViewById(R.id.send_button).setOnClickListener(this);
        }

        if (commentPatternWindow == null) {
            commentPatternWindow = new PopupWindow(commentPatternView, WindowManager.LayoutParams.MATCH_PARENT,
                    WindowManager.LayoutParams.WRAP_CONTENT, true);
            commentPatternWindow.setBackgroundDrawable(new ColorDrawable(Color.WHITE));
            commentPatternWindow.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
        }

        commentPatternWindow.showAtLocation(parent, Gravity.BOTTOM, 0, 0);
        commentPatternWindow.setOnDismissListener(new PopupWindow.OnDismissListener() {
            @Override
            public void onDismiss() {
                imm.toggleSoftInput(InputMethodManager.HIDE_IMPLICIT_ONLY, 0);
            }
        });

        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                imm.showSoftInput(commentPatternView.findViewById(R.id.main_edit_text), InputMethodManager.SHOW_FORCED);
            }
        }, 100);
    }
}
</code></pre><p>上面两个布局文件没什么好说的，主要是第三个文件，首先要注意的是要调用<strong>PopupWindow</strong>的<strong>setBackgroundDrawable</strong>方法，否则会有各种意想不到的bug；其次要调用<strong>setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE)</strong>，这是为了让<strong>PopupWindow</strong>出现在软键盘之上。</p>
<p>软键盘的调用方式也是值得注意的地方，在<strong>showAtLocation</strong>方法调用完成之后不能立即使软键盘弹出，得有一个延时的过程，软键盘消失的事件与window消失的事件绑定在一起即可。</p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>上述方法有一个缺陷，就是不能禁止掉<strong>outsideTouchable</strong>，因为要接受软键盘的输入，所以<strong>focusable</strong>必须为<strong>true</strong>，而<strong>setOutsideTouchable(false)</strong>方法必须在<strong>focusable</strong>为<strong>false</strong>，<strong>touchable</strong>为<strong>true</strong>时才生效，所以上述方法不能保证点击其余空白区域悬浮窗不消失。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/14/使用Fork-Join架构进行归并排序/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/使用Fork-Join架构进行归并排序/" itemprop="url">
                  使用Fork/Join架构进行归并排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-14T23:37:51+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/使用Fork-Join架构进行归并排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/使用Fork-Join架构进行归并排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>以下部分文字，图片摘自《Java并发编程的艺术》</p>
<h1 id="Fork-Join框架简介"><a href="#Fork-Join框架简介" class="headerlink" title="Fork/Join框架简介"></a>Fork/Join框架简介</h1><p>Fork/Join框架是jdk7中提供的并行框架，其主要的特点是把一个大任务分割成几块不同的小任务，由不同的线程去执行这一系列的小任务，最终结果合并成大任务的结果。</p>
<p>其主要原理如图所示：<br><img src="http://cdn.infoqstatic.com/statics_s1_20170314-0434/resource/articles/fork-join-introduction/zh/resources/21.png" alt=""></p>
<h1 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h1><p>工作窃取算法的意思是每个线程的任务队列执行完毕之后，此线程会将其他线程的任务队列中的任务“窃取”到本线程的任务队列中来。使用窃取算法的好处就是充分利用了线程的并行计算，有关工作窃取算法的更多内容，请看：<a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="external">Work Stealing</a></p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>再实际应用上，要首先确定一个大的任务是否能够分成几个小的任务，是否能把小任务的结果进行合并，这样就自然而然的想到递归。下面笔者实现一个用Fork/Join架构实现的归并排序算法：</p>
<pre><code>public class ForkJoinPractice {
    static class SortTask&lt;T extends Comparable&lt;T&gt;&gt; extends RecursiveAction {
        T[] array;
        int start;
        int end;
        int mid;

        public SortTask(T[] array, int start, int end) {
            this.array = array;
            this.start = start;
            this.end = end;
            this.mid = (this.start + this.end) / 2;
        }

        @Override
        protected void compute() {
            int mid;
            if (start &lt; end) {
                mid = (start + end) / 2;
                //将任务分解
                invokeAll(new SortTask&lt;T&gt;(array, start, mid), new SortTask&lt;T&gt;(array, mid + 1, end));
                merge();
            }
        }

        private void merge() {
            int n1 = mid - start + 1;
            int n2 = end - mid;
            int i, j, k;

            List&lt;T&gt; leftList = new ArrayList&lt;&gt;(n1);
            List&lt;T&gt; rightList = new ArrayList&lt;&gt;(n2);

            for (i = 0; i &lt; n1; i++) {
                leftList.add(array[start + i]);
            }

            for (j = 0; j &lt; n2; j++) {
                rightList.add(array[mid + 1 + j]);
            }

            i = j = 0;
            k = start;

            while (i &lt; n1 &amp;&amp; j &lt; n2) {
                if (leftList.get(i).compareTo(rightList.get(j)) &lt; 0) {
                    array[k++] = leftList.get(i++);
                } else {
                    array[k++] = rightList.get(j++);
                }
            }

            while (i &lt; n1) {
                array[k++] = leftList.get(i++);
            }

            while (j &lt; n2) {
                array[k++] = rightList.get(j++);
            }
        }
    }

    public static void main(String[] args) {
        Integer[] array = new Integer[90];
        for (int i = 0; i &lt; 90; i++) {
            array[i] = 90 - i;
        }

        SortTask&lt;Integer&gt; sortTask = new SortTask&lt;&gt;(array, 0, array.length - 1);
        ForkJoinPool pool = new ForkJoinPool();
        pool.submit(sortTask);
        try {
            //等待任务结束
            pool.awaitTermination(3, TimeUnit.SECONDS);
            pool.shutdown();
            for (int i :  array) {
                System.out.println(i);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Stephen Zhang" />
          <p class="site-author-name" itemprop="name">Stephen Zhang</p>
          <p class="site-description motion-element" itemprop="description">zsr的小本本</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Zhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zsrcodingme"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
