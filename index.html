<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Stephen Zhang&apos;s notes.">
<meta property="og:type" content="website">
<meta property="og:title" content="Stephen's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Stephen's blog">
<meta property="og:description" content="Stephen Zhang&apos;s notes.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stephen's blog">
<meta name="twitter:description" content="Stephen Zhang&apos;s notes.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Stephen's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Stephen's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/10/Java内存模型-一/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/10/Java内存模型-一/" itemprop="url">
                  Java内存模型(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-10T20:06:10+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/10/Java内存模型-一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/10/Java内存模型-一/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JMM(Java Memory Model),即Java内存模型，是Java实现并发的主要机制。多个线程通过JMM共享程序公有状态进而实现隐式通信。</p>
<h1 id="抽象结构"><a href="#抽象结构" class="headerlink" title="抽象结构"></a>抽象结构</h1><p>程序的公有状态，共享变量等储存在主内存(Main Memory)当中。每个线程都有一个本地内存(Local Memory)来储存主内存中共享变量的副本，其结构如下图所示：<br><img src="http://cdn.infoqstatic.com/statics_s1_20170228-0434_4/resource/articles/java-memory-model-1/zh/resources/11.png" alt=""><br>（本图作者为Java资深软件工程师：<a href="http://ifeve.com/author/25622818/" target="_blank" rel="external">程晓明</a>）</p>
<p>此时两个线程A,B的通信流程为：</p>
<ul>
<li>线程A更新本地内存中共享变量的副本，并将其写入主内存。</li>
<li>线程B从主内存中读取更新过的共享变量。</li>
</ul>
<p>现有如下程序：</p>
<pre><code>public class MemoryModelDemo {
    static int a = 0;
    static volatile boolean isInError = false;
    static int count = 0;

    public static void main(String[] args) {
        while (!isInError) {
            new Thread(() -&gt; {
                a = 1;
            }).start();

            new Thread(() -&gt; {
                if (a != 1)
                    isInError = true;
            }).start();

            a = 0;
            count++;
        }

        System.out.println(&quot;Error occurred in &quot; + count);
    }
}
</code></pre><p>结果如下：</p>
<pre><code>Error occurred in 6
</code></pre><p>这段代码通过不断地开启两个线程来向同一个共享变量进行赋值和读取，当出现错误时退出循环，这里采用<strong>volatile</strong>关键字来保证<strong>isInError</strong>的可见性，由程序结果来看是第六次出现了错误，这里第几次出现错误不是一个固定的值。出现错误的原因很简单：在第一个线程中对<strong>a</strong>的更新还没来得及写入主内存当中去边切换到第二个线程，第二个线程从主内存中读取的是还没有更新的值。</p>
<h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><p>重排序是指为了提高程序运行的性能，充分利用并行，来对指令进行重新排序，主要分为编译器优化重排序和指令级并行重排序。关于重排序的更多理解，参见：<a href="http://blog.hesey.net/2011/07/reordering.html" target="_blank" rel="external">理解重排序</a></p>
<h2 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h2><p>数据依赖性分为三种情况：</p>
<ul>
<li>写后读，对一个变量写之后再进行读取。</li>
<li>读后写，对一个变量读取之后再进行写入。</li>
<li>写后写，对一个变量写之后再进行写入。</li>
</ul>
<p>以上三种情况若两个指令发生了重排序，则产生的结果与预期不一致，称以上三个指令对两指令之间存在数据依赖性，存在数据依赖性的两个指令不会发生重排序。</p>
<h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><p><strong>as-if-serial</strong>的含义是指，对于一个单线程而言，无论怎么重排序，其结果与顺序执行的结果一致。为了遵循这个原则，在单线程环境中，如果两个指令指令之间存在数据依赖性，那么这两个指令便不会发生重排序。</p>
<h2 id="对多线程的影响"><a href="#对多线程的影响" class="headerlink" title="对多线程的影响"></a>对多线程的影响</h2><p>假设有以下程序：</p>
<pre><code>public class RecorderExample {
    private boolean flag = false;
    private int i = 0;

    public void write() {
        i = 1;       //1
        flag = true; //2
    }

    public void read() {
        if (flag) {
            int a = i * i; 
        }
    }

    public static void main(String[] args) {
        RecorderExample re = new RecorderExample();
        new Thread(re::write).start();
        new Thread(re::read).start();
    }
}
</code></pre><p>在第一个线程里面，1、2指令由于没有数据依赖，所以可以进行重排序，若两个进行了重排序，<strong>flag</strong>设置成true之后，切换到第二个线程进行条件判断，判断完成后对a进行赋值，此时变量<strong>i</strong>并没有进行设置，所以会发生异常的结果，也就是说，<strong>重排序会破坏多线程的语义</strong>。</p>
<h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>它指的是一组用来实现对内存操作的顺序限制的处理器指令，会根据需求禁止特定类型的重排序。先假定这样一个事实：内存数据被推送到缓冲区，就会有消息协议来保证缓存和内存的数据一致性，这种尽快保证数据可见性的技术称为内存屏障。</p>
<p>内存屏障有三种类型：</p>
<ul>
<li>Store屏障：在该屏障之前的Store指令都会被执行，即写操作都会刷新到主内存当中去。</li>
<li>Load屏障，在该屏障之后的load指令在该屏障之后执行，保证了处理器缓存加载成功后进行读操作。</li>
<li>Full Barrier:即结合了上述两种屏障功能的屏障。</li>
</ul>
<p>一个比较典型的例子是Java当中的<strong>volatile</strong>关键字，对<strong>volatile</strong>变量写指令的后面会加上store屏障，对<strong>volatile</strong>变量读命令的前面会加上load屏障。</p>
<p>关于内存屏障的更多内容，参见<a href="http://www.infoq.com/cn/articles/memory_barriers_jvm_concurrency" target="_blank" rel="external">内存屏障与JVM并发</a></p>
<h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h1><p>如果一个操作的结果对另一个操作是可见的，那么这两个操作必须遵循<strong>happens-before</strong>关系。在这里两个操作可以在同一个线程里面，也可以在不同的线程里面，常见的规则如下：</p>
<ul>
<li>单个线程中的操作，happens-before于其后续操作。</li>
</ul>
<p>这句话很好理解，假定单个线程中的两条指令不存在数据依赖性，那这两条指令则不满足<strong>happens-before</strong>的先决条件；若存在数据的依赖性，则一条指令必定发生在另一条之前。</p>
<ul>
<li>对一个锁的解锁，happens-before于对这个锁的加锁。</li>
<li>对一个<strong>volatile</strong>写操作happens-before于对这个变量的读操作。</li>
</ul>
<h1 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h1><p>是一个理想化的理论模型，主要有两大特征：</p>
<ul>
<li>单个线程的操作必须按照程序的顺序来执行。</li>
<li>每个线程都只有一个单一的执行序列（不管是否同步），且每个操作必须立刻对所有线程可见。</li>
</ul>
<h2 id="JVM的实现"><a href="#JVM的实现" class="headerlink" title="JVM的实现"></a>JVM的实现</h2><h3 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h3><p>还是刚才的RecorderExample,现在修改如下：</p>
<pre><code>public class RecorderExample {
    private boolean flag = false;
    private int i = 0;

    public synchronized void write() {
        i = 1; //1
        flag = true; //2
    }

    public synchronized void read() {
        if (flag) {
            int a = i * i;
        }
    }

    public static void main(String[] args) {
        RecorderExample re = new RecorderExample();
        new Thread(re::write).start();
        new Thread(re::read).start();
    }
}
</code></pre><p>加上<strong>synchronized</strong>关键字之后，<strong>write</strong> happens-before <strong>read</strong>，但是在第一个线程当中，1和2操作是有可能被重排序的，但是对结果没有任何的影响，可以看成是和顺序一致性模型达到了相同的效果。</p>
<h3 id="非同步执行"><a href="#非同步执行" class="headerlink" title="非同步执行"></a>非同步执行</h3><p>非同步的执行结果无法预知，也没有什么实际意义。JVM对非同步执行只提供一种安全性，即在读一个变量的时候，要么是某个其他线程已经设置好的值，要么是零值，这里无需再做分析。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/02/SQL使用（一）/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/02/SQL使用（一）/" itemprop="url">
                  MySQL使用（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-02T21:37:05+08:00">
                2017-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/02/SQL使用（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/02/SQL使用（一）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>在这里我不想说这些无聊的配置内容（懒），在这里给出两个讲的不错的地址：</p>
<ul>
<li>Mac: <a href="http://www.jianshu.com/p/fd3aae701db9" target="_blank" rel="external">mac安装mysql的两种方法（含配置）</a></li>
<li>Windows: <a href="http://0000-bigtree.github.io/blog/2016/04/06/mysql-on-windows.html" target="_blank" rel="external">在 Windows 下安装 MySQL 5.7.11</a></li>
</ul>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>笔者喜欢用ide来进行开发，并且是JetBrains的忠实拥护者，特此向大家推荐一个JetBrains的SQL ide: <a href="https://www.jetbrains.com/datagrip/" target="_blank" rel="external">DataGrip</a></p>
<p>当然使用终端操作也不是不可以，这里还是要看个人的习惯。</p>
<p>打开DataGrip，这里不像其他ide，没有项目的概念。command + 1打开左边侧栏，command + N，依次选中Data Source, MySQL,配置如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-02%20%E4%B8%8B%E5%8D%8810.00.40.png" alt=""><br>⚠️注意：要先加载MySQL的启动文件才可正常运行</p>
<p>上图中host为localhost，端口默认3306，user和password可以用自带的root，也可以在终端启动MySQL，以root用户登录，新建一个用户，这里不再细谈，笔者直接用root用户进行操作。</p>
<p>打开之后，左侧栏如下图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-02%20%E4%B8%8B%E5%8D%8810.16.00.png" alt=""><br>从上到下依次是：数据库的根容器，数据库，表，表中的各个列。</p>
<p>要在某个数据库中进行操作，可以用两种办法，一种是在根标签（<strong>@localhost</strong>标签）上选中，右键，打开Console File，输入指令：</p>
<pre><code>USE Persons;
</code></pre><p>command + enter运行，即切换到Persons数据库进行工作。或者直接选中<strong>Persons</strong>标签，右键打开Console File，这时的工作环境便自动在<strong>Persons</strong>数据库之下了。</p>
<h2 id="创建、删除表"><a href="#创建、删除表" class="headerlink" title="创建、删除表"></a>创建、删除表</h2><p>表的创建：</p>
<pre><code>CREATE TABLE students (
  id             INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  name           VARCHAR(255),
  age            INT,
  grade          INT,
  class          INT,
  math_scores    FLOAT(3, 1),
  chinese_scores FLOAT(3, 1),
  englih_scores  FLOAT(3, 1),
  average_scores FLOAT(3, 1)
)
  CHARACTER SET = utf8;
</code></pre><p>MySQL的数据类型实在是太多，下面三张图摘自w3cschool:</p>
<p><img src="http://ok34fi9ya.bkt.clouddn.com/text_type.png" alt=""><br><img src="http://ok34fi9ya.bkt.clouddn.com/num_type.png" alt=""><br><img src="http://ok34fi9ya.bkt.clouddn.com/date_type.png" alt=""><br>至于<strong>NOT NULL, AUTO_INCREMENT, PRIMARY KEY</strong>后面再讲。</p>
<p>⚠️注意：上面代码中最后一行的<strong>CHARACTER SET = utf8</strong>是告诉MySQL此表使用utf8进行编码，因为MySQL默认不支持中文字体。</p>
<p>表的删除：</p>
<pre><code>DROP TABLE temp;
</code></pre><h2 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h2><p>此指令用于向表中插入数据，用法如下：</p>
<pre><code>INSERT INTO students (name, age, grade, class, math_scores, chinese_scores, englih_scores, average_scores)
VALUES (&apos;张师睿&apos;, 19, 2, 3, 127, 127, 138, (127 + 127 + 138) / 3.0);
</code></pre><p>注意两个括号里面的键值要一一对应，凡是在声明时标注<strong>NOT NULL</strong>的是必须要填的（PRIMARY KEY除外）。</p>
<h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p>此指令用于更新表中的数据，用法如下：</p>
<pre><code>UPDATE students SET grade = 3 WHERE name = &apos;张师睿&apos;;
</code></pre><p>SET后面是要更新的column和对应的新值，WHERE子句用来指定一个条件。</p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>此指令用于删除表中的行，用法如下：</p>
<pre><code>DELETE FROM students WHERE id = 2;
</code></pre><p>同样的WHERE指明了一个限定的条件，如果没有WHERE子句的话，那么此表中所有的行都将被删去，因此用此指令时不要忘记添加WHERE子句。</p>
<h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p>此指令用于查询表中的数据，用法如下：</p>
<pre><code>SELECT [DISTINCT] 列名称 FROM 表名称 [WHERE子句];
</code></pre><p>⚠️注意：DISTINCT关键字的作用是选出唯一的列值，因为对于某一列，多个行可能具有相同的值。</p>
<p>如：进行如下操作</p>
<pre><code>SELECT * FROM students;
</code></pre><p>结果：</p>
<p><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-02%20%E4%B8%8B%E5%8D%8811.28.46.png" alt=""><br>⚠️注意：SELECT *是取表中所有的列。</p>
<h2 id="ALERT"><a href="#ALERT" class="headerlink" title="ALERT"></a>ALERT</h2><p>此指令用于更改表的性质，例如：增加、删除列，改变列的值类型。用法如下：</p>
<p>增加列：</p>
<pre><code>ALERT TABLE 表名 ADD 列名 值类型;
</code></pre><p>删除列：</p>
<pre><code>ALTER TABLE 表名 DROP COLUMN 列名;
</code></pre><p>改变列的值类型：</p>
<pre><code>ALTER TABLE 表名 MODIFY 列名 值类型;
</code></pre><p>⚠️注意：更改列值类型的指令仅适用于MySQL!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/26/Android自定义字体解决方案/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/26/Android自定义字体解决方案/" itemprop="url">
                  Android自定义字体解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-26T16:04:26+08:00">
                2017-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/26/Android自定义字体解决方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/26/Android自定义字体解决方案/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在安卓开发中我们通常需要自定义字体，下面笔者给出两种解决方案，以供参考。</p>
<h1 id="利用反射"><a href="#利用反射" class="headerlink" title="利用反射"></a>利用反射</h1><p>这种方案通常情况下适用于替换整个app的默认字体，方法是利用反射更改<strong>Typeface</strong>类的静态<strong>DEFAULT</strong>成员，如下所示：</p>
<pre><code>public class MyApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        Typeface typeface = Typeface.createFromAsset(getAssets(), &quot;fonts/CourierNewBold.ttf&quot;);
        try {
            Field field = Typeface.class.getDeclaredField(&quot;MONOSPACE&quot;);
            field.setAccessible(true);
            field.set(null, typeface);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
            Log.e(&quot;Application&quot;, &quot;Error happened!&quot;);
        }
    }
}
</code></pre><p>style文件：</p>
<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;android:Theme.Holo.Light.DarkActionBar&quot;&gt;
    &lt;!-- Customize your theme here. --&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name=&quot;android:typeface&quot;&gt;monospace&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>运行效果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/Screenshot_1488099698.png" alt=""><br>这种方法的局限也很明显，就是在Android 5.0默认主题之上并不能运行，需要更换一个旧的主题，如果主题不是很重要的话，这种方法就比较合适了。</p>
<h1 id="利用DataBinding"><a href="#利用DataBinding" class="headerlink" title="利用DataBinding"></a>利用DataBinding</h1><p>这是笔者认为最快速，最便捷的方法了，用<strong>BindingAdapters</strong>注解标注方法即可在xml文件中指定<strong>Typeface</strong>，方法如下：</p>
<p>MyApplication:</p>
<pre><code>public class MyApplication extends Application {

    public static final Map&lt;String, Typeface&gt; FONTS_MAP = new HashMap&lt;&gt;();

    @Override
    public void onCreate() {
        super.onCreate();

        FONTS_MAP.put(getString(R.string.courier_new_bold),
                Typeface.createFromAsset(getAssets(), &quot;fonts/&quot; +
                        getString(R.string.courier_new_bold)));
        FONTS_MAP.put(getString(R.string.lao_sangam_mn),
                Typeface.createFromAsset(getAssets(), &quot;fonts/&quot; +
                        getString(R.string.lao_sangam_mn)));
        FONTS_MAP.put(getString(R.string.microsoft_sans_serif),
                Typeface.createFromAsset(getAssets(), &quot;fonts/&quot; +
                        getString(R.string.microsoft_sans_serif)));
    }
}
</code></pre><p>FontsUtils:</p>
<pre><code>public class FontsUtils {
    @BindingAdapter({&quot;fonts&quot;})
    public static void setTextViewFonts(TextView tv, String fontName) {
        tv.setTypeface(MyApplication.FONTS_MAP.get(fontName));
    }
}
</code></pre><p>xml:</p>
<pre><code>&lt;layout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
    &lt;data&gt;
        &lt;import type=&quot;com.stephen.customfontdemo.FontsUtils&quot;/&gt;
    &lt;/data&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:id=&quot;@+id/activity_main&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:padding=&quot;16dp&quot;
        android:orientation=&quot;vertical&quot;
        tools:context=&quot;com.stephen.customfontdemo.MainActivity&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;测试字体1&quot;
            app:fonts=&quot;@{@string/courier_new_bold}&quot;/&gt;
        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;测试字体2&quot;
            app:fonts=&quot;@{@string/lao_sangam_mn}&quot;/&gt;
        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;测试字体3&quot;
            app:fonts=&quot;@{@string/microsoft_sans_serif}&quot;/&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre><p>运行效果：<img src="http://ok34fi9ya.bkt.clouddn.com/Screenshot_1488100937.png" alt=""><br>额……可能2和3看不出效果，不过确实已经更改了。</p>
<p>需要注意的是： <strong>Typeface</strong>的加载要放在Application类当中，或者放在另一个线程当中进行，因为它是一个比较耗时的操作，如果大量的<strong>TextView</strong>用到自定义字体会造成卡顿。</p>
<p>这样在需要自定义字体时，只需要在<strong>FONTS_MAP</strong>和strings.xml当中注册，在xml中一行代码即可指定！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/16/Mac-OS-Sierra下编译Android-7-1-1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/16/Mac-OS-Sierra下编译Android-7-1-1/" itemprop="url">
                  Mac OS Sierra下编译Android 7.1.1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-16T19:46:37+08:00">
                2017-02-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/16/Mac-OS-Sierra下编译Android-7-1-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/16/Mac-OS-Sierra下编译Android-7-1-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要编译源码"><a href="#为什么要编译源码" class="headerlink" title="为什么要编译源码"></a>为什么要编译源码</h1><p>安卓进阶的最好方式就是Read the fucking source code!不去研究源码的程序员不是好程序员，呵呵呵……好吧，其实笔者要编译源码的原因是因为想研究DataBinding源码结果发现自带的sdk看不到核心逻辑，而笔者却是一个处女座……</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="配置repo"><a href="#配置repo" class="headerlink" title="配置repo"></a>配置repo</h2><p>repo是google为了方便Android源代码的管理，用一系列Python脚本封装git命令做成的工具，具体的请看：<a href="http://ticktick.blog.51cto.com/823160/1653304" target="_blank" rel="external">Repo的使用</a>  </p>
<p>安装代码两行：</p>
<pre><code>$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo
</code></pre><h2 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a>配置JDK</h2><p>Android 7.1.1需要Java8，到官方下载安装即可：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html" target="_blank" rel="external">传送门</a></p>
<p>Java环境变量配置：</p>
<pre><code>export JAVA_HOME=`/usr/libexec/java_home -v 1.8`
export PATH=$JAVA_HOME/bin:$PATH 
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
</code></pre><h2 id="安装curl"><a href="#安装curl" class="headerlink" title="安装curl"></a>安装curl</h2><p>Mac OS自带的curl不带有openssl，不满足Jack编译的条件，因此需要用brew手动下载并替换默认的curl，命令如下：</p>
<pre><code>$ brew install curl --with-openssl
$ export PATH=$(brew --prefix curl)/bin:$PATH
</code></pre><h2 id="下载配置Mac-OS-sdk"><a href="#下载配置Mac-OS-sdk" class="headerlink" title="下载配置Mac OS sdk"></a>下载配置Mac OS sdk</h2><p>由于Mac OS 10.12sdk弃用了syscall函数，所以我们需要旧版本的sdk：<a href="https://github.com/phracker/MacOSX-SDKs/releases" target="_blank" rel="external">下载地址</a></p>
<p>下载好之后解压（如果下载下来的文件格式是xz文件那就不能用系统默认的解压工具），将解压得到的文件夹放在<strong>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</strong>下，大功告成。</p>
<h2 id="创建大小写敏感的磁盘区域"><a href="#创建大小写敏感的磁盘区域" class="headerlink" title="创建大小写敏感的磁盘区域"></a>创建大小写敏感的磁盘区域</h2><p>由于Mac OS默认不区别大小写，为了防止之后下载的文件冲突，需要新建一块大小写敏感的磁盘区域：</p>
<pre><code>$ hdiutil create -type SPARSE -fs &apos;Case-sensitive Journaled HFS+&apos; -size 85g ~/android.dmg
</code></pre><p>大小尽量设置的大些，笔者的源码下载并且编译之后整个的大小是83g。创建完毕后即可在Finder中双击加载。</p>
<h2 id="下载镜像文件"><a href="#下载镜像文件" class="headerlink" title="下载镜像文件"></a>下载镜像文件</h2><p>由于众所周知的原因，google官方的景象并不能有很好的体验，所以要用<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="external">清华大学的aosp镜像</a>，这里采用其官方推荐的做法，先下载一个每月更新的<a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="external">初始化包</a>（为求速度和稳定性请用迅雷）。</p>
<p>下载完成后，将压缩包剪切到先前已经加载的磁盘区域当中，用终端cd到压缩包所在的目录，运行如下指令：</p>
<pre><code>$ tar xf aosp-latest.tar
$ cd aosp
$ repo sync
</code></pre><p>接下来便会等待一段时间，此时repo正将下载好的分支更新到最新，所以仍需下载。如果出现下载速度过慢，远程连接经常hang up，那就请为git设置代理，笔者采用的是ss代理，所以相应的设置如下：</p>
<pre><code>git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;
git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;
</code></pre><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>下载完后，用终端cd到aosp目录，做的第一件事就是加载封装好的命令集：</p>
<pre><code>$ source build/envsetup.sh
</code></pre><p>接着运行指令lunch，会给出很多选项，对应不同的设备，这里笔者只是想查看一下源码，并没有刷机的需求，所以我就选了aosp_arm-eng。</p>
<p>接下来运行：</p>
<pre><code>$ make -j4
</code></pre><p>注意j4是因为笔者的笔记本是二核心的，如果是4核心就是8，以此类推。</p>
<p>下面就是漫长的等待，大概3，4个小时左右吧。</p>
<h2 id="导入Android-Studio"><a href="#导入Android-Studio" class="headerlink" title="导入Android Studio"></a>导入Android Studio</h2><p>编译完成之后，运行：</p>
<pre><code>$ mmm development/tools/idegen/
$ development/tools/idegen/idegen.sh
</code></pre><p>如果出现找不到指令的错误，请重新加载指令集。</p>
<p>为保证AS是大小写敏感的，在导入AS之前，先编辑<strong>/Applications/Android\ Studio.app/Contents/bin</strong>下的<strong>idea.properties</strong>文件，在其最后加上如下代码：</p>
<pre><code>idea.case.sensitive.fs=true
</code></pre><p>这时候aosp目录之下会出现android.ipr文件，此文件便是AS所需。用AS打开该文件，又是一个漫长的等待过程，大概20分钟左右吧。</p>
<p>导入之后，为了防止我们在观察源码时跳转到不是我们需要的.class文件，还需要做额外的几件事情：</p>
<h3 id="配置JDK和SDK"><a href="#配置JDK和SDK" class="headerlink" title="配置JDK和SDK"></a>配置JDK和SDK</h3><p><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%889.38.12.png" alt=""><br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%889.40.01.png" alt=""></p>
<h3 id="删除jar依赖"><a href="#删除jar依赖" class="headerlink" title="删除jar依赖"></a>删除jar依赖</h3><p>在项目设置(command + ;)中点击Modules，删除所有的jar包依赖，再添加两个文件夹依赖，分别是aosp文件夹下的external和frameworks文件夹。</p>
<h3 id="注释掉android-iml文件的-lt-sourceFloder-gt-标签"><a href="#注释掉android-iml文件的-lt-sourceFloder-gt-标签" class="headerlink" title="注释掉android.iml文件的&lt;sourceFloder&gt;标签"></a>注释掉android.iml文件的&lt;sourceFloder&gt;标签</h3><p>上面两步之后，一般情况下可以愉快的看源码了，可是有时候还会出现跳转错误，这是因为导入的其他的文件夹里面的类与external和frameworks冲突所致，这时候就需要编辑aosp目录下的android.iml文件，将发生冲突的文件夹的位置记录下来，并在iml文件中将&lt;sourceFolder&gt;标签注释掉。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/15/Android-DataBinding（二）：源码解析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/15/Android-DataBinding（二）：源码解析/" itemprop="url">
                  Android DataBinding（二）：源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-15T15:27:19+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/15/Android-DataBinding（二）：源码解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/15/Android-DataBinding（二）：源码解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>看源码有两种方式可供选择，第一种是直接将整个AOSP下载下来，然后自行编译，这种方法的好处看源码不会遇到爆红，整个代码结构一目了然，缺点就是占用空间大，下载时间长，编译坑比较多……第二种方法是直接用sdk目录之下的。在这里笔者采用第一种方法，下载并编译AOSP请见：<a href="http://zsrr.coding.me/2017/02/16/Mac-OS-Sierra%E4%B8%8B%E7%BC%96%E8%AF%91Android-7-1-1/" target="_blank" rel="external">Mac OS Sierra下编译Android 7.1.1</a>。</p>
<p>用Android Studio导入安卓源码之后，在Android视图，java包下会看到这几个包：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%889.24.48.png" alt=""><br>这就是我们要分析的源码了。</p>
<p>如果要采用第二种方法，platform请升到最新，不然可能出现当前platform找不到databinding的源码的问题，具体步骤如下：    </p>
<ul>
<li>随便新建一个Android项目</li>
<li>找到sdk文件夹，依次进入sources，android-xx（最新的），android文件夹，将里面的databinding文件夹复制到刚才新建的安卓项目当中。</li>
<li>更改databinding文件夹中所有java文件的包名。</li>
</ul>
<p>另外，如果你是Windows用户，那么请用<a href="https://www.sourceinsight.com/download/" target="_blank" rel="external">Source Insight</a>查看安卓源码。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="DataBindingUtil"><a href="#DataBindingUtil" class="headerlink" title="DataBindingUtil"></a>DataBindingUtil</h2><p>这是数据绑定的入口类，一般用它来创建相应的Binding类，我们由此开始分析。</p>
<p>先看最常见的用法：</p>
<pre><code>public static &lt;T extends ViewDataBinding&gt; T inflate(LayoutInflater inflater, int layoutId, ViewGroup parent, boolean attachToParent);
public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId);
public static &lt;T extends ViewDataBinding&gt; T bind(View root);
</code></pre><p>第一个方法最终调用的是<strong>bind(DataBindingComponent bindingComponent, View root, int layoutId)</strong>方法（如果attachToParent设置为false的话），这个方法的定义为：</p>
<pre><code>static &lt;T extends ViewDataBinding&gt; T bind(DataBindingComponent bindingComponent, View root,
        int layoutId) {
    return (T) sMapper.getDataBinder(bindingComponent, root, layoutId);
}
</code></pre><p>直接交给了sMapper来处理，sMapper是一个类型为DataBinderMapper的静态成员，其getDataBinder方法会根据xml文件生成的ViewDataBinding子类动态改变，这是笔者的getDataBinder源码（源自另一个已经写好的安卓项目）：</p>
<pre><code>public android.databinding.ViewDataBinding getDataBinder(android.databinding.DataBindingComponent bindingComponent, android.view.View view, int layoutId) {
    switch(layoutId) {
            case com.stephen.learning.R.layout.item_view:
                return com.stephen.learning.databinding.ViewHolderBinding.bind(view, bindingComponent);
            case com.stephen.learning.R.layout.activity_data_binding:
                return com.stephen.learning.databinding.ImageViewBinding.bind(view, bindingComponent);
    }
    return null;
}
</code></pre><p>可以看到，DataBinderMapper类将行为委托给了实际产生的ViewDataBinding的子类上，其具体的bind方法的实现，我们稍后再谈。现在再看<strong>setContentView</strong>方法，此方法的实现：</p>
<pre><code>public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId) {
    return setContentView(activity, layoutId, sDefaultComponent);
}

public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId,
        DataBindingComponent bindingComponent) {
    activity.setContentView(layoutId);
    View decorView = activity.getWindow().getDecorView();
    ViewGroup contentView = (ViewGroup) decorView.findViewById(android.R.id.content);
    return bindToAddedViews(bindingComponent, contentView, 0, layoutId);
}
</code></pre><p>bindToAddedViews方法的实现：</p>
<pre><code>private static &lt;T extends ViewDataBinding&gt; T bindToAddedViews(DataBindingComponent component,
        ViewGroup parent, int startChildren, int layoutId) {
    final int endChildren = parent.getChildCount();
    final int childrenAdded = endChildren - startChildren;
    if (childrenAdded == 1) {
        final View childView = parent.getChildAt(endChildren - 1);
        return bind(component, childView, layoutId);
    } else {
        final View[] children = new View[childrenAdded];
        for (int i = 0; i &lt; childrenAdded; i++) {
            children[i] = parent.getChildAt(i + startChildren);
        }
        return bind(component, children, layoutId);
    }
}
</code></pre><p>由上述代码可以发现，setContentView先获得activity中DecorView中的FrameLayout，再将其作为参数传入<strong>bindToAddedViews</strong>方法，此方法先判断parent当中子视图的数目，一般情况下我们activity的xml文件只有一个RelativeLayout或者LinearLayout的根元素，所以子视图一般只有一个，于是又开始调用bind方法，重新回到上面的流程。</p>
<p>下面分析<strong>bind(View root)</strong>方法：</p>
<pre><code>public static &lt;T extends ViewDataBinding&gt; T bind(View root) {
    return bind(root, sDefaultComponent);
}

public static &lt;T extends ViewDataBinding&gt; T bind(View root,
        DataBindingComponent bindingComponent) {
    T binding = getBinding(root);
    if (binding != null) {
        return binding;
    }
    Object tagObj = root.getTag();
    if (!(tagObj instanceof String)) {
        throw new IllegalArgumentException(&quot;View is not a binding layout&quot;);
    } else {
        String tag = (String) tagObj;
        int layoutId = sMapper.getLayoutId(tag);
        if (layoutId == 0) {
            throw new IllegalArgumentException(&quot;View is not a binding layout&quot;);
        }
        return (T) sMapper.getDataBinder(bindingComponent, root, layoutId);
    }
}
</code></pre><p>bind方法先调用<strong>getBinding</strong>方法，<strong>getBinding</strong>方法直接调用了ViewDataBinding的静态<strong>getBinding</strong>方法，这个方法之后分析ViewDataBinding的时候再讲。如果得到的binding是空的，那就创建一个binding并且返回，创建过程是先得到view的tag，这个tag是个String类型。例如ListView的item的xml文件名为item<em> view，里面的根元素是layout标签，那么我们用LayoutInflater类inflate出来的view便有一个String类型的Tag，并且值为：”layout/item</em> view_ 0”。好，找到tag之后，便调用DataBinderMapper类的<strong>getLayoutId</strong>方法，这个方法也是根据xml文件的定义自动生成的，笔者的方法定义如下所示：</p>
<pre><code>int getLayoutId(String tag) {
    if (tag == null) {
        return 0;
    }
    final int code = tag.hashCode();
    switch(code) {
        case -1223782307: {
            if(tag.equals(&quot;layout/item_view_0&quot;)) {
                return com.stephen.learning.R.layout.item_view;
            }
            break;
        }
        case 1514339820: {
            if(tag.equals(&quot;layout/activity_data_binding_0&quot;)) {
                return com.stephen.learning.R.layout.activity_data_binding;
            }
            break;
        }
    }
    return 0;
}
</code></pre><p>嗯……这么拿hashCode做判断再拿tag做判断的写法比较智障啊……<br>拿到layoutId之后，最后调用sMapper的<strong>getDataBinder</strong>，结束。</p>
<h2 id="DataBinderMapper"><a href="#DataBinderMapper" class="headerlink" title="DataBinderMapper"></a>DataBinderMapper</h2><p>这个类随着我们对xml的定义改变而改变，它的职责其实在上文对DataBindingUtil类的分析中已经展现：  </p>
<ul>
<li>作为DataBindingUtil和ViewDataBinding类的中介类</li>
<li>根据tag得到对应的id</li>
</ul>
<p>此外，它的内部还维护一个InnerBrLookUp的静态类，此静态类又维护一个String类型的数组，用来将BR类的id转成对应的String，通常用作打log，这里不再细谈。</p>
<h2 id="BaseObservable"><a href="#BaseObservable" class="headerlink" title="BaseObservable"></a>BaseObservable</h2><p>把此类放在这个位置是为了之后介绍<strong>ViewDataBinding</strong>类。</p>
<p>此类的实现相当简单：</p>
<pre><code>public class BaseObservable implements Observable {
    private transient PropertyChangeRegistry mCallbacks;

    public BaseObservable() {
    }

    @Override
    public synchronized void addOnPropertyChangedCallback(OnPropertyChangedCallback callback) {
        if (mCallbacks == null) {
            mCallbacks = new PropertyChangeRegistry();
        }
        mCallbacks.add(callback);
    }

    @Override
    public synchronized void removeOnPropertyChangedCallback(OnPropertyChangedCallback callback) {
        if (mCallbacks != null) {
            mCallbacks.remove(callback);
        }
    }


    public synchronized void notifyChange() {
        if (mCallbacks != null) {
            mCallbacks.notifyCallbacks(this, 0, null);
        }
    }

    public void notifyPropertyChanged(int fieldId) {
        if (mCallbacks != null) {
            mCallbacks.notifyCallbacks(this, fieldId, null);
        }
    }
}
</code></pre><p>将所有的职责都托付给了内部成员<strong>mCallbacks</strong>身上。</p>
<h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p><strong>BaseObservable</strong>实现了<strong>Observable</strong>接口。先看一下官方文档对此接口的介绍：</p>
<blockquote>
<p>Observable classes provide a way in which data bound UI can be notified of changes.</p>
</blockquote>
<p>简而言之，这个接口就是为了保证UI元素和数据之间的双向绑定，其内部有两个方法：</p>
<pre><code>void addOnPropertyChangedCallback(OnPropertyChangedCallback callback);
void removeOnPropertyChangedCallback(OnPropertyChangedCallback callback);
</code></pre><p>OnPropertyChangedCallback是一个抽象类，其内部只有一个抽象方法:</p>
<pre><code>public abstract void onPropertyChanged(Observable sender, int propertyId);
</code></pre><p>sender就是持有此类的<strong>Observable</strong>类，propertyId是绑定的数据id。当我们用<strong>Bindable</strong>注解标注一个getter时，自动生成的<strong>BR</strong>类会生成此id。</p>
<h3 id="CallbackRegistry"><a href="#CallbackRegistry" class="headerlink" title="CallbackRegistry"></a>CallbackRegistry</h3><p>上面说到<strong>BaseObservable</strong>将职责托付给了<strong>mCallbacks</strong>，而mCallbacks是一个<strong>PropertyChangeRegistry</strong>类，这个类的超类<strong>CallbackRegistry</strong>。此类是管理callback注册，删除，通知的核心类，通过内部<strong>NotifierCallback</strong>类来通知callbacks，此类的代码虽然不多，但是对于我这种算法弱鸡来说看上去的感觉是这样的：<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1487508874434&amp;di=188c6fb1e6fe4e69bf1cab8c82844595&amp;imgtype=0&amp;src=http%3A%2F%2Fwanzao2.b0.upaiyun.com%2Fsystem%2Fpictures%2F31274020%2Foriginal%2F1449639129_500x500.png" alt=""></p>
<p>这个牛逼的算法就不由我这个弱鸡去分析了，它实现了通知Callback的可重入性，就是比方说有两个线程，一个线程执行到通知某个Callback时cpu切到了另一个线程，这个线程把刚才的要通知的Callback给删了，这种情况下切换到之前的线程进行通知是没有任何影响的。如果各位实在想知道这个算法是怎么一回事，请看这篇大牛的文章吧：<a href="https://gold.xitu.io/post/5840e2e3ac502e006cc0ef26" target="_blank" rel="external">回调通知管理器 CallbackRegistry 解析</a></p>
<h3 id="PropertyChangeRegistry"><a href="#PropertyChangeRegistry" class="headerlink" title="PropertyChangeRegistry"></a>PropertyChangeRegistry</h3><p>此类比较简单：</p>
<pre><code>public class PropertyChangeRegistry extends
    CallbackRegistry&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt; {

    private static final CallbackRegistry.NotifierCallback&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt; NOTIFIER_CALLBACK = new CallbackRegistry.NotifierCallback&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt;() {
        @Override
        public void onNotifyCallback(Observable.OnPropertyChangedCallback callback, Observable sender,
                int arg, Void notUsed) {
            callback.onPropertyChanged(sender, arg);
        }
    };

    public PropertyChangeRegistry() {
        super(NOTIFIER_CALLBACK);
    }

    public void notifyChange(Observable observable, int propertyId) {
        notifyCallbacks(observable, propertyId, null);
    }
}
</code></pre><p>Callback类型是<strong>Observable</strong>的内部类<strong>OnPropertyChangedCallback</strong>，Sender类型是<strong>Observable</strong>。NotifierCallback内部的实现仅仅是调用callback的<strong>onPropertyChanged</strong>方法，arg便是<strong>BR</strong>类里面的资源id。<strong>notifyChange</strong>方法是将外层传来的sender以及资源id传给<strong>notifyCallbacks</strong>方法，以此达到了最终调用每一个callback的<strong>onPropertyChanged</strong>的目的。</p>
<h2 id="ViewDataBinding"><a href="#ViewDataBinding" class="headerlink" title="ViewDataBinding"></a>ViewDataBinding</h2><p>系统会根据xml的描述生成此类的子类，我们先看一下自动生成的类的代码，一步一步加以分析。</p>
<p>xml文件：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;data class=&quot;BindingForTest&quot;&gt;
        &lt;variable
            name=&quot;testData&quot;
            type=&quot;com.stephen.learning.databinding.Model&quot;/&gt;
    &lt;/data&gt;

    &lt;LinearLayout
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        tools:context=&quot;com.stephen.learning.databinding.TestActivity&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/main_text_view&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot; /&gt;
        &lt;TextView
            android:id=&quot;@+id/second_text_view&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{testData.testData}&quot;/&gt;
        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{testData.testData}&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre><p>生成的ViewBinding子类：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-19%20%E4%B8%8B%E5%8D%888.36.08.png" alt=""><br>先看构造函数：</p>
<pre><code>public BindingForTest(android.databinding.DataBindingComponent bindingComponent, View root) {
    super(bindingComponent, root, 0);
    final Object[] bindings = mapBindings(bindingComponent, root, 4, sIncludes, sViewsWithIds);
    this.mainTextView = (android.widget.TextView) bindings[3];
    this.mboundView0 = (android.widget.LinearLayout) bindings[0];
    this.mboundView0.setTag(null);
    this.mboundView2 = (android.widget.Button) bindings[2];
    this.mboundView2.setTag(null);
    this.secondTextView = (android.widget.TextView) bindings[1];
    this.secondTextView.setTag(null);
    setRootTag(root);
    // listeners
    invalidateAll();
}
</code></pre><p>先调用超类的静态<strong>mapBindings</strong>方法得到一个<strong>View</strong>数组，再从数组中初始化View成员，View成员有三种：</p>
<ul>
<li>在xml中有id的定义。</li>
<li>在xml中存在数据的绑定。</li>
<li>是根View。</li>
</ul>
<p>满足以上三个条件任意一个便会生成相应的类成员，下面是笔者的类里面的类成员：</p>
<pre><code>//存在id，不存在数据绑定
public final android.widget.TextView mainTextView;
//根View
private final android.widget.LinearLayout mboundView0;
//存在数据绑定，不存在id
private final android.widget.Button mboundView2;
//既存在数据绑定，也存在id
public final android.widget.TextView secondTextView;
</code></pre><p>再来看一下类的静态初始化：</p>
<pre><code>static {
    sIncludes = null;
    sViewsWithIds = new android.util.SparseIntArray();
    sViewsWithIds.put(R.id.main_text_view, 3);
}
</code></pre><p><strong>sIncludes</strong>只有在xml中存在<strong>&lt;include&gt;</strong>标签且存在数据绑定的时候才不为空，在这里笔者暂时没有用到使用数据绑定的<strong>&lt;include&gt;</strong>的需求（觉得也不可能有），而且源码的实现相对简单，这里不太值得分析，有兴趣自己去看。<strong>sViewsWithIds</strong>是一个<strong>SparseIntArray</strong>，这个成员的作用是存放不存在数据绑定但存在id定义的View成员。键是id，值是对应在上面所提在View数组中的索引值。</p>
<p>下面来看<strong>mapBindings</strong>方法：</p>
<pre><code>protected static Object[] mapBindings(DataBindingComponent bindingComponent, View root,
        int numBindings, IncludedLayouts includes, SparseIntArray viewsWithIds) {
    Object[] bindings = new Object[numBindings];
    mapBindings(bindingComponent, root, bindings, includes, viewsWithIds, true);
    return bindings;
}

private static void mapBindings(DataBindingComponent bindingComponent, View view,
        Object[] bindings, IncludedLayouts includes, SparseIntArray viewsWithIds,
        boolean isRoot) {
    final int indexInIncludes;
    final ViewDataBinding existingBinding = getBinding(view);
    //已经绑定过，返回
    if (existingBinding != null) {
        return;
    }

    Object objTag = view.getTag();
    final String tag = (objTag instanceof String) ? (String) objTag : null;
    boolean isBound = false;

    //如果是根View
    if (isRoot &amp;&amp; tag != null &amp;&amp; tag.startsWith(&quot;layout&quot;)) {
        final int underscoreIndex = tag.lastIndexOf(&apos;_&apos;);
        if (underscoreIndex &gt; 0 &amp;&amp; isNumeric(tag, underscoreIndex + 1)) {
            final int index = parseTagInt(tag, underscoreIndex + 1);
            if (bindings[index] == null) {
                bindings[index] = view;
            }
            indexInIncludes = includes == null ? -1 : index;
            isBound = true;
        } else {
            indexInIncludes = -1;
        }
     //如果不是根View
    } else if (tag != null &amp;&amp; tag.startsWith(BINDING_TAG_PREFIX)) {
        int tagIndex = parseTagInt(tag, BINDING_NUMBER_START);
        if (bindings[tagIndex] == null) {
            bindings[tagIndex] = view;
        }
        isBound = true;
        indexInIncludes = includes == null ? -1 : tagIndex;
    } else {
        // Not a bound view
        indexInIncludes = -1;
    }
    //处理存在id但是不存在数据绑定的view成员
    if (!isBound) {
        final int id = view.getId();
        if (id &gt; 0) {
            int index;
            if (viewsWithIds != null &amp;&amp; (index = viewsWithIds.get(id, -1)) &gt;= 0 &amp;&amp;
                    bindings[index] == null) {
                bindings[index] = view;
            }
        }
    }

    if (view instanceof  ViewGroup) {
        final ViewGroup viewGroup = (ViewGroup) view;
        final int count = viewGroup.getChildCount();
        int minInclude = 0;
        for (int i = 0; i &lt; count; i++) {
            final View child = viewGroup.getChildAt(i);
            boolean isInclude = false;
            if (indexInIncludes &gt;= 0 &amp;&amp; child.getTag() instanceof String) {
               ...
            }
            //对每一个子View进行递归处理
            if (!isInclude) {
                mapBindings(bindingComponent, child, bindings, includes, viewsWithIds, false);
            }
        }
    }
}
</code></pre><p>此方法的思想相对简单，先判断是否绑定过，如果已经绑定过，则返回。接下来分成三种情况：</p>
<ul>
<li>根视图。</li>
<li>存在数据绑定的视图。</li>
<li>不存在数据绑定，但是在xml中有id定义。</li>
</ul>
<p>最后如果传入的是一个ViewGroup，则对它的子视图进行递归处理。下面我们来看几个细节：</p>
<p><strong>视图数组索引的判断</strong>  </p>
<p>上文中我们说过用<strong>&lt;layout&gt;</strong>做标记的xml文件在用<strong>LayoutInflater</strong>类inflate出来的根View会有一个<strong>tag</strong>，这个<strong>tag</strong>是一个<strong>String</strong>类型，且设置的规则如下：</p>
<ul>
<li>根视图设置为<strong>layout/[xml文件名]_[在View数组中的索引]</strong></li>
<li>不是根视图，但是存在数据的绑定，则设置为<strong>binding_[在View数组中的索引]</strong></li>
</ul>
<p>根据tag获得数组索引的代码如下：</p>
<pre><code>private static int parseTagInt(String str, int startIndex) {
    final int end = str.length();
    int val = 0;
    for (int i = startIndex; i &lt; end; i++) {
        val *= 10;
        char c = str.charAt(i);
        val += (c - &apos;0&apos;);
    }
    return val;
}
</code></pre><p>这样得出的数组索引便是最后一个”_”后面的数字值。</p>
<p>还有一种情况是不存在数据绑定，但是存在id定义的view成员。上面提到过如果存在这种情况，<strong>ViewDataBinding</strong>在静态初始化的时候会将对应的id和数组索引值放在一个<strong>SparseIntArray</strong>当中，这时候处理过程是这样的：</p>
<pre><code>if (!isBound) {
    final int id = view.getId();
    if (id &gt; 0) {
        int index;
        if (viewsWithIds != null &amp;&amp; (index = viewsWithIds.get(id, -1)) &gt;= 0 &amp;&amp;
                bindings[index] == null) {
            bindings[index] = view;
        }
    }
</code></pre><p>好，现在继续往下看<strong>invalidateAll</strong>方法：</p>
<pre><code>public void invalidateAll() {
    synchronized(this) {
            mDirtyFlags = 0x2L;
    }
    requestRebind();
}
</code></pre><p><strong>requestRebind</strong>:</p>
<pre><code>protected void requestRebind() {
    synchronized (this) {
        if (mPendingRebind) {
            return;
        }
        mPendingRebind = true;
    }
    if (USE_CHOREOGRAPHER) {
        mChoreographer.postFrameCallback(mFrameCallback);
    } else {
        mUIThreadHandler.post(mRebindRunnable);
    }

}
</code></pre><p>其中<strong>USE_CHOREOGRAPHER</strong>是判断当前的SDK是不是16以上版本来决定是否能用<strong>Choreographer</strong>，如果能则直接设置一个<strong>FrameCallback</strong>，不能则在主线程运行一个<strong>Runnable</strong>，我们来看<strong>mFrameCallback</strong>的定义：</p>
<pre><code>mFrameCallback = new Choreographer.FrameCallback() {
            @Override
            public void doFrame(long frameTimeNanos) {
                mRebindRunnable.run();
            }
        };
</code></pre><p><strong>mRebindRunnable</strong>:</p>
<pre><code>private final Runnable mRebindRunnable = new Runnable() {
    @Override
    public void run() {
        synchronized (this) {
            mPendingRebind = false;
        }
        if (VERSION.SDK_INT &gt;= VERSION_CODES.KITKAT) {
            // Nested so that we don&apos;t get a lint warning in IntelliJ
            if (!mRoot.isAttachedToWindow()) {
                // Don&apos;t execute the pending bindings until the View
                // is attached again.
                mRoot.removeOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);
                mRoot.addOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);
                return;
            }
        }
        executePendingBindings();
    }
};
</code></pre><p><strong>ROOT_ REATTACHED_LISTENER</strong>是一个<strong>OnAttachStateChangeListener</strong>，其定义如下：</p>
<pre><code>ROOT_REATTACHED_LISTENER = new OnAttachStateChangeListener() {
            @TargetApi(VERSION_CODES.KITKAT)
            @Override
            public void onViewAttachedToWindow(View v) {
                // execute the pending bindings.
                final ViewDataBinding binding = getBinding(v);
                binding.mRebindRunnable.run();
                v.removeOnAttachStateChangeListener(this);
            }

            @Override
            public void onViewDetachedFromWindow(View v) {
            }
        };
</code></pre><p>很简单，当根视图还没有attach到window上的时候，<strong>mRebindRunnable</strong>直接设置一个<strong>OnAttachStateChangeListener</strong>并返回，当attach到window上的时候重新运行<strong>mRebindRunnable</strong>，此时将运行<strong>executePendingBindings</strong>，定义如下：</p>
<pre><code>public void executePendingBindings() {
    if (mIsExecutingPendingBindings) {
        requestRebind();
        return;
    }
    if (!hasPendingBindings()) {
        return;
    }
    mIsExecutingPendingBindings = true;
    mRebindHalted = false;
    if (mRebindCallbacks != null) {
        mRebindCallbacks.notifyCallbacks(this, REBIND, null);

        // The onRebindListeners will change mPendingHalted
        if (mRebindHalted) {
            mRebindCallbacks.notifyCallbacks(this, HALTED, null);
        }
    }
    if (!mRebindHalted) {
        executeBindings();
        if (mRebindCallbacks != null) {
            mRebindCallbacks.notifyCallbacks(this, REBOUND, null);
        }
    }
    mIsExecutingPendingBindings = false;
}
</code></pre><p>其中<strong>hasPendingBindings</strong>方法是一个抽象方法，一般情况下子类通过其<strong>mDirtyFlags</strong>判断是否有未处理的绑定情况，返回相应的布尔值：</p>
<pre><code>public boolean hasPendingBindings() {
    synchronized(this) {
        if (mDirtyFlags != 0) {
            return true;
        }
    }
    return false;
}
</code></pre><p>接下来便要通知相应的mRebindCallbacks，我们来看它的定义：</p>
<pre><code>private CallbackRegistry&lt;OnRebindCallback, ViewDataBinding, Void&gt; mRebindCallbacks;

public void addOnRebindCallback(OnRebindCallback listener) {
    if (mRebindCallbacks == null) {
        mRebindCallbacks = new CallbackRegistry&lt;OnRebindCallback, ViewDataBinding, Void&gt;(REBIND_NOTIFIER);
    }
    mRebindCallbacks.add(listener);
}
</code></pre><p>它是一个Callback类型是<strong>OnRebindCallback</strong>，Sender类型是<strong>ViewDataBinding</strong>的<strong>CallbackRegistry</strong>类型，下面来看<strong>OnRebindCallback</strong>的定义，它是一个抽象类，里面有三个方法：</p>
<pre><code>public abstract class OnRebindCallback&lt;T extends ViewDataBinding&gt; {
    public boolean onPreBind(T binding) {
        return true;
    }

    public void onCanceled(T binding) {
    }

    public void onBound(T binding) {
    }
}
</code></pre><p>泛型的参数T就是上面的Sender，第一个方法<strong>onPreBind</strong>的返回值决定着rebind是否会继续进行。接着再来看<strong>REBIND_NOTIFIER</strong>:</p>
<pre><code>private static final CallbackRegistry.NotifierCallback&lt;OnRebindCallback, ViewDataBinding, Void&gt;
    REBIND_NOTIFIER = new NotifierCallback&lt;OnRebindCallback, ViewDataBinding, Void&gt;() {
    @Override
    public void onNotifyCallback(OnRebindCallback callback, ViewDataBinding sender, int mode,
            Void arg2) {
        switch (mode) {
            case REBIND:
                if (!callback.onPreBind(sender)) {
                    sender.mRebindHalted = true;
                }
                break;
            case HALTED:
                callback.onCanceled(sender);
                break;
            case REBOUND:
                callback.onBound(sender);
                break;
        }
    }
};
</code></pre><p>现在再来看<strong>executePendingBindings</strong>方法，先是向<strong>mRebindCallbacks</strong>传入<strong>REBIND</strong>参数，进而调用<strong>OnRebindCallback</strong>的<strong>onPreBind</strong>方法，根据其返回的布尔值来决定<strong>mRebindHalted</strong>的值（是否停止）。接下来判断<strong>mRebindHalted</strong>的值，如果是真值的话，则通过向<strong>mRebindCallbacks</strong>传入<strong>HALTED</strong>参数进而调用<strong>OnRebindCallback</strong>的<strong>onCanceled</strong>方法；如果是假值，则先调用<strong>executeBindings</strong>方法，此方法是抽象方法，再通过向<strong>mRebindCallbacks</strong>传入<strong>REBOUND</strong>参数，进而调用<strong>OnRebindCallback</strong>的<strong>onRebound</strong>方法。</p>
<p>下面来看<strong>executeBindings</strong>方法的具体实现：</p>
<pre><code>@Override
protected void executeBindings() {
    long dirtyFlags = 0;
    synchronized(this) {
        //读取mDirtyFlags
        dirtyFlags = mDirtyFlags;
        //重置mDirtyFlags
        mDirtyFlags = 0;
    }
    java.lang.String testDataTestData = null;
    //读取testData
    com.stephen.learning.databinding.Model testData = mTestData;

    if ((dirtyFlags &amp; 0x3L) != 0) {



            if (testData != null) {
                // read testData.testData
                testDataTestData = testData.testData;
            }
    }
    // batch finished
    if ((dirtyFlags &amp; 0x3L) != 0) {
        // api target 1

        android.databinding.adapters.TextViewBindingAdapter.setText(this.mboundView2, testDataTestData);
        android.databinding.adapters.TextViewBindingAdapter.setText(this.secondTextView, testDataTestData);
    }
}
</code></pre><p>方法的最后通过<strong>TextViewBindingAdapter</strong>来实际设置<strong>TextView</strong>的值（<strong>Button</strong>继承于<strong>TextView</strong>），除了<strong>TextViewBindingAdapter</strong>之外，官方还提供了四十多种Adapter用来使数据绑定更加便捷，在这里我就不一一分析了，只说一下大体的形式。一般来说一个Adapter由两部分组成：</p>
<ul>
<li>顶部<strong>BindingMethods</strong>注解，用此注解来说明当发生数据绑定时调用哪个类的哪个方法。</li>
<li>一系列用<strong>BindingAdapter</strong>注释的静态方法，用来供<strong>ViewDataBinding</strong>的子类调用。</li>
</ul>
<p>值得注意的是，xml中的数据绑定并不都是通过Adapter来实现的，下面举一个例子：</p>
<p>将xml文件更改成：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;

    ...

    &lt;LinearLayout
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        tools:context=&quot;com.stephen.learning.databinding.TestActivity&quot;
        android:orientation=&quot;vertical&quot;&gt;

        ...

        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{testData.testData}&quot;
            android:onClick=&quot;@{(v) -&gt; testData.onButtonClick()}&quot;/&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre><p>这个时候rebuild project，<strong>BindingForTest</strong>类变成了这样：</p>
<pre><code>public class BindingForTest extends android.databinding.ViewDataBinding implements android.databinding.generated.callback.OnClickListener.Listener {

    ...

    public BindingForTest(android.databinding.DataBindingComponent bindingComponent, View root) {
        ...
        // listeners
        mCallback1 = new android.databinding.generated.callback.OnClickListener(this, 1);
        invalidateAll();
    }

    @Override
    protected void executeBindings() {
        ...
        if ((dirtyFlags &amp; 0x2L) != 0) {
            // api target 1

            this.mboundView2.setOnClickListener(mCallback1);
        }
    }
    // Listener Stub Implementations
    // callback impls
    public final void _internalCallbackOnClick(int sourceId , android.view.View callbackArg_0) {
        // localize variables for thread safety
        // testData != null
        boolean testDataObjectnull = false;
        // testData
        com.stephen.learning.databinding.Model testData = mTestData;



        testDataObjectnull = (testData) != (null);
        if (testDataObjectnull) {


            testData.onButtonClick();
        }
    }
}
</code></pre><p>在构造函数中初始化了databinding包中的<strong>OnClickListener</strong>，并且实现了其中的<strong>Listener</strong>接口，<strong>OnClickListener</strong>类的定义如下：</p>
<pre><code>public final class OnClickListener implements android.view.View.OnClickListener {
    final Listener mListener;
    final int mSourceId;
    public OnClickListener(Listener listener, int sourceId) {
        mListener = listener;
        mSourceId = sourceId;
    }
    @Override
    public void onClick(android.view.View callbackArg_0) {
        mListener._internalCallbackOnClick(mSourceId , callbackArg_0);
    }
    public interface Listener {
        void _internalCallbackOnClick(int sourceId , android.view.View callbackArg_0);
    }
}
</code></pre><p>它实现了<strong>View</strong>当中的<strong>OnClickListener</strong>接口，其<strong>onClick</strong>方法则调用<strong>mListener</strong>当中的<strong>_internalCallbackOnClick</strong>方法（这个命名怎么这么像native方法）。<strong>BindingForTest</strong>的对此方法的定义如下：</p>
<pre><code>public final void _internalCallbackOnClick(int sourceId , android.view.View callbackArg_0) {
        // localize variables for thread safety
        // testData != null
        boolean testDataObjectnull = false;
        // testData
        com.stephen.learning.databinding.Model testData = mTestData;
        testDataObjectnull = (testData) != (null);
        if (testDataObjectnull) {
            testData.onButtonClick();
        }
    }
</code></pre><p>这边开始调用testData的<strong>onButtonClick</strong>，与xml中的定义对应起来了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/14/Android-DataBinding（一）：基本使用/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/14/Android-DataBinding（一）：基本使用/" itemprop="url">
                  Android DataBinding（一）：基本使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-14T21:42:57+08:00">
                2017-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/14/Android-DataBinding（一）：基本使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/14/Android-DataBinding（一）：基本使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MVVM设计模式"><a href="#MVVM设计模式" class="headerlink" title="MVVM设计模式"></a>MVVM设计模式</h2><p>这是一种由MVP发展而来，起源于WPF开发的一种架构模式。全称为Model-View-ViewModel，其中ViewModel便是MVP对应的Presenter。其最大的特征是ViewModel实现了View和Model的双向绑定，只需要为每一个View定制一个Model，在xml中去引用Model类，强大的IDE便会自动生成ViewModel类。强大，简单，可测试，低耦合。  </p>
<h2 id="DataBinding的使用"><a href="#DataBinding的使用" class="headerlink" title="DataBinding的使用"></a>DataBinding的使用</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>首先，在gradle中开启dataBinding选项：</p>
<pre><code>android {
    ...
    dataBinding {
        enabled true
    }
}
</code></pre><h3 id="基本数据绑定"><a href="#基本数据绑定" class="headerlink" title="基本数据绑定"></a>基本数据绑定</h3><p><strong>简单数据绑定</strong><br>先定义一个简单的Model类User：</p>
<pre><code>public class User {
    private final String name;
    private final String age;

    public User(String name, String age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
           return name;
    }

    public String getAge() {
        return age;
    }
}
</code></pre><p>界面xml文件：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

&lt;data&gt;
    &lt;import type=&quot;java.lang.String&quot;/&gt;
    &lt;variable
        name=&quot;user&quot;
        type=&quot;com.stephen.learning.databinding.User&quot; /&gt;
&lt;/data&gt;

&lt;RelativeLayout
    android:id=&quot;@+id/activity_data_binding&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/name_text_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;@{user.name}&quot;/&gt;
    &lt;TextView
        android:id=&quot;@+id/age_text_view&quot;
        android:layout_below=&quot;@id/name_text_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;16dp&quot;
        android:text=&quot;@{String.valueOf(user.age)}&quot;/&gt;
&lt;/RelativeLayout&gt;
&lt;/layout&gt;
</code></pre><ul>
<li><strong>&lt;layout&gt;</strong>标签：使用数据绑定时的根标签。</li>
<li><strong>&lt;data&gt;</strong>标签：数据标签，这里用来定义绑定的变量及其类型。如果需要一个类中的常量活着静态方法，可以导入类型。</li>
<li><strong>&lt;import&gt;</strong>标签：导入类型。</li>
<li><strong>&lt;variable&gt;</strong>标签：定义变量。</li>
<li><strong>android:text=”@{user.name}”</strong>：将数据绑定到view，注意引用user的name，运行时便会调用user.getName()方法，注意命名保持一致。 </li>
</ul>
<p>其中<strong>@{}</strong>会有更加丰富的语法，后文再讲。</p>
<p>Activity调用：</p>
<pre><code>public class DataBindingActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityDataBindingBinding binding = DataBindingUtil.setContentView(this, 
                R.layout.activity_data_binding);
        binding.setUser(new User(&quot;Stephen&quot;, 19));
    }
}
</code></pre><p>注意此时IDE生成的binding类默认是根据xml文件来命名的，笔者的xml文件时activity_data_binding，那么生成的类名便是ActivityDataBindingBinding，当然如果嫌命名太丑的话可以在<strong>data</strong>标签当中修改:</p>
<pre><code>&lt;data class=&quot;BindingForActivity&quot;&gt;
    &lt;import type=&quot;java.lang.String&quot;/&gt;
    &lt;variable
        name=&quot;user&quot;
        type=&quot;com.stephen.learning.databinding.User&quot; /&gt;
&lt;/data&gt;
</code></pre><p>对应生成的类名便是BindingForActivity。<br>注意生成Binding类的方法：</p>
<pre><code>DataBindingUtil.setContentView(this, R.layout.activity_data_binding);
</code></pre><p>这是在Activity当中的一般用法，如果是要绑定ListView, RecyclerView的ItemView的话，可以这么调用：  </p>
<pre><code>ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false);
</code></pre><p>最后一步便是通过生成的binding类设置在xml文件中定义的变量了，在variable中定义的name时user，那么函数的名字便是setUser，注意命名。  </p>
<p><strong>Observable数据绑定</strong><br>上面的简单数据绑定存在的问题是：当绑定之后数据发生变化时，对应的View不会更改，也就是说，没有真正的实现双向绑定。如果要实现双向绑定，就得将Model类继承BaseObservable类，并且<em>assigning a Bindable annotation to the getter and notifying in the setter.</em> 此时User类改写为：  </p>
<pre><code>public class User extends BaseObservable {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Bindable
    public String getName() {
        return name;
    }

    @Bindable
    public int getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
        notifyPropertyChanged(BR.name);
    }

    public void setAge(int age) {
        this.age = age;
        notifyPropertyChanged(BR.age);
    }
}
</code></pre><p>注意，如果出现BR类找不到，BR.后面的属性找不到，<strong>那就删除所有import有关数据绑定的类的语句，并在xml中删除（加块状注释）data标签，并clean project！</strong>  </p>
<p>Activity:</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    user = new User(&quot;Stephen&quot;, 19);
    BindingForActivity bindingForActivity = DataBindingUtil.setContentView(this, R.layout.activity_data_binding);
    bindingForActivity.setUser(user);

    findViewById(R.id.change_button).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            user.setAge(20);
            user.setName(&quot;Stephanie&quot;);
        }
    });
}
</code></pre><h3 id="处理交互事件"><a href="#处理交互事件" class="headerlink" title="处理交互事件"></a>处理交互事件</h3><p>数据绑定同样适合View的交互事件的处理，某个动作要处理的逻辑也可以放在引用的类当中，方法如下：  </p>
<p>xml文件：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

&lt;data&gt;
    ...
    &lt;variable
        name=&quot;handler&quot;
        type=&quot;com.stephen.learning.databinding.DataBindingActivity&quot;
&lt;/data&gt;

&lt;RelativeLayout
    android:id=&quot;@+id/activity_data_binding&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    ...
    &lt;Button
        android:id=&quot;@+id/change_button&quot;
        android:layout_below=&quot;@id/age_text_view&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;16dp&quot;
        android:onClick=&quot;@{(view) -&gt; handler.onButtonClick(view)}&quot;
&lt;/RelativeLayout&gt;
&lt;/layout&gt;
</code></pre><p>Activity:  </p>
<pre><code>public class DataBindingActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        bindingForActivity.setHandler(this);
    }

    public void onButtonClick(View v) {
        Log.e(&quot;DataBinding&quot;, String.valueOf(v.getId()));
        Toast.makeText(this, &quot;onClick!&quot;, Toast.LENGTH_SHORT).show();
    }
}
</code></pre><p>android:onClick后面是一个lambda表达式，参数是一个view，便是其自身，后面是点击之后将要做的事，这里调用了Activity中定义好的函数。  </p>
<p>除了onClick之外，还有onLongClick，onSearchClick(SearchView)等等，用法相同，这里不再细谈。</p>
<h3 id="神奇的花括号"><a href="#神奇的花括号" class="headerlink" title="神奇的花括号"></a>神奇的花括号</h3><p>xml中的{}里面支持各种各样的操作，支持的操作符有这些（来自官方文档）：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-15%20%E4%B8%8A%E5%8D%8812.54.14.png" alt=""><br>用法很多，比如根据model选择view相应的状态：</p>
<pre><code>android:visibility=&quot;@{age &lt; 13 ? View.GONE : View.VISIBLE}&quot;
android:padding=&quot;@{large? @dimen/largePadding : @dimen/smallPadding}&quot;
android:background=&quot;@{isError ? @drawable/error : @color/white}&quot;
</code></pre><p>调用相应的函数：</p>
<pre><code>&lt;data&gt;
    &lt;import type=&quot;com.example.MyStringUtils&quot;/&gt;
    &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;
&lt;/data&gt;
…
&lt;TextView
       android:text=&quot;@{MyStringUtils.capitalize(user.lastName)}&quot;
       android:layout_width=&quot;wrap_content&quot;
       android:layout_height=&quot;wrap_content&quot;/&gt;  
</code></pre><p> 获取数组中的特定元素：</p>
<pre><code> &lt;data&gt;
    &lt;import type=&quot;android.util.SparseArray&quot;/&gt;
    &lt;import type=&quot;java.util.Map&quot;/&gt;
    &lt;import type=&quot;java.util.List&quot;/&gt;
    &lt;variable name=&quot;list&quot; type=&quot;List&amp;lt;String&amp;gt;&quot;/&gt;
    &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&amp;lt;String&amp;gt;&quot;/&gt;
    &lt;variable name=&quot;map&quot; type=&quot;Map&amp;lt;String, String&amp;gt;&quot;/&gt;
    &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;
    &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;
&lt;/data&gt;
…
android:text=&quot;@{list[index]}&quot;
…
android:text=&quot;@{sparse[index]}&quot;
…
android:text=&quot;@{map[key]}&quot;
</code></pre><h3 id="动态变量的绑定"><a href="#动态变量的绑定" class="headerlink" title="动态变量的绑定"></a>动态变量的绑定</h3><p>有很多时候我们并不能提前知道所要的数据是什么，比如RecyclerView的adapter中的数据有可能是经过网络请求得来的，这里展示一下用法：<br>item_view.xml:</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
&lt;data class=&quot;ViewHolderBinding&quot;&gt;
    &lt;variable
        name=&quot;dataStr&quot;
        type=&quot;String&quot;/&gt;
&lt;/data&gt;

&lt;LinearLayout
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;
    &lt;TextView
        android:id=&quot;@+id/test_text_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;@{dataStr}&quot;/&gt;
&lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre><p>RecyclerView.Adapter:</p>
<pre><code>public class Adapter extends RecyclerView.Adapter&lt;Adapter.ViewHolder&gt; {

    private List&lt;String&gt; mData;
    private LayoutInflater inflater;

    public Adapter(List&lt;String&gt; mData, Context context) {
        this.mData = mData;
        inflater = LayoutInflater.from(context);
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        return new ViewHolder(inflater.inflate(R.layout.item_view, parent, false));
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        holder.binding.setDataStr(mData.get(position));
    }

    @Override
    public int getItemCount() {
        return mData.size();
    }

    static class ViewHolder extends RecyclerView.ViewHolder {
        ViewHolderBinding binding;

        public ViewHolder(View itemView) {
           super(itemView);
            binding = DataBindingUtil.bind(itemView);
        }
    }
}
</code></pre><p>非常简单，不再细谈。</p>
<h3 id="自定义Setter"><a href="#自定义Setter" class="headerlink" title="自定义Setter"></a>自定义Setter</h3><p>有时候可以让我们的xml变得更加灵活，例如想要在xml里面设置一张图片的imageUrl就可以显示图片，实现的方式便是自定义Setter，实现过程如下：<br>xml文件：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;

&lt;data class=&quot;ImageViewBinding&quot;&gt;
    &lt;import type=&quot;com.stephen.learning.databinding.DataBindingActivity&quot;/&gt;
&lt;/data&gt;

&lt;RelativeLayout
    android:id=&quot;@+id/activity_data_binding&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;&gt;

    &lt;ImageView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:imageUrl=&apos;@{&quot;http://imgsrc.baidu.com/baike/pic/item/7aec54e736d12f2ee289bffe4cc2d5628435689b.jpg&quot;}&apos;/&gt;
&lt;/RelativeLayout&gt;
&lt;/layout&gt;
</code></pre><p>然后在Activity里面定义相应的方法，用BindAdapter标注：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    DataBindingUtil.setContentView(this, R.layout.activity_data_binding);
}

@BindingAdapter({&quot;imageUrl&quot;})
public static void loadImage(ImageView imageView, String imageUrl) {
    Picasso.with(imageView.getContext()).load(imageUrl).into(imageView);
}
</code></pre><p> 要注意的两点一是在xml文件中要import static方法所在的类，第二点是方法要用BindAdaper备注，必须是一个public static方法，参数的顺序第一个必须是对应的View，往后的按照注解的参数来即可。</p>
<p>  <strong>是不是感觉开启了新世界的大门呢？</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/01/iOS-UIView/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/01/iOS-UIView/" itemprop="url">
                  iOS UIView
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-01T20:37:56+08:00">
                2017-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/01/iOS-UIView/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/01/iOS-UIView/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="UIView简介"><a href="#UIView简介" class="headerlink" title="UIView简介"></a>UIView简介</h2><p>官方文档：  </p>
<blockquote>
<p>The UIView class defines a rectangular area on the screen and the interfaces for managing the content in that area.  </p>
</blockquote>
<p>说白了就是一块展现内容还能处理交互的矩形区域，比如一个按钮，一个输入框，重要性不再多说。  </p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p><strong>设置外观</strong><br>这个没什么好说的，常见的有backgroundColor(背景色)，isHidden(是否隐藏)，alpha(透明度)等等。一个比较重要的属性是layer，这个稍后再谈。  </p>
<p><strong>frame, bounds</strong><br>先贴上一篇讲的非常好的博客：<br><a href="http://www.jianshu.com/p/964313cfbdaa" target="_blank" rel="external">frame和bounds的区别</a><br>通俗的讲，frame是针对superview来说的，bounds是针对subview来说的，下面来写一个小程序验证一下有什么作用:<br>代码如下：  </p>
<pre><code>private var subView: UIView?
private var subViewsSubView: UIView?

override func viewDidLoad() {
    super.viewDidLoad()
    setUp()
}

private func setUp() {
    setUpControllButtons()
    setUpSubviews()
} 
    private func setUp() {
    setUpControllButtons()
    setUpSubviews()
}

private func setUpSubviews() {
    subView = UIView(frame: CGRect(x: 40.0, y: 40.0, width: 200, height: 300))
    subViewsSubView = UIView(frame: CGRect(x: 20.0, y: 20.0, width: 50, height: 50))
    subViewsSubView?.backgroundColor = UIColor.yellow
    subView?.backgroundColor = UIColor.blue
    view.addSubview(subView!)
    subView?.addSubview(subViewsSubView!)
}

private func setUpControllButtons() {
    let cb1 = UIButton(frame: CGRect(x: 50.0, y: 500.0, width: 100, height: 100))
    let cb2 = UIButton(frame: CGRect(x: 250.0, y: 500.0, width: 100, height: 100))

    ......

    cb1.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(ViewController.onCb1Click)))
    cb2.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(ViewController.onCb2Click)))

    view.addSubview(cb1)
    view.addSubview(cb2)
}

func onCb1Click() {
    if let subView = self.subView {
        subView.frame = CGRect(x: subView.frame.minX, y: subView.frame.minY, width: subView.frame.width + 10, height: subView.frame.height + 10)
    }
}

func onCb2Click() {
    if let subView = self.subView {
        subView.bounds = CGRect(x: subView.bounds.minX + 10, y: subView.bounds.minY + 10, width: subView.bounds.width, height: subView.bounds.height)
    }
}
</code></pre><p>程序很简单，先是创建一个subView，设置其在父view(即Controller的RootView)的坐标(40.0, 40.0)，宽200，高300。再往subView里面添加子视图subViewsSubView，其相对于subView的坐标为(20.0, 20.0)。两个控制的按钮，一个title为frame，点击的效果是将subView的frame宽高都加10，效果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/screen1.gif" alt=""><br>可见frame的宽和高便是控件实际的宽高，而且改变之后，整个矩形区域的左上角的位置不发生改变，宽和高加长，现在修改onCb1Click()方法：</p>
<pre><code>func onCb1Click() {
    if let subView = self.subView {
        subView.frame = CGRect(x: subView.frame.minX + 10, y: subView.frame.minY + 10, width: subView.frame.width, height: subView.frame.height)
    }
}
</code></pre><p>运行效果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/screen2.gif" alt=""><br>可见frame的minX, minY是矩形区域左上角在父view的坐标，当其改变时，它在父view的位置便发生了改变。<br>下面来看bounds按钮点击的效果：<br><img src="http://ok34fi9ya.bkt.clouddn.com/screen3.gif" alt=""><br>当bounds的宽高改变的时候，view的宽高也会改变，不同的是frame的宽高改变的时候不动点在左上角，而bounds的宽高改变的时候不动点在view初始的center。改变onCb2Click()方法如下：</p>
<pre><code>func onCb2Click() {
    if let subView = self.subView {
        subView.bounds = CGRect(x: subView.bounds.minX - 10, y: subView.bounds.minY - 10, width: subView.bounds.width, height: subView.bounds.height)
    }
}
</code></pre><p>运行效果如图：<br><img src="http://ok34fi9ya.bkt.clouddn.com/screen4.gif" alt=""><br>这里应该这么想，初始的时候bounds的minX, minY都是0(坐标原点)，现在将其都剪去10，那么左上角变成了(-10, -10)，坐标原点向右下角移动，子view的位置是根据坐标原点的位置确定的，所以子view也跟着右下角移动了。</p>
<p><strong>处理交互事件</strong><br>UIView继承于UIResponder，若想自定义的view按照自己的逻辑处理交互事件的话，需要重写四个方法：  </p>
<pre><code>func touchesBegan(Set&lt;UITouch&gt;, with: UIEvent?)
func touchesMoved(Set&lt;UITouch&gt;, with: UIEvent?)
func touchesEnded(Set&lt;UITouch&gt;, with: UIEvent?)
func touchesCancelled(Set&lt;UITouch&gt;, with: UIEvent?)
</code></pre><p>这四个具体怎么用请看官方文档（我就是懒）<br>还有一种简单一点的办法，是在view初始化的时候给它注册GestureRecogniser，这时候target是自己就可以了。  </p>
<p><strong>layer属性</strong><br>这是个比较重要的属性，可以控制view的外观，像圆角，阴影，渐变背景色都可以通过它来设置（搞不懂为什么view可以直接设置背景色向外暴露backgroundColor属性，不优雅），不过我认为它并不如安卓那样通过xml来控制简单方便。它是一个CALayer类，几个常用的属性：  </p>
<pre><code>var cornerRadius: CGFloat { get set } //设置圆角
var borderWidth: CGFloat { get set } //边框的宽度
var borderColor: CGColor? { get set } //边框的颜色
var backgroundColor: CGColor? { get set } //背景色
</code></pre><p>此外，它还有一系列的子类，例如CAGradientLayer(设置渐变色)，CATextLayer, CAShapeLayer。下面画一个拥有渐变色背景的Button吧！ 代码如下：  </p>
<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    setUp()
}

private func setUp() {
    let button = UIButton()
    button.frame = CGRect(x: 40.0, y: 40.0, width: 300, height: 200)
    view.addSubview(button)

    let backgroundLayer = CAGradientLayer()
    //设置frame，不要忽略这一步！
    backgroundLayer.frame = button.layer.bounds
    //设置起点和终点, 范围是(0,0) -&gt; (1, 1)
    backgroundLayer.startPoint = CGPoint(x: 0.5, y: 1.0)
    backgroundLayer.endPoint = CGPoint(x: 0.5, y: 0.0)
    //渐变颜色数组
    backgroundLayer.colors = [ UIColor.blue.cgColor, UIColor.red.cgColor ]
    button.layer.addSublayer(backgroundLayer)

    button.layer.cornerRadius = 10
}
</code></pre><p>运行效果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/IMG_2159.PNG" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/01/iOS-ViewController/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/01/iOS-ViewController/" itemprop="url">
                  iOS ViewController
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-01T18:56:10+08:00">
                2017-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/01/iOS-ViewController/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/01/iOS-ViewController/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="UIViewController简介"><a href="#UIViewController简介" class="headerlink" title="UIViewController简介"></a>UIViewController简介</h2><p>官方文档：  </p>
<blockquote>
<p>The UIViewController class provides the infrastructure for managing the views of your iOS apps. A view controller manages a set of views that make up a portion of your app’s user interface. It is responsible for loading and disposing of those views, for managing interactions with those views, and for coordinating responses with any appropriate data objects. View controllers also coordinate their efforts with other controller objects—including other view controllers—and help manage your app’s overall interface.</p>
</blockquote>
<p>用通俗的话来讲，他就是mvc层的c(Controller)，用于View层和Model层的通信，跟Android里面的Activity十分类似，但是比其要灵活不少，貌似还不是很臃肿……</p>
<h2 id="UIViewController生命周期"><a href="#UIViewController生命周期" class="headerlink" title="UIViewController生命周期"></a>UIViewController生命周期</h2><p>主要是这几个部分：  </p>
<ol>
<li>初始化  </li>
<li>如果是通过其他ViewController通过segue导航而来的话，那就根据segue的要求进行初始化  </li>
<li>Outlet设置  </li>
<li>viewDidLoad()</li>
<li>viewWillAppear()  </li>
<li>viewWillLayoutSubviews()  </li>
<li>viewDidLayoutSubviews()  </li>
<li>(6,7步多次调用之后) viewDidAppear()  </li>
<li>(界面离开屏幕)viewWillDisappear()  </li>
<li>(6,7步多次调用)viewDidDisappear()<br>这几个函数的顺序我就不验证了，懒，值得注意的地方在于第二步和第三步的顺序不能颠倒，也就是说，如果在prepare()阶段通过segue的destination来修改目标Controller的Outlet标签成员的话，会崩溃的。  <h2 id="UIViewController的主要职责"><a href="#UIViewController的主要职责" class="headerlink" title="UIViewController的主要职责"></a>UIViewController的主要职责</h2><strong>管理views</strong><br><img src="http://ok34fi9ya.bkt.clouddn.com/ViewController1.png" alt=""><br>UIViewController有一个view属性，便是上图中的RootView，RootView的子视图也可以交给Controller来进行管理，例如Outlet标签标记的视图。  </li>
</ol>
<p><strong>管理子Controller</strong><br><img src="http://ok34fi9ya.bkt.clouddn.com/ViewController2.png" alt=""><br>上图中，SplitViewController管理着两个子Controller，分别是master controller和detail controller，这两个Controller的内容是包裹在父Controller的Container里面的（只能在iPad上面看到全部的内容）。  </p>
<p><strong>处理与用户交互有关的事件</strong><br>Controller可以处理与其管理的views有关的交互事件（触摸，点击，滑动……）实现的方式有两种。一种就是直接从Storyboard按住ctrl拖(既不优雅也没效率)，实现一个标记IAction属性的方法，这种方法通常是用来处理单一的例如Touch up inside的单一事件。另一种实现方式是在管理的view上面添加GestureRecogniser，iOS sdk自己给出的几个recogniser真是太好用了，这里给出一段示例代码：</p>
<pre><code>- (void)viewDidLoad {
     [super viewDidLoad];

     // 创建TabGestureRecogniser
     UITapGestureRecognizer *tapRecognizer = [[UITapGestureRecognizer alloc]
      initWithTarget:self action:@selector(respondToTapGesture:)];

     // 配置TabGestureRecogniser
     tapRecognizer.numberOfTapsRequired = 1;

     // 为view添加GestureRecogniser
     [self.view addGestureRecognizer:tapRecognizer];
}
</code></pre><p>接下来Controller只需要实现selector里面的方法就可以了，个人感觉这真是太优雅了，比安卓提供的丰富多彩很多（安卓好像就几个ClickListener）  </p>
<p><strong>作为管理的view的委托类</strong><br>一个典型示例便是UITableViewController，它的内部持有一个tableView，在这个view加载的时候，便调用其delegate属性的一系列方法，例如获取sections的个数，获取每一个section有多少行，每行的高度是多少等等。而管理它的Controller便实现了UITableView的委托协议，这样我们就可以在Controller内部实现相应的方法，进而管理tableView。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/22/Java-ReferenceQueue实战/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/22/Java-ReferenceQueue实战/" itemprop="url">
                  Java ReferenceQueue实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-22T22:28:09+08:00">
                2017-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/22/Java-ReferenceQueue实战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/22/Java-ReferenceQueue实战/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="浅谈ReferenceQueue"><a href="#浅谈ReferenceQueue" class="headerlink" title="浅谈ReferenceQueue"></a>浅谈ReferenceQueue</h2><p>先看官方文档对这个类的介绍：  </p>
<blockquote>
<p>Reference queues, to which registered reference objects are appended by the<br>garbage collector after the appropriate reachability changes are detected.  </p>
</blockquote>
<p>这个的大体意思是这样的，当一个Reference类所指向的实际对象被回收的时候，这个Referece便会加入到这个队列里面，这个队列提供了三个操作：</p>
<pre><code>public Reference&lt;? extends T&gt; poll();

public Reference&lt;? extends T&gt; remove(long timeout);

public Reference&lt;? extends T&gt; remove();
</code></pre><p>三个都是出队操作，后两个remove是阻塞方法，具体请看官方文档，懒得解释。</p>
<h2 id="ReferenceQueue实战"><a href="#ReferenceQueue实战" class="headerlink" title="ReferenceQueue实战"></a>ReferenceQueue实战</h2><p>笔者将用一个简单粗暴的例子来解释这个类的实际用途。假设在一个公司的内部，有员工(Staff)，有事务(Work)，每一个事务都必须对应一个员工去做。假如这个员工突然有急事请假了，或者工作太累不小心嗝屁了（相应的Staff类实例被回收了），那这个Work类实例可以做一些清理工作，或者通知其他相关类它所对应的Staff已经被回收。那么这个模型就可以完美地应用ReferenceQueue，下面是代码实现：</p>
<p>Work类：</p>
<pre><code>public class Work {
    static class StaffWeakReference extends WeakReference&lt;Staff&gt; {
        Work work;

        public StaffWeakReference(Work work, Staff referent, ReferenceQueue&lt;? super Staff&gt; q) {
            super(referent, q);
            this.work = work;
        }
    }

    StaffWeakReference swReference;

    Work(Staff staff, ReferenceQueue&lt;? super Staff&gt; referenceQueue) {
        swReference = new StaffWeakReference(this, staff, referenceQueue);
    }

    public void cancel() {
        // 可以做一些清理工作，或者通知其他相关类它所对应的Staff已经被回收
    }
}
</code></pre><p>Company类：</p>
<pre><code>public class Company {

    static class CleanUpThread extends Thread {
        ReferenceQueue&lt;?&gt; referenceQueue;
        static final long TIME_OUT = 1000;

        CleanUpThread(ReferenceQueue&lt;?&gt; referenceQueue) {
            this.referenceQueue = referenceQueue;
        }

        @Override
        public void run() {
            while (true) {
                try {
                    Work.StaffWeakReference reference = (Work.StaffWeakReference) referenceQueue.remove(TIME_OUT);
                    if (reference != null) {
                        reference.work.cancel();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        ReferenceQueue&lt;Staff&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
        CleanUpThread cleanUpThread = new CleanUpThread(referenceQueue);
        cleanUpThread.start();
        Staff staff = new Staff();
        Work work = new Work(staff, referenceQueue);
        ...
        ...
    }
}
</code></pre><p>当main开始运行的时候，先开启一个CleanUpThread，这个类的run方法内部则是不断的从传入的ReferenceQueue当中读取所指向Staff对象已经被回收的引用，如果某个Staff已经被回收，那它在对应的Work里面对应的弱引用便会读取出来，这时候就可以调用读出的弱引用对应的Staff已经被回收的Work的cancel方法了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/20/Picasso源码分析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/20/Picasso源码分析/" itemprop="url">
                  Picasso源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-20T19:03:32+08:00">
                2017-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/20/Picasso源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/20/Picasso源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Picasso简介"><a href="#Picasso简介" class="headerlink" title="Picasso简介"></a>Picasso简介</h2><p>Picasso是大名鼎鼎的Square公司推出的安卓图片下载，缓存的第三方库。上手简单，功能强大。在此本文就不介绍它具体是怎么使用的了，给出几个已经讲的很好的博文地址即可：  </p>
<p>Github地址： <a href="http://square.github.io/picasso/" target="_blank" rel="external">http://square.github.io/picasso/</a><br>Picasso使用详解： <a href="http://www.jianshu.com/p/ae8e6ed18e23" target="_blank" rel="external">http://www.jianshu.com/p/ae8e6ed18e23</a>  </p>
<p>Github上的源码中的示例代码是个不错的学习资源哦！</p>
<h2 id="Picasso工作原理"><a href="#Picasso工作原理" class="headerlink" title="Picasso工作原理"></a>Picasso工作原理</h2><p>工作原理如图所示，图中所标记的类下文会一一进行剖析。（笔者的图确实画的不怎么样，见谅）  </p>
<p><img src="http://ok34fi9ya.bkt.clouddn.com/picasso_structure.png" alt="Picasso Structure"> </p>
<p><strong>注：</strong> 图中没有列出像LruCache, OkHttpDownloader等涉及到大量技术细节的类，没有什么值得讨论的，感兴趣的可以自行看源码。</p>
<p><strong>Picasso</strong>类<br>提供给用户使用的顶层类，通过一个依附在主线程（mainThread)的Handler与Dispatcher中的DispatcherThread的Handler交互，其主要类成员和方法为：  </p>
<pre><code>Map&lt;Object, Action&gt; targetToAction; //Picasso管理Action的工具
Map&lt;ImageView, DeferredRequestCreator&gt; targetToRequestCreator; //管理ImageView
Handler HANDLER = new Handler(Looper.getMainLooper()) { ... } //用于通知Action图片加载成功（或者失败），以及重新提交Action(resumeAction)
Dispatcher dispatcher; //用于处理提交（submit)和取消（cancel)操作

...

Picasso.with(Context); //单例模式提供默认的Picasso类
picasso.load(Uri); //向外提供一个RequestCreator
picasso.enqueueAndSubmit(Action); //提交Action给Dispatcher处理
picasso.resumeAction(Action); //重新提交Action给Dispatcher
picasso.complete(BitmapHunter); //从中获取Action，通知主线程图片加载失败或者成功
picasso.deliverAction(Action); //通知主线程图片加载成功（action.complete)或者失败(action.error)
picasso.cancelExistingRequest(Object); //通过Tag从targetToAction中获取到Action, 并通知dispatcher取消此action， 如果Target是ImageView的话还会从targetToRequestCreator中得到DeferredRequestCreator并通知起取消。
</code></pre><p><strong>Dispatcher类</strong><br>dispatcher，顾名思义，掌管“事件”的奋发，Picasso通过它来取消或者提交Action，BitmapHunter通过它来与Picasso当中的HANDLER进行通信。其内部有一个DispatcherThread和相应的DispatcherHandler，在此线程内处理各种事件。其主要的类成员和方法为： </p>
<pre><code>Map&lt;String, BitmapHunter&gt; hunterMap; // String是key类型，从Action.getKey()获取
Map&lt;Object, Action&gt; failedAction; // 失败的Action
Map&lt;Object, Action&gt; pausedAction; //处在暂停状态的Action
Handler handler; //即DispatcherThread的Handler
Handler mainThreadHandler; //即Picasso维持的主线程的Handler

...

dispatchSubmit(Action); //提交Action
dispatchCancel(Action); //取消Action
dispatchPauseTag(Object); //根据Tag暂停相应的Action
dispatchResumeTag(Object); //根据相应的Tag重新开始相应的Action
dispatchComplete(BitmapHunter); //BitmapHunter成功抓取图片回调
dispatchFailed(BitmapHunter); //BitmapHunter抓取图片失败回调
</code></pre><p><strong>Action类</strong><br>在笔者看来，这个类代表着从开始请求到请求成功或者失败的“动作”，在这整个流程里面，包括一开始使用的Picasso, 还有所构造出来的Request, 所使用的存储策略(memoryPolicy)、网络策略(networkPolicy),失败时的默认图片，以及标志这个动作的Tag都包含在里面。代表成功或者失败则是两个抽象方法：</p>
<pre><code>abstract void complete(Bitmap result, Picasso.LoadedFrom from);

abstract void error(Exception e);
</code></pre><p>这两个方法由它的子类具体来实现，典型的<a href="https://zh.wikipedia.org/wiki/策略模式" target="_blank" rel="external">策略模式</a>，其主要类成员如下所示：</p>
<pre><code>Picasso picasso;
Request request;
WeakReference&lt;T&gt; target;
int memoryPolicy;
int networkPolicy;
int errorResId;
Drawable errorDrawable;
String key;     //一个key对应一个相应的BitmapHunter
Object tag;        //标志此Action
</code></pre><p><strong>BitmapHunter类</strong><br>这个嘛，顾名思义（英文好是多么重要），就是用来抓图的，它是一个Runnable，并且通过key和一个（或者一些）Action关联起来。当Dispatcher调用perform(Action)这个方法的时候，会通过Action的key找到相应的BitmapHunter， 并且通过从Picasso传来的ExcutorService来运行这个Hunter，抓取成功或者失败后则会通知其内部持有的Dispatcher。主要的成员及方法如下：</p>
<pre><code>Dispatcher dispatcher;
String key;
Action action; //当前处理的Action
List&lt;Action&gt; actions; //key相同的actions.
Future&lt;?&gt; future; //提交到ExcutorService后对应的Future，可以用来取消请求

...

hunt(); //抓取图片
forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats, Action action); //静态方法构造Hunter.
attach(Action); //将其加入到actions当中
detach(Action); //与上述方法对应
cancel(); //取消此请求
</code></pre><p>hunt()方法源码为：</p>
<pre><code>Bitmap hunt() throws IOException {
    Bitmap bitmap = null;

    //是否能从缓存读取
    if (shouldReadFromMemoryCache(memoryPolicy)) {
        bitmap = cache.get(key);
        if (bitmap != null) {
            stats.dispatchCacheHit();
            loadedFrom = MEMORY;
            ...
            ...
            return bitmap;
        }
    }

    data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;
    //通过requetHandler来处理请求
    RequestHandler.Result result = requestHandler.load(data, networkPolicy);
    if (result != null) {
        loadedFrom = result.getLoadedFrom();
        exifOrientation = result.getExifOrientation();
        bitmap = result.getBitmap();

        // If there was no Bitmap then we need to decode it from the stream.
        if (bitmap == null) {
            InputStream is = result.getStream();
            try {
                bitmap = decodeStream(is, data);
            } finally {
                Utils.closeQuietly(is);
            }
        }
    }

    if (bitmap != null) {
       ...
       ...
       ... //对其进行相应的转换操作
    }

    return bitmap;
}
</code></pre><p><strong>Request类</strong><br>此类包含着请求的数据，包括请求的Uri，对图片所要进行的转换（Transformation)，是否进行centerCrop，centerInside，是否进行旋转，旋转的角度……太简单不必细说。</p>
<p><strong>RequestCreator类</strong><br>此类由Picasso.load(Uri)方法暴露给用户，提供各种方法，如resize(), centerCrop(), centerInside(), fit()来记录用户对图片的需求，并且更新内部所持有的Request，还提供了三个很重要的方法， fetch(), get(), into(Target)，这三个方法最后都是根据实际情况了构造了不同的Action，并且同Picasso通信，通知Picasso将Action发送出去（即通知Dispatcher来处理它）。</p>
<p><strong>RequestHandler类</strong><br>注意这个可不是安卓线程通信所使用的Handler，这是用来处理请求的，其内部类RequestHandler.Result表示处理的结果，其结构为：</p>
<pre><code>Picasso.LoadedFrom loadedFrom;
Bitmap bitmap;
InputStream stream;
int exifOrientation;

//构造函数
Result(
            @Nullable Bitmap bitmap,
            @Nullable InputStream stream,
            @NonNull Picasso.LoadedFrom loadedFrom,
            int exifOrientation) {
        //两个至少一个不为空
        if ((bitmap != null) == (stream != null)) {
            throw new AssertionError();
        }
        this.bitmap = bitmap;
        this.stream = stream;
        this.loadedFrom = checkNotNull(loadedFrom, &quot;loadedFrom == null&quot;);
        this.exifOrientation = exifOrientation;
    }
</code></pre><p>可以通过这个类来实现自己加载图片的逻辑，需要实现两个抽象方法：</p>
<pre><code>abstract boolean canHandleRequest(Request data);

abstract Result load(Request request, int networkPolicy)；
</code></pre><p>此外，Picasso库也给我们提供了一系列内置的RequestHandler，如NetworkRequestHandler, MediaStoreRequestHandler, FileRequestHandler,分别用来处理不同类型的请求，这些内置的RequestHandler将默认提供给Picasso类。</p>
<p><strong>Target类</strong><br>这是一个接口，可以看作是一个简单的图片加载的监听器，内部有三个方法：</p>
<pre><code>void onBitmapLoaded(Bitmap bitmap, LoadedFrom from);

void onBitmapFailed(Exception e, Drawable errorDrawable);

void onPrepareLoad(Drawable placeHolderDrawable);
</code></pre><p>一看名字就知道是干什么的，不必多说。需要注意的一点就是ImageView可以看作是一种特殊的Target，但是IamgeView没有实现Target接口，因此Picasso库针对ImageView有特殊的处理。</p>
<p><strong>DeferredRequestHandler</strong><br>这个既和线程通信没有联系，也和之前的RequestHandler没有联系，它实现了<a href="https://developer.android.com/reference/android/view/ViewTreeObserver.OnDrawListener.html" target="_blank" rel="external">ViewTreeObserver.OnPreDrawListener</a>这个接口。这个就是上文所说Picasso库针对ImageView的情况提供的特殊的类。当我们调用RequestCreator.fit()的时候，会触发RequestCreator中的defer标志，最后在调用into(ImageView)的时候会对目标ImageView的<a href="https://developer.android.com/reference/android/view/ViewTreeObserver.html" target="_blank" rel="external">ViewTreeObserver</a>注册一个DeferredRequestCreator，这样便在目标ImageView加入到所属的ViewTree的时候在preDraw过程中对其进行处理，处理的大致逻辑如下所示：</p>
<pre><code>public boolean onPreDraw() {
    ...
    ...
    int width = target.getWidth();
    int height = target.getHeight();

    if (width &lt;= 0 || height &lt;= 0 || target.isLayoutRequested()) {
        return true;
    }

    vto.removeOnPreDrawListener(this);
    this.target.clear();

    this.creator.unfit().resize(width, height).into(target, callback);
    return true;
}
</code></pre><p>最后还是回归到RequestCreator的resize操作，来达到所谓的”fit exactly”的效果。</p>
<h2 id="Picasso工作流程源码分析"><a href="#Picasso工作流程源码分析" class="headerlink" title="Picasso工作流程源码分析"></a>Picasso工作流程源码分析</h2><p>首先，我们从最基本的操作开始，一步一步加以分析。</p>
<pre><code>Picasso.with(Context)
      .load(Uri)
      ....
      .into(Target);
</code></pre><p><strong>注：</strong>第三行的…对应的是RequestCreator的各种“操作符”，由于数量太多，这里不一一列举。  </p>
<p><strong>Picasso.with(context)</strong><br>源码如下：</p>
<pre><code>public static Picasso with(@NonNull Context context) {
    if (context == null) {
        throw new IllegalArgumentException(&quot;context == null&quot;);
    }
    if (singleton == null) {
        synchronized (Picasso.class) {
            if (singleton == null) {
                //默认使用OkHttp3Downloader和LruCache.
                singleton = new Builder(context).build();
            }
        }
    }
    return singleton;
}
</code></pre><p>这个不需要过多的解释，经典的DCL单例模式，其中需要注意的是Builder里面的build()方法：</p>
<pre><code>public Picasso build() {
        Context context = this.context;

        if (downloader == null) {
            downloader = new OkHttp3Downloader(context);
        }
        if (cache == null) {
            cache = new LruCache(context);
        }
        if (service == null) {
            service = new PicassoExecutorService();
        }
        if (transformer == null) {
            transformer = RequestTransformer.IDENTITY;
        }

        Stats stats = new Stats(cache);

        Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);

        return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,
                defaultBitmapConfig, indicatorsEnabled, loggingEnabled);
    }
</code></pre><p>由此可以看出如果采用默认的Picasso类的话，会采用OkHttp3Downloader, LruCache和PicassoExcutorService，这些便是默认配置。</p>
<p><strong>picasso.load(Uri)</strong><br>不论调用的是picasso.load(String)也好，还是picasso.load(File)也好都会调用picasso.load(Uri)方法(picasso.load(int)除外)，只不过是将String和File转成Uri而已，其源码也比较简单，就是构造一个RequestCreator返回而已，不再细谈。</p>
<p><strong>RequestCreator的各种“操作符”</strong><br>由于操作符实在是太多，这里只粘出几个具有代表性的：</p>
<pre><code>public RequestCreator resize(int targetWidth, int targetHeight) {
    data.resize(targetWidth, targetHeight);
    return this;
}

public RequestCreator centerCrop() {
    data.centerCrop(Gravity.CENTER);
    return this;
}

public RequestCreator error(@DrawableRes int errorResId) {
    if (errorResId == 0) {
        throw new IllegalArgumentException(&quot;Error image resource invalid.&quot;);
    }
    if (errorDrawable != null) {
        throw new IllegalStateException(&quot;Error image already set.&quot;);
    }
    this.errorResId = errorResId;
    return this;
}

public RequestCreator fit() {
    deferred = true;
    return this;
}
...
</code></pre><p>可以看到，有些操作是改变的RequestCreator本身具有的一些属性（error(), fit())，还有一些便是将参数传给了data，这个data类型是一个Request.Builder，RequestCreator在这个时候便充当了“中介人”的角色吧。</p>
<p><strong>RequestCreator.into(…)</strong><br>这个方法便是根据参数的类型来构造一个Action并通知Picasso类发送出去。</p>
<pre><code>public void into(@NonNull Target target) {
    ...
    ...

    Request request = createRequest(started);
    String requestKey = createKey(request);

    //先判断能否从缓存当中读取
    if (shouldReadFromMemoryCache(memoryPolicy)) {
        Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);
        if (bitmap != null) {
            picasso.cancelRequest(target);
            target.onBitmapLoaded(bitmap, MEMORY);
            return;
        }
    }

    target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : null);

    //构造Action并发送
    Action action =
            new TargetAction(picasso, target, request, memoryPolicy, networkPolicy, errorDrawable,
                    requestKey, tag, errorResId);
    picasso.enqueueAndSubmit(action);
}
</code></pre><p>当参数为ImageView的时候有特殊情况：</p>
<pre><code>public void into(ImageView target, Callback callback) {
    ...
    ...

    if (deferred) {
        if (data.hasSize()) {
            throw new IllegalStateException(&quot;Fit cannot be used with resize.&quot;);
        }
        int width = target.getWidth();
        int height = target.getHeight();
        if (width == 0 || height == 0 || target.isLayoutRequested()) {
            if (setPlaceholder) {
                setPlaceholder(target, getPlaceholderDrawable());
            }
            picasso.defer(target, new DeferredRequestCreator(this, target, callback));
            return;
        }
        data.resize(width, height);
    }

    ...
    ...

    Action action =
            new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,
                    errorDrawable, requestKey, tag, callback, noFade);

    picasso.enqueueAndSubmit(action);
}
</code></pre><p>如果之前调用过fit方法的时候，deferred标志位就会开启，这个时候就会构造一个DeferredRequestCreator，并注册到目标ImageView的ViewTreeObserver当中，并且将其写入picasso所持有的targetToDeferredRequestCreator当中。</p>
<p><strong>Picasso.enqueueAndSubmit(Action)</strong><br>正如上面看到的，RequestCreator.into(…)到最后一步都是构建对应的Action并调用picasso.enqueueAndSubmit(action)方法，下面就顺着这个方法进行分析：</p>
<pre><code>void enqueueAndSubmit(Action action) {
    Object target = action.getTarget();
    if (target != null &amp;&amp; targetToAction.get(target) != action) {
        // This will also check we are on the main thread.
        cancelExistingRequest(target);
        targetToAction.put(target, action);
    }
    submit(action);
}
</code></pre><p>先判断以传进来的的action的target作为键在targetToAction中得来的的action值是不是当前传进来的action，如果不是，则先取消target的请求，再将target和当前传递的action键值对传到字典当中，最后调用submit方法，submit方法如下：</p>
<pre><code>void submit(Action action) {
    dispatcher.dispatchSubmit(action);
}
</code></pre><p>很简单粗暴地就调用了dispatcher的dispatchSubmit(action)方法来处理此action，下面来分析dispatcher.dispatchSubmit(action)方法。</p>
<p><strong>dispatcher.dispatchSubmit(action)</strong><br>源码如下：</p>
<pre><code>void dispatchSubmit(Action action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));
}
</code></pre><p>一层一层往下看，最终调用的是performSubmit(Action)方法：  </p>
<pre><code>void performSubmit(Action action) {
    performSubmit(action, true);
  }

  void performSubmit(Action action, boolean dismissFailed) {
        if (pausedTags.contains(action.getTag())) {
          pausedActions.put(action.getTarget(), action);
          ...
          ...
          return;
    }

    BitmapHunter hunter = hunterMap.get(action.getKey());
    if (hunter != null) {
          hunter.attach(action);
          return;
    }

    if (service.isShutdown()) {
          ...
          ...
          return;
    }

    hunter = forRequest(action.getPicasso(), this, cache, stats, action);
    hunter.future = service.submit(hunter);
    hunterMap.put(action.getKey(), hunter);
    if (dismissFailed) {
          failedActions.remove(action.getTarget());
    }
    ...
    ...
}
</code></pre><p>逻辑也不是多么的复杂，如果标记Action的Tag在pausedTag当中的话（下面会讲tag对应的操作），便直接返回不做处理。再判断hunterMap中是不是有传入的action的key对应的BitmapHunter，如果有，便调用attach方法并返回。attach方法较简单，更新BitmapHunter当前的action或者将其加入到List<action>当中。下一步判断ExcutorService是不是已经处在关闭的状态，这是为下面一步做准备。如果没有，便构造出一个BitmapHunter，并将这个Hunter（本身便是一个Runnable)加入到service当中，最后更新hunterMap。</action></p>
<p><strong>dispatcher.dispatchComplete(BitmapHunter) dispatcher.dispatchFailed(BitmapHunter)</strong><br>当此Runnable加入到ExcutorService当中后便开始运行，其run方法如下所示：</p>
<pre><code>public void run() {
    try {
        updateThreadName(data);

        ...
        ...

        result = hunt();

        if (result == null) {
            dispatcher.dispatchFailed(this);
        } else {
            dispatcher.dispatchComplete(this);
        }
    } ...
     finally {
        Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);
    }
}
</code></pre><p>每一个catch字句最后都会调用dispatcher.dispatchFailed(BitmapHunter)，逻辑比较简单，这里省去。run()方法内部还是比较直观的，先是更新当前线程的名称，再调用hunt()方法获取到一个Bitmap，如果为空就调用dispatchFailed，不为空就调用dispatchComplete。  </p>
<p>同样，两个dispatch方法也只是通过DispatcherThreadHandler通知DispatcherThread进行相应的操作，最后调用的是performComplete(BitmapHunter)和performError(BitmapHunter)方法，源码如下：</p>
<pre><code>void performComplete(BitmapHunter hunter) {
    //是否应该写入缓存
    if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) {
          cache.set(hunter.getKey(), hunter.getResult());
    }
    hunterMap.remove(hunter.getKey());
    batch(hunter);
  }

  void performError(BitmapHunter hunter, boolean willReplay) {
       hunterMap.remove(hunter.getKey());
    batch(hunter);
   }
</code></pre><p>逻辑比较简单，两者共同的操作是更新hunterMap和调用batch(hunter)，区别就是performComplete方法第一步先判断是否要写入缓存。batch(BitmapHunter)方法源码如下：</p>
<pre><code>private void batch(BitmapHunter hunter) {
    if (hunter.isCancelled()) {
          return;
    }
    batch.add(hunter);
    if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) {
          handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);
    }
  }
</code></pre><p>逻辑也是比较直观的，其中batch是一个List<bitmaphunter>，这个和下面sendEmptyMessageDelayed方法结合在一块用，起到了一定的缓存的作用。这个消息发送出去之后，最终调用的是performBatchComplete()，源码如下：</bitmaphunter></p>
<pre><code>void performBatchComplete() {
    List&lt;BitmapHunter&gt; copy = new ArrayList&lt;&gt;(batch);
    batch.clear();
    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));
  }
</code></pre><p>此方法先将缓存复制一份，再将缓存清空，最后通知主线程开始处理复制好的缓存数据，最终调用的是Picasso当中的complete(BitmapHunter)方法。</p>
<p><strong>Picasso.complete(BitmapHunter)</strong><br>源码如下：</p>
<pre><code>void complete(BitmapHunter hunter) {
    Action single = hunter.getAction();
    List&lt;Action&gt; joined = hunter.getActions();

    boolean hasMultiple = joined != null &amp;&amp; !joined.isEmpty();
    boolean shouldDeliver = single != null || hasMultiple;

    if (!shouldDeliver) {
        return;
    }

    Uri uri = hunter.getData().uri;
    Exception exception = hunter.getException();
    Bitmap result = hunter.getResult();
    LoadedFrom from = hunter.getLoadedFrom();

    if (single != null) {
        deliverAction(result, from, single, exception);
    }

    if (hasMultiple) {
        //noinspection ForLoopReplaceableByForEach
        for (int i = 0, n = joined.size(); i &lt; n; i++) {
            Action join = joined.get(i);
            deliverAction(result, from, join, exception);
        }
    }

    if (listener != null &amp;&amp; exception != null) {
        listener.onImageLoadFailed(this, uri, exception);
    }
}
</code></pre><p>如果这个Hunter只有一个那就调用一次deliverAction(…)，如果获得的joined列表不为空，那就对其中的Action依次调用deliverAction(…)， deliverAction(…)源码如下：</p>
<pre><code>private void deliverAction(Bitmap result, LoadedFrom from, Action action, Exception e) {
    ...
    ...
    if (result != null) {
        ...
        action.complete(result, from);
        ...
    } else {
        action.error(e);
        ...
    }
}
</code></pre><p>不必多说，最后根据result是否为空调用action的complete或者error方法。就拿ImageViewAction来说吧，成功的话，就会将图片加载到对应的ImageView中去（此时ImageView是此Action的Target)，失败则加载errorImage，整个工作流程就此结束。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/lion.jpg"
               alt="Stephen Zhang" />
          <p class="site-author-name" itemprop="name">Stephen Zhang</p>
          <p class="site-description motion-element" itemprop="description">Stephen Zhang's notes.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Zhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zsrcodingme"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
