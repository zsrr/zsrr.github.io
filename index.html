<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Stephen Zhang&apos;s notes.">
<meta property="og:type" content="website">
<meta property="og:title" content="Stephen's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Stephen's blog">
<meta property="og:description" content="Stephen Zhang&apos;s notes.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stephen's blog">
<meta name="twitter:description" content="Stephen Zhang&apos;s notes.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Stephen's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Stephen's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/24/Android-Proguard/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/Android-Proguard/" itemprop="url">
                  Android ProGuard
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-24T11:06:25+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/24/Android-Proguard/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/24/Android-Proguard/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先附上一个github地址： <a href="https://github.com/krschultz/android-proguard-snippets" target="_blank" rel="external">android-proguard-snippets</a>，里面记录了各种库的ProGuard规则。</p>
<h1 id="ProGuard简介"><a href="#ProGuard简介" class="headerlink" title="ProGuard简介"></a>ProGuard简介</h1><p>ProGuard是用来压缩，最优化，混淆，预检验Java代码的工具，能够防止class文件被反编译以及减小最终生成的程序的大小，其工作流程图如下图所示(图片来自官方文档):</p>
<p><img src="https://www.guardsquare.com/files/media/guardsquare2016/Website/ProGuard/ProGuard_build_process.png" alt=""></p>
<p>ProGuard要求制定Library jars，以此来重新组织class文件的依赖关系，Library jars通常是保持不变的。</p>
<p>代码的某些地方不能被混淆，如main方法，这些地方称为入口点(Entry Points)。反射时用到的类、方法、属性名也不能被混淆。</p>
<h1 id="ProGuard的使用"><a href="#ProGuard的使用" class="headerlink" title="ProGuard的使用"></a>ProGuard的使用</h1><p>先附上下载地址：<a href="http://ok34fi9ya.bkt.clouddn.com/proguard5.3.3.zip" target="_blank" rel="external">ProGuard 5.3.3下载地址</a></p>
<p>下载完成之后切换到bin目录，在终端执行：</p>
<pre><code>sh proguard.sh [options]
</code></pre><p>也可以运行proguardgui.sh来开启图形界面。</p>
<h2 id="ProGuard-Options"><a href="#ProGuard-Options" class="headerlink" title="ProGuard Options"></a>ProGuard Options</h2><p>options通常写在一个单独的configuration file里面，并且可以递归地读取配置文件，下面来介绍几个最常见的Options。</p>
<h3 id="Input-Output-Options"><a href="#Input-Output-Options" class="headerlink" title="Input/Output Options"></a>Input/Output Options</h3><h4 id="inlcude-filename"><a href="#inlcude-filename" class="headerlink" title="-inlcude filename"></a>-inlcude <em>filename</em></h4><p>读取配置文件，可以在配置文件中声明表示递归地读取。</p>
<h4 id="basedirectory-directoryname"><a href="#basedirectory-directoryname" class="headerlink" title="-basedirectory directoryname"></a>-basedirectory <em>directoryname</em></h4><p>声明配置文件的相对位置。</p>
<h4 id="injars-class-path"><a href="#injars-class-path" class="headerlink" title="-injars class_path"></a>-injars <em>class_path</em></h4><p>指定需要处理的jar文件。jar中的class文件将被处理，并将处理之后的class文件写到output jars。默认情况下非class文件将只进行复制处理。</p>
<h4 id="outjars-class-path"><a href="#outjars-class-path" class="headerlink" title="-outjars class_path"></a>-outjars <em>class_path</em></h4><p>指定output jars的名字，应该避免output jars重写掉input files。</p>
<h4 id="libraryjars-class-path"><a href="#libraryjars-class-path" class="headerlink" title="-libraryjars class_path"></a>-libraryjars <em>class_path</em></h4><p>指定应用的库文件，这些文件不会再output jars里面出现。被应用中的类继承的class需要被指定，用到的class不用被指定，但是指定它们有助于最优化代码。</p>
<h4 id="skipnonpubliclibraryclasses"><a href="#skipnonpubliclibraryclasses" class="headerlink" title="-skipnonpubliclibraryclasses"></a>-skipnonpubliclibraryclasses</h4><p>用来指定处理Library jars的时候跳过非公有类，以此来节省ProGuard运行时所占的时间和空间，但是不能总是指定这个选项，例如当某些类库中的非公有类被公有类继承的时候。</p>
<h4 id="dontskipnonpubliclibraryclasses"><a href="#dontskipnonpubliclibraryclasses" class="headerlink" title="-dontskipnonpubliclibraryclasses"></a>-dontskipnonpubliclibraryclasses</h4><p>上一个选项的反义词，从版本4.5开始这是默认选项。</p>
<h4 id="dontskipnonpubliclibraryclassmembers"><a href="#dontskipnonpubliclibraryclassmembers" class="headerlink" title="-dontskipnonpubliclibraryclassmembers"></a>-dontskipnonpubliclibraryclassmembers</h4><p>指定不要忽略包级私有类的成员（属性和方法）。由于这些类不经常被应用程序所引用，因此忽略它们是ProGuard的默认选项，但是在某些情况下不能忽略，例如应用程序的类与它们处在同一个包中，这时候被引用的包级私有类不能被忽略。</p>
<h4 id="keepdirectories-directory-filter"><a href="#keepdirectories-directory-filter" class="headerlink" title="-keepdirectories [directory_filter]"></a>-keepdirectories [<em>directory_filter</em>]</h4><p>指定需要在Output jars里面保留的文件夹名。如果directory_filter为空，那么所有的文件夹都将被保存。</p>
<h4 id="target-version"><a href="#target-version" class="headerlink" title="-target version"></a>-target <em>version</em></h4><p>指定class文件的级别。</p>
<h4 id="forceprocessing"><a href="#forceprocessing" class="headerlink" title="-forceprocessing"></a>-forceprocessing</h4><p>对class文件进行强制处理，即便输出看起来是过时的。</p>
<h3 id="Keep-Options"><a href="#Keep-Options" class="headerlink" title="Keep Options"></a>Keep Options</h3><h4 id="keep-modifier-…-class-specification"><a href="#keep-modifier-…-class-specification" class="headerlink" title="-keep [,modifier,…] class_specification"></a>-keep [,<em>modifier</em>,…] <em>class_specification</em></h4><p>指定类和类的成员当作入口点，例如一个Java应用程序的入口类以及main方法，对于类库来说，所有的public元素都应该当作入口点。此指令会保护类和其成员不被混淆和删除。</p>
<h4 id="keepclassmembers-modifier-…-class-specification"><a href="#keepclassmembers-modifier-…-class-specification" class="headerlink" title="-keepclassmembers [,modifier,…] class_specification"></a>-keepclassmembers [,<em>modifier</em>,…] <em>class_specification</em></h4><p>指定保护类的成员，例如，实现了Serializable接口的用于序列化的类成员应该被保护。此指令会保证类成员不会被混淆和删除。</p>
<h4 id="keepclasseswithmembers-modifier-…-class-specification"><a href="#keepclasseswithmembers-modifier-…-class-specification" class="headerlink" title="-keepclasseswithmembers [,modifier,…] class_specification"></a>-keepclasseswithmembers [,<em>modifier</em>,…] <em>class_specification</em></h4><p>指定保护拥有指定类成员的类及指定类成员。如在一个Java程序中，要保护拥有main方法的类，可以用这个指令，而不用一一列举。</p>
<h4 id="keepnames-class-specification"><a href="#keepnames-class-specification" class="headerlink" title="-keepnames class_specification"></a>-keepnames <em>class_specification</em></h4><p>指定类的名称不会被混淆，前提是在压缩代码的时候此类仍然存在，仅在混淆阶段起作用。</p>
<h4 id="keepclassmembernames-class-specification"><a href="#keepclassmembernames-class-specification" class="headerlink" title="-keepclassmembernames class_specification"></a>-keepclassmembernames <em>class_specification</em></h4><p>指定类成员的名字不会被混淆。仅在混淆阶段起作用，前提是Shrink过后类成员仍然存在。</p>
<h4 id="keepclasseswithmembernames-class-specification"><a href="#keepclasseswithmembernames-class-specification" class="headerlink" title="-keepclasseswithmembernames class_specification"></a>-keepclasseswithmembernames <em>class_specification</em></h4><p>指定拥有指定类成员的类及指定类成员的名字不会被混淆，如要保护一个拥有本地方法的类名和其本地方法的名字不被混淆。仅在混淆阶段起作用。</p>
<p>关于以上几个 -keep选项，详见下表：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%884.21.32.png" alt="来自官方文档"></p>
<h3 id="Shirinking-Options（非重点）"><a href="#Shirinking-Options（非重点）" class="headerlink" title="Shirinking Options（非重点）"></a>Shirinking Options（非重点）</h3><h4 id="dontshrink"><a href="#dontshrink" class="headerlink" title="-dontshrink"></a>-dontshrink</h4><p>指定不压缩代码，默认情况下，除了被上述多样的 -keep选项保护起来的类和类成员，以及它们直接或者间接依赖的类不被压缩外，其余的都不会被保留。</p>
<h3 id="Optimization-options（非重点）"><a href="#Optimization-options（非重点）" class="headerlink" title="Optimization options（非重点）"></a>Optimization options（非重点）</h3><h4 id="dontoptimize"><a href="#dontoptimize" class="headerlink" title="-dontoptimize"></a>-dontoptimize</h4><p>指定不进行最优化，默认开启。</p>
<h4 id="optimizationpasses-n"><a href="#optimizationpasses-n" class="headerlink" title="-optimizationpasses n"></a>-optimizationpasses n</h4><p>指定ProGuard进行对代码进行最优化的次数。</p>
<h4 id="optimizations"><a href="#optimizations" class="headerlink" title="-optimizations"></a>-optimizations</h4><p>指定优化时所采取的算法，属于高级选项，关于optimizations filter，请查看：<a href="https://www.guardsquare.com/en/proguard/manual/optimizations" target="_blank" rel="external">optimizations</a></p>
<h4 id="assumenosideeffects-class-specification"><a href="#assumenosideeffects-class-specification" class="headerlink" title="-assumenosideeffects class_specification"></a>-assumenosideeffects <em>class_specification</em></h4><p>指定无关紧要的方法，ProGuard会在优化阶段去除对此方法所有的调用，例如可以去除打log的方法调用，注意此举是危险的，除非我们能够确定一个方法在整个应用程序中是绝对没有用处的，否则不要轻易指定。</p>
<h4 id="mergeinterfacesaggressively"><a href="#mergeinterfacesaggressively" class="headerlink" title="-mergeinterfacesaggressively"></a>-mergeinterfacesaggressively</h4><p>合并接口，能够减少最终输出类的数目，缩小体积。不过在某些Java虚拟机上会带来性能的损失。</p>
<p><strong>注：</strong>Android Studio默认的配置文件最优化是不开启的，因为Android Java虚拟机对于优化和预检验的代码不友好。</p>
<h3 id="Obfuscation-options"><a href="#Obfuscation-options" class="headerlink" title="Obfuscation options"></a>Obfuscation options</h3><h4 id="dontobfuscate"><a href="#dontobfuscate" class="headerlink" title="-dontobfuscate"></a>-dontobfuscate</h4><p>指定关闭混淆，混淆默认是开启的，除了被 -keep选项保护起来的类和类成员，其余的类和类成员都被赋予了随机的名字。</p>
<h4 id="applymapping-filename"><a href="#applymapping-filename" class="headerlink" title="-applymapping filename"></a>-applymapping <em>filename</em></h4><p>重新利用指定file中的映射集，在此文件中列出的类和类成员被赋予映射集文件中指定的名字，没有在其中列举的但出现在输入中的类和类成员被赋予新的名字。</p>
<h4 id="overloadaggressively"><a href="#overloadaggressively" class="headerlink" title="-overloadaggressively"></a>-overloadaggressively</h4><p>允许重载，很多类属性和方法会得到相同的名称，只要方法的参数名不同或者返回值不同（遵守Java的约定），这会使得输出的体积更小，不过很多虚拟机并不支持此选项，小心使用。</p>
<h4 id="useuniqueclassmembernames"><a href="#useuniqueclassmembernames" class="headerlink" title="-useuniqueclassmembernames"></a>-useuniqueclassmembernames</h4><p>为名字相同的类成员指派相同的混淆名</p>
<h4 id="dontusemixedcaseclassnames"><a href="#dontusemixedcaseclassnames" class="headerlink" title="-dontusemixedcaseclassnames"></a>-dontusemixedcaseclassnames</h4><p>指定不用大小写混合的混淆名，这在大小写不敏感的操作系统（如Mac OS）上尤其有用。</p>
<h4 id="keeppackagenames-package-filter"><a href="#keeppackagenames-package-filter" class="headerlink" title="-keeppackagenames [package_filter]"></a>-keeppackagenames [<em>package_filter</em>]</h4><p>指定的包名不会被混淆。</p>
<h4 id="keepattributes-attribute-filter"><a href="#keepattributes-attribute-filter" class="headerlink" title="-keepattributes [attribute_filter]"></a>-keepattributes [<em>attribute_filter</em>]</h4><p>指定不会被混淆的属性，具体支持的属性，请查看：<a href="https://www.guardsquare.com/en/proguard/manual/attributes" target="_blank" rel="external">属性列表</a> </p>
<p>例如，为了便于调试，需要保存异常信息，则需要以下选项：</p>
<pre><code>-keepattributes SourceFile,LineNumberTable
</code></pre><h4 id="keepparameternames"><a href="#keepparameternames" class="headerlink" title="-keepparameternames"></a>-keepparameternames</h4><p>保证方法的参数名不被混淆。</p>
<h3 id="Preverification-options"><a href="#Preverification-options" class="headerlink" title="Preverification options"></a>Preverification options</h3><p>Android Java虚拟机对其支持的不友好，默认关闭，在此不再列举该选项。</p>
<p><strong>以上内容大部分为常用的，ProGuard的用法实在是太多了，没有必要在这里一一列举，混淆和保存选项是重要内容，其余请查看官方文档。</strong></p>
<h3 id="class-specification"><a href="#class-specification" class="headerlink" title="class_specification"></a>class_specification</h3><p>用来指定类和其成员的语句，用在 -keep选项和 -assumenosideeffects选项当中，模板设计的风格非常像Java，还有很多通配符，具体的格式如下：</p>
<pre><code>[@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname
[extends|implements [@annotationtype] classname]
[{
    [@annotationtype] [[!]public|private|protected|static|volatile|transient ...] &lt;fields&gt; |
                                                                      (fieldtype fieldname);
    [@annotationtype] [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...] &lt;methods&gt; |
                                                                                           &lt;init&gt;(argumenttype,...) |
                                                                                           classname(argumenttype,...) |
                                                                                           (returntype methodname(argumenttype,...));
    [@annotationtype] [[!]public|private|protected|static ... ] *;
    ...
}]
</code></pre><p>方括号[]代表内部的内容是可选的。</p>
<p>…代表前面几个是可以进行多个选择的。</p>
<p>classame必须写全称，例如java.lang.String。对于内部类来讲，类名前面和外部类后面要有”$”分隔。例如：<code>java.lang.Thread$State</code>。classname里面可以有如下的通配符：</p>
<ul>
<li>?：匹配任意一个字符。</li>
<li>*：匹配任何不带.的语句，不能够匹配带有.号的包名。</li>
<li>**：可以匹配带有.的语句，专门用来匹配带有.的包名。</li>
</ul>
<p>@annotationtype代表限制被注解类型注释的类，annotationtype和上述classname的规则是一样的。</p>
<p>属性和方法名大部分和Java中是一样的，除了方法中参数列表只包含参数类型不包含参数名称，属性和方法名还可以包含以下通配符：</p>
<ul>
<li>&lt;init&gt; 匹配所有的构造函数。</li>
<li>&lt;fields&gt; 匹配所有的属性。</li>
<li>&lt;methods&gt; 匹配所有的方法。</li>
<li><ul>
<li>匹配所有的方法和属性。</li>
</ul>
</li>
</ul>
<p>类型描述符可以包含以下通配符：</p>
<ul>
<li>% 匹配任何值类型，如boolean, int等等。</li>
<li>？ 匹配引用类型中的单个字符。</li>
<li><ul>
<li>匹配不带.的引用类型。</li>
</ul>
</li>
<li>** 匹配带有包名的引用类型，但不匹配数组类型。</li>
<li><em>*</em> 匹配任何类型，包括值类型和引用类型，以及数组类型。</li>
<li>… 匹配任意数量的任意类型。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/14/Java-ORM解决方案/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/14/Java-ORM解决方案/" itemprop="url">
                  Java ORM解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-14T15:31:14+08:00">
                2017-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/14/Java-ORM解决方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/14/Java-ORM解决方案/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>此篇部分内容，图片来自<a href="http://ok34fi9ya.bkt.clouddn.com/jpa_tutorial.pdf" target="_blank" rel="external">JPA Tutorial</a></p>
<h1 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h1><p>对象关系映射(Object Relational Mapping)，用面向对象的语言实现了数据的转换，存储等操作。</p>
<h1 id="Java-ORM解决方案"><a href="#Java-ORM解决方案" class="headerlink" title="Java ORM解决方案"></a>Java ORM解决方案</h1><h2 id="Java-Persistence-Api"><a href="#Java-Persistence-Api" class="headerlink" title="Java Persistence Api"></a>Java Persistence Api</h2><p>Java持久化API（以下简称JPA），是从EJB发展而来的Java ORM框架。</p>
<h3 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h3><p>其主要结构如下图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.11.50.png" alt=""><br>主要组成部分有下面几个：</p>
<ul>
<li><strong>POJO class</strong>此种类定义了像id, name等等基本属性，相当于关系数据库的表。</li>
<li><strong>Service class</strong>此种类实现了与数据库进行操作，包括获取对象，删除对象，更新对象等操作。</li>
<li><strong>JPA Provider</strong>由各大厂商提供的对JPA的具体实现，如Eclipselink, Toplink, Hibernate等等。</li>
<li><strong>Mapping file</strong>用来定义POJO class和关系数据库的映射关系。</li>
</ul>
<p>除了Mapping file，JPA还提供了各种形式的注解来定义POJO class和关系数据库之间的映射关系，主要的几个注解如下：</p>
<ul>
<li><strong>@Entity</strong>用来声明一个将要和关系数据库发生映射的POJO class。</li>
<li><strong>@Table</strong>用来声明此类对应的表名, schema和catalog。</li>
<li><strong>@Basic</strong>通常用来声明属性的加载方式。</li>
<li><strong>@Id</strong>用来声明POJO class对应的表的主键。</li>
<li><strong>@GeneratedValue</strong>用来指定主键的生成策略。</li>
<li><strong>@Column</strong>用来声明属性对应的列。</li>
</ul>
<p>此外，POJO class应该具备Java Bean的标准形式。</p>
<h3 id="用IntelliJ-IDEA建立JPA项目"><a href="#用IntelliJ-IDEA建立JPA项目" class="headerlink" title="用IntelliJ IDEA建立JPA项目"></a>用IntelliJ IDEA建立JPA项目</h3><p>笔者采用的环境是IDEA 2017.1.1，Hibernate 5.2.9，JPA 2.1。注意Hibernate的版本要和JPA的版本对应，不然会出错。</p>
<h4 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h4><p><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.37.05.png" alt=""><br>勾选JavaEE Persistence项目，下面指定JPA的版本为2.1，Provider为Hibernate，建好项目后整个项目的结构如图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.42.46.png" alt=""></p>
<h4 id="加入Hibernate以及数据库驱动依赖"><a href="#加入Hibernate以及数据库驱动依赖" class="headerlink" title="加入Hibernate以及数据库驱动依赖"></a>加入Hibernate以及数据库驱动依赖</h4><p>笔者采用的是h2数据库，将相应的依赖包放在lib目录下，对用的jar依赖包的下载地址：<a href="http://ok34fi9ya.bkt.clouddn.com/jpa-with-hibernate.zip" target="_blank" rel="external">h2以及Hibernate依赖包</a></p>
<p>将jar包放在lib文件夹之后，打开Project Struture，找到项目对应的Module，为其添加dependicies:<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.59.23.png" alt=""></p>
<h4 id="配置persistence-xml文件"><a href="#配置persistence-xml文件" class="headerlink" title="配置persistence.xml文件"></a>配置persistence.xml文件</h4><p>此文件定义了数据源，映射类等基本信息，且一定要在项目类路径下的META-INF文件夹下，笔者采用的是h2数据库，配置如下：</p>
<pre><code>&lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; version=&quot;2.1&quot;&gt;

    &lt;persistence-unit name=&quot;HibernatePersistenceUnit&quot;&gt;
        &lt;!--定义Provider--&gt;
        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
        &lt;properties&gt;
            &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:h2:~/test/test&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;org.h2.Driver&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;sa&quot;/&gt;
            &lt;!--&lt;property name=&quot;hibernate.connection.password&quot; value=&quot;&quot;/&gt;--&gt;
            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot;/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</code></pre><p>注意，笔者采用的是h2嵌入式数据库，因此不用提供用户的密码，还要注意里面的hbm2ddl.auto属性，此属性的值在这里是create，意味着应用程序每次启动都会创建一个新的表格，而上一次启动创建的表格将不复存在，关于此属性更多的内容，请见：<a href="http://blog.csdn.net/kjfcpua/article/details/4272415" target="_blank" rel="external">hibernate.hbm2ddl.auto属性配置</a></p>
<p>至此，项目的基本配置完毕。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>此小节通过小小的例子来阐述JPA的基本使用。</p>
<p>Employee.java:</p>
<pre><code>@Entity
@Table(name = &quot;Employee&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Employee {
    @Id
    private int eid;
    private String ename;
    private double salary;
    private String deg;

    public Employee(String ename, double salary, String deg) {
        this.ename = ename;
        this.salary = salary;
        this.deg = deg;
    }

    public Employee() {

    }

    public int getEid() {
        return eid;
    }

    public void setEid(int eid) {
        this.eid = eid;
    }

    public String getEname() {
        return ename;
    }

    public void setEname(String ename) {
        this.ename = ename;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public String getDeg() {
        return deg;
    }

    public void setDeg(String deg) {
        this.deg = deg;
    }

    @Override
    public String toString() {
        return &quot;Employee{&quot; +
                &quot;eid=&quot; + eid +
                &quot;, ename=&apos;&quot; + ename + &apos;\&apos;&apos; +
                &quot;, salary=&quot; + salary +
                &quot;, deg=&apos;&quot; + deg + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);

    private static void createAnEmployee(Employee employee) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        manager.persist(employee);
        transaction.commit();
        manager.close();
    }

    private static Employee findEmployee(int eid) {
        EntityManager manager = factory.createEntityManager();
        try {
            return manager.find(Employee.class, eid);
        } finally {
            manager.close();
        }
    }

    private static void deleteEmployee(int eid) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        Employee employee = manager.find(Employee.class, eid);
        manager.remove(employee);
        transaction.commit();
        manager.close();
    }

    private static void updateEmployeeSalary(int eid, double salary) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        Employee employee = manager.find(Employee.class, eid);
        System.out.println(employee);
        employee.setSalary(salary);
        transaction.commit();
        manager.close();
    }


    public static void main(String[] args) {
        Employee employee = new Employee();

        employee.setEid(100);
        employee.setEname(&quot;zsr&quot;);
        employee.setSalary(3000);
        employee.setDeg(&quot;Student&quot;);

        createAnEmployee(employee);
        System.out.println(findEmployee(100));
        updateEmployeeSalary(100, 5000);
        System.out.println(findEmployee(100));
        deleteEmployee(100);
        factory.close();
    }
}
</code></pre><p>结果如下：</p>
<pre><code>Employee{eid=100, ename=&apos;zsr&apos;, salary=3000.0, deg=&apos;Student&apos;}
Employee{eid=100, ename=&apos;zsr&apos;, salary=3000.0, deg=&apos;Student&apos;}
Employee{eid=100, ename=&apos;zsr&apos;, salary=5000.0, deg=&apos;Student&apos;}
</code></pre><p>需要注意的是：如果要手动指定主键，就不要用<strong>@GeneratedValue</strong>去注释主键，否则会出现detached entity passed to persist异常。</p>
<p>以上主要用到的类有下面几个：</p>
<ul>
<li><strong>EntityManagerFactory</strong>  EntityManager的工厂类，与EntityManager是一对多的关系。</li>
<li><strong>EntityManager</strong> 用来执行对象持久化的类，是<strong>Query</strong>类的工厂类。</li>
<li><strong>EntityTransaction</strong> 与EntityManager是一对一的关系，作用在EntityManager上更新表的操作存储在其中，最后用其commit()方法才正式生效。</li>
<li><strong>Persistence</strong> 提供静态方法用来生成EntityManagerFactory对象。</li>
</ul>
<p>关系如下图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%889.35.54.png" alt=""></p>
<h3 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h3><p>JPQL是在SQL语句基础之上建立起来的标准语句，能够执行对表中对象的<strong>SELECT, UPDATE, DELETE</strong>。</p>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>main方法改成如下代码：</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
public static void main(String[] args) {
    Employee employee1 = new Employee(100, &quot;Gopal&quot;, 40000, &quot;Technical Manager&quot;);
    Employee employee2 = new Employee(101, &quot;Manisha&quot;, 35000, &quot;Reader&quot;);
    Employee employee3 = new Employee(102, &quot;Masthanvali&quot;, 37000, &quot;Teacher&quot;);
    Employee employee4 = new Employee(103, &quot;Satish&quot;, 30000, &quot;Student&quot;);
    Employee employee5 = new Employee(104, &quot;Krishna&quot;, 31000, &quot;Tutor&quot;);
    Employee employee6 = new Employee(105, &quot;Kiran&quot;, 32000, &quot;Drinker&quot;);

    createAnEmployee(employee1);
    createAnEmployee(employee2);
    createAnEmployee(employee3);
    createAnEmployee(employee4);
    createAnEmployee(employee5);
    createAnEmployee(employee6);

    EntityManager manager = factory.createEntityManager();

    Query betweenQuery = manager.createQuery(&quot;select e from Employee e where e.salary between 30000 and 35000&quot;);
    List&lt;Employee&gt; salaryQueryEmployees = (List&lt;Employee&gt;) betweenQuery.getResultList();

    for (Employee employee : salaryQueryEmployees) {
        System.out.println(employee);
    }

    System.out.println();

    Query likeQuery = manager.createQuery(&quot;select  e from Employee e where e.ename like &apos;M%&apos;&quot;);
    List&lt;Employee&gt; likeQueryResults = (List&lt;Employee&gt;) likeQuery.getResultList();

    for (Employee employee : likeQueryResults) {
        System.out.println(employee);
    }

    manager.close();
    factory.close();
}
</code></pre><p>运行结果：</p>
<pre><code>Employee{eid=101, ename=&apos;Manisha&apos;, salary=35000.0, deg=&apos;Reader&apos;}
Employee{eid=103, ename=&apos;Satish&apos;, salary=30000.0, deg=&apos;Student&apos;}
Employee{eid=104, ename=&apos;Krishna&apos;, salary=31000.0, deg=&apos;Tutor&apos;}
Employee{eid=105, ename=&apos;Kiran&apos;, salary=32000.0, deg=&apos;Drinker&apos;}

Employee{eid=101, ename=&apos;Manisha&apos;, salary=35000.0, deg=&apos;Reader&apos;}
Employee{eid=102, ename=&apos;Masthanvali&apos;, salary=37000.0, deg=&apos;Teacher&apos;}
</code></pre><p>sql语法实在是繁多，这里不再一一详细列举。</p>
<h4 id="NamedQuery"><a href="#NamedQuery" class="headerlink" title="NamedQuery"></a>NamedQuery</h4><p><strong>@NamedQuery</strong>注解用实现定义好的且不可变的query语句来执行查询操作，这个query语句中含有未知的参数可以在别处指定，用法如下：</p>
<p>Employee.java:</p>
<pre><code>@Entity
@Table(name = &quot;Employee&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
@NamedQuery(query = &quot;select e from Employee e where e.eid = :id&quot;, name = &quot;find employee by id&quot;)
public class Employee {
    ...
}
</code></pre><p>main函数：</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
public static void main(String[] args) {
    ...

    EntityManager manager = factory.createEntityManager();

    Query query = manager.createNamedQuery(&quot;find employee by id&quot;);
    query.setParameter(&quot;id&quot;, 103);

    Employee employee = (Employee) query.getSingleResult();
    System.out.println(employee);

    manager.close();
    factory.close();
}
</code></pre><h3 id="JPA对继承的处理"><a href="#JPA对继承的处理" class="headerlink" title="JPA对继承的处理"></a>JPA对继承的处理</h3><p>Java对象之间存在错综复杂的继承关系，而关系数据库没有继承这种概念，JPA对这种情况提供了多种解决方案。</p>
<p>考虑如下的继承关系：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8810.25.29.png" alt=""></p>
<h4 id="单一表策略"><a href="#单一表策略" class="headerlink" title="单一表策略"></a>单一表策略</h4><p>单一表策略是指将不同的对象（存在继承关系）放在一个表当中，代码如下：</p>
<p>Staff.java:</p>
<pre><code>@Entity
@Table(name = &quot;Staff&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = &quot;type&quot;)
public class Staff {
    @Id
    private int sid;
    private String sname;

    public Staff(int sid, String sname) {
        this.sid = sid;
        this.sname = sname;
    }

    public Staff() {

    }

    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }
}
</code></pre><p>TeachingStaff.java:</p>
<pre><code>@Entity
@DiscriminatorValue(value = &quot;TS&quot;)
public class TeachingStaff extends Staff {
    private String qualification;
    private String subjectexpertise;

    public TeachingStaff(int sid, String sname, String qualification, String subjectexpertise) {
        super(sid, sname);
        this.qualification = qualification;
        this.subjectexpertise = subjectexpertise;
    }

    public TeachingStaff() {
        super();
    }

    public String getQualification() {
        return qualification;
    }

    public void setQualification(String qualification) {
        this.qualification = qualification;
    }

    public String getSubjectexpertise() {
        return subjectexpertise;
    }

    public void setSubjectexpertise(String subjectexpertise) {
        this.subjectexpertise = subjectexpertise;
    }
}
</code></pre><p>NonTeachingStaff.java:</p>
<pre><code>@Entity
@DiscriminatorValue(value = &quot;NST&quot;)
public class NonTeachingStaff extends Staff {
    private String areaexpertise;

    public NonTeachingStaff(int sid, String sname, String areaexpertise) {
        super(sid, sname);
        this.areaexpertise = areaexpertise;
    }

    public NonTeachingStaff() {
        super();
    }

    public String getAreaexpertise() {
        return areaexpertise;
    }

    public void setAreaexpertise(String areaexpertise) {
        this.areaexpertise = areaexpertise;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    @SuppressWarnings(&quot;unchecked&quot;)
    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        TeachingStaff ts1 = new TeachingStaff(100, &quot;zsr&quot;, &quot;fine&quot;, &quot;a&quot;);
        TeachingStaff ts2 = new TeachingStaff(101, &quot;zx&quot;, &quot;good&quot;, &quot;a&quot;);

        NonTeachingStaff nts1 = new NonTeachingStaff(102, &quot;zy&quot;, &quot;a&quot;);
        NonTeachingStaff nts2 = new NonTeachingStaff(103, &quot;zu&quot;, &quot;b&quot;);

        manager.persist(ts1);
        manager.persist(ts2);
        manager.persist(nts1);
        manager.persist(nts2);

        transaction.commit();

        manager.close();
        factory.close();
    }
}
</code></pre><p>运行结束后打开h2 console，执行:</p>
<pre><code>SELECT * FROM STAFF;
</code></pre><p>运行结果：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8810.51.27.png" alt=""></p>
<h4 id="合并表策略"><a href="#合并表策略" class="headerlink" title="合并表策略"></a>合并表策略</h4><p>合并表策略（不知道怎么翻译才是对的，原文是Joined Table Strategy）是指将几个对象模型中共有的东西抽出来，在此基础上为子类分别建表，代码如下：</p>
<p>Staff.java:</p>
<pre><code>@Entity
@Table(name = &quot;Staff&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
@Inheritance(strategy = InheritanceType.JOINED)
public class Staff {
    ...
}
</code></pre><p>TeachingStaff.java:</p>
<pre><code>@Entity
@PrimaryKeyJoinColumn(referencedColumnName = &quot;sid&quot;)
public class TeachingStaff extends Staff {
    ...
}
</code></pre><p>NonTeachingStaff的变化与TeachingStaff的相同，不再展示。</p>
<p>main方法不变，执行完毕之后，打开h2 console，运行如下指令：</p>
<pre><code>SELECT * FROM STAFF;
SELECT * FROM TEACHINGSTAFF;
SELECT * FROM NONTEACHINGSTAFF;
</code></pre><p>结果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8811.12.43.png" alt=""></p>
<h4 id="一类一表策略"><a href="#一类一表策略" class="headerlink" title="一类一表策略"></a>一类一表策略</h4><p>顾名思义就是为每一个类都产生一个表，此方法不再做展示。</p>
<h3 id="实体间关系"><a href="#实体间关系" class="headerlink" title="实体间关系"></a>实体间关系</h3><p>除了继承，实体之间也有很多复杂的组合关系，JPA为实体之间的关系提供了四种注解：<strong>@OneToOne @OneToMany @ManyToOne @ManyToMany</strong></p>
<h4 id="ManyToOne"><a href="#ManyToOne" class="headerlink" title="ManyToOne"></a>ManyToOne</h4><p>考虑下面的模型：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8811.28.37.png" alt=""><br>此时多个Employee可以对应一个Department，在关系数据库里面，Employee的did便是一个外键，且指向Department的id。</p>
<p>代码如下：</p>
<p>Employee.java:</p>
<pre><code>@Entity
@Table(name = &quot;Employee&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Employee {
    @Id
    private int eid;
    private String ename;
    private double salary;
    private String deg;
    @ManyToOne
    private Department department;

    ...

}
</code></pre><p>Department.java:</p>
<pre><code>@Entity
public class Department {
    @Id
    private int did;
    private String dname;

    public Department(int did, String dname) {
        this.did = did;
        this.dname = dname;
    }

    public Department() {
    }

    public int getDid() {
        return did;
    }

    public void setDid(int did) {
        this.did = did;
    }

    public String getDname() {
        return dname;
    }

    public void setDname(String dname) {
        this.dname = dname;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    @SuppressWarnings(&quot;unchecked&quot;)
    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        Department department = new Department(10, &quot;DingXiang&quot;);
        manager.persist(department);

        Employee employee1 = new Employee(100, &quot;zsr&quot;, 4000, &quot;Student&quot;);
        employee1.setDepartment(department);

        Employee employee2 = new Employee(101, &quot;yui&quot;, 4000, &quot;Student&quot;);
        employee2.setDepartment(department);

        Employee employee3 = new Employee(102, &quot;yuo&quot;, 4000, &quot;Student&quot;);
        employee3.setDepartment(department);

        manager.persist(employee1);
        manager.persist(employee2);
        manager.persist(employee3);

        transaction.commit();

        manager.close();
        factory.close();
    }
} 
</code></pre><p>执行结束后，打开h2 console，查看Employee和Department表，结果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8811.47.43.png" alt=""></p>
<h4 id="OneToMany"><a href="#OneToMany" class="headerlink" title="OneToMany"></a>OneToMany</h4><p>上面的反过来说，一个Department可以对应多个Employee，代码修改如下：</p>
<p>Department.java:</p>
<pre><code>@Entity
public class Department {
    @Id
    private int did;
    private String dname;
    @OneToMany(targetEntity = Employee.class)
    private List&lt;Employee&gt; employeeList;

    public Department(int did, String dname) {
        this.did = did;
        this.dname = dname;
    }

    public Department() {
    }

    public List&lt;Employee&gt; getEmployeeList() {
        return employeeList;
    }

    public void setEmployeeList(List&lt;Employee&gt; employeeList) {
        this.employeeList = employeeList;
    }

    public int getDid() {
        return did;
    }

    public void setDid(int did) {
        this.did = did;
    }

    public String getDname() {
        return dname;
    }

    public void setDname(String dname) {
        this.dname = dname;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        Department department = new Department(10, &quot;DingXiang&quot;);

        Employee employee1 = new Employee(100, &quot;zsr&quot;, 4000, &quot;Student&quot;);
        Employee employee2 = new Employee(101, &quot;yui&quot;, 4000, &quot;Student&quot;);
        Employee employee3 = new Employee(102, &quot;yuo&quot;, 4000, &quot;Student&quot;);

        manager.persist(employee1);
        manager.persist(employee2);
        manager.persist(employee3);

        List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();
        employees.add(employee1);
        employees.add(employee2);
        employees.add(employee3);

        department.setEmployeeList(employees);

        manager.persist(department);

        transaction.commit();

        manager.close();
        factory.close();
    }
}
</code></pre><p>执行完毕之后，打开h2 console，查看表信息，如下所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-16%20%E4%B8%8A%E5%8D%8812.00.54.png" alt=""></p>
<h4 id="OneToOne"><a href="#OneToOne" class="headerlink" title="OneToOne"></a>OneToOne</h4><p>假设上述Employee类和Department类是一一对应的关系，只需要把ManyToOne小节下Employee类中对department成员上的注解修改成<strong>@OneToOne</strong>，再在main方法中为每个Employee提供一个Department即可，执行完毕后，生成的表的格式和ManyToOne的格式相同，这里不再展示。</p>
<h4 id="ManyToMany"><a href="#ManyToMany" class="headerlink" title="ManyToMany"></a>ManyToMany</h4><p>考虑下面的模型：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-16%20%E4%B8%8A%E5%8D%8812.13.46.png" alt=""><br>一个课程可以有多个老师同时教学，一个老师也可以教多个课程，代码如下：</p>
<p>Clazz.java:</p>
<pre><code>@Entity
@Table(name = &quot;Clazz&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Clazz {
    @Id
    private int cid;
    private String cname;

    @ManyToMany(targetEntity = Teacher.class)
    private Set&lt;Teacher&gt; teachers;

    public Clazz() {
    }

    public Clazz(int cid, String cname) {
        this.cid = cid;
        this.cname = cname;
    }

    public Set&lt;Teacher&gt; getTeachers() {
        return teachers;
    }

    public void setTeachers(Set&lt;Teacher&gt; teachers) {
        this.teachers = teachers;
    }

    public int getCid() {
        return cid;
    }

    public void setCid(int cid) {
        this.cid = cid;
    }

    public String getCname() {
        return cname;
    }

    public void setCname(String cname) {
        this.cname = cname;
    }
}
</code></pre><p>Teacher.java:</p>
<pre><code>@Entity
@Table(name = &quot;Teacher&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Teacher {
    @Id
    private int tid;
    private String tname;

    @ManyToMany(targetEntity = Clazz.class)
    Set&lt;Clazz&gt; clazzes;

    public Teacher(int tid, String tname) {
        this.tid = tid;
        this.tname = tname;
    }

    public Teacher() {
    }

    public int getTid() {
        return tid;
    }

    public void setTid(int tid) {
        this.tid = tid;
    }

    public String getTname() {
        return tname;
    }

    public void setTname(String tname) {
        this.tname = tname;
    }

    public Set&lt;Clazz&gt; getClazzes() {
        return clazzes;
    }

    public void setClazzes(Set&lt;Clazz&gt; clazzes) {
        this.clazzes = clazzes;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        Clazz clazz = new Clazz(10, &quot;Chinese&quot;);
        Clazz clazz1 = new Clazz(11, &quot;Math&quot;);
        Clazz clazz2 = new Clazz(12, &quot;English&quot;);

        manager.persist(clazz);
        manager.persist(clazz1);
        manager.persist(clazz2);

        Set&lt;Clazz&gt; clazzes = new HashSet&lt;&gt;();
        clazzes.add(clazz);
        clazzes.add(clazz1);
        clazzes.add(clazz2);

        Set&lt;Clazz&gt; clazzes1 = new HashSet&lt;&gt;(clazzes);
        Set&lt;Clazz&gt; clazzes2 = new HashSet&lt;&gt;(clazzes);

        Teacher teacher1 = new Teacher(1, &quot;zsr&quot;);
        Teacher teacher2 = new Teacher(2, &quot;zx&quot;);
        Teacher teacher3 = new Teacher(3, &quot;zo&quot;);

        teacher1.setClazzes(clazzes);
        teacher2.setClazzes(clazzes1);
        teacher3.setClazzes(clazzes2);

        manager.persist(teacher1);
        manager.persist(teacher2);
        manager.persist(teacher3);

        transaction.commit();

        manager.close();
        factory.close();
    }
}
</code></pre><p>执行完毕之后打开h2 console查看表，结果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-16%20%E4%B8%8A%E5%8D%8812.33.02.png" alt=""></p>
<h3 id="Criteria-Api"><a href="#Criteria-Api" class="headerlink" title="Criteria Api"></a>Criteria Api</h3><p>Criteria Api是用来执行标准查询的api，其用法遵循以下流程：</p>
<pre><code>EntityManager em = ...;
CriteriaBuilder cb = em.getCriteriaBuilder(); CriteriaQuery&lt;Entity class&gt; cq = cb.createQuery(Entity.class); 
Root&lt;Entity&gt; from = cq.from(Entity.class);
cq.select(Entity);
TypedQuery&lt;Entity&gt; q = em.createQuery(cq);
List&lt;Entity&gt; allitems = q.getResultList();
</code></pre><p>还是拿JPQL小节的数据当例子，代码如下：</p>
<p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);

    private static void createAnEmployee(EntityManager manager, Employee employee) {
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        manager.persist(employee);
        transaction.commit();
    }


    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();


        Employee employee1 = new Employee(100, &quot;Gopal&quot;, 40000, &quot;Technical Manager&quot;);
        Employee employee2 = new Employee(101, &quot;Manisha&quot;, 35000, &quot;Reader&quot;);
        Employee employee3 = new Employee(102, &quot;Masthanvali&quot;, 37000, &quot;Teacher&quot;);
        Employee employee4 = new Employee(103, &quot;Satish&quot;, 30000, &quot;Student&quot;);
        Employee employee5 = new Employee(104, &quot;Krishna&quot;, 31000, &quot;Tutor&quot;);
        Employee employee6 = new Employee(105, &quot;Kiran&quot;, 32000, &quot;Drinker&quot;);

        createAnEmployee(manager, employee1);
        createAnEmployee(manager, employee2);
        createAnEmployee(manager, employee3);
        createAnEmployee(manager, employee4);
        createAnEmployee(manager, employee5);
        createAnEmployee(manager, employee6);

        CriteriaBuilder criteriaBuilder = manager.getCriteriaBuilder();
        CriteriaQuery&lt;Employee&gt; employeeCriteriaQuery = criteriaBuilder.createQuery(Employee.class);
        Root&lt;Employee&gt; from = employeeCriteriaQuery.from(Employee.class);

        CriteriaQuery&lt;Employee&gt; betweenSelect = employeeCriteriaQuery.select(from)
                .where(criteriaBuilder.between(from.get(&quot;salary&quot;), 30000, 35000));
        TypedQuery&lt;Employee&gt; betweenSelectTypedQuery = manager.createQuery(betweenSelect);
        List&lt;Employee&gt; betweenSelectResults = betweenSelectTypedQuery.getResultList();

        for (Employee employee : betweenSelectResults) {
            System.out.println(employee);
        }

        manager.close();
        factory.close();
    }
}
</code></pre><p>输出和JPQL小节的输出效果相同，可以看出Criteria更加面向对象。</p>
<h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>上面再配置JPA项目的时候我们用Hibernate作为Provider。Hibernate是一个优秀的开源Java ORM框架，既可以适配JPA也可以拿出来单独使用，有了上面的基础其使用也就变的简单自然。Hibernate还提供了缓存和检索服务，拥有拦截功能，其具体使用请查看官方文档，教程推荐: <a href="http://wiki.jikexueyuan.com/project/hibernate/" target="_blank" rel="external">Hibernate教程</a></p>
<p>另外，IntelliJ IDEA也可以直接建立Hibernate项目省去了配置的麻烦…</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/08/用PopupWindow实现键盘之上的悬浮窗/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/08/用PopupWindow实现键盘之上的悬浮窗/" itemprop="url">
                  用PopupWindow实现键盘之上的悬浮窗
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-08T20:22:23+08:00">
                2017-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/08/用PopupWindow实现键盘之上的悬浮窗/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/08/用PopupWindow实现键盘之上的悬浮窗/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近遇到一个写评论的需求，就是点击一个写评论的按钮跳出软键盘，软键盘之上有一个输入框和发送按钮，想了好半天决定采用悬浮窗，其主要想法来自：<a href="http://www.itdadao.com/articles/c15a380342p0.html" target="_blank" rel="external">模仿微信，QQ评论输入框</a>，其效果图如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/Screenshot_1491657613.png" alt=""></p>
<h1 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h1><h2 id="activity-main"><a href="#activity-main" class="headerlink" title="activity_main:"></a>activity_main:</h2><pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.stephen.popupwindowedittext.MainActivity&quot;
    android:id=&quot;@+id/root&quot;&gt;

    &lt;LinearLayout
        android:id=&quot;@+id/comment_part&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:orientation=&quot;horizontal&quot;
        android:padding=&quot;12dp&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/comment&quot;
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_weight=&quot;1&quot;
            android:textStyle=&quot;bold&quot;
            android:text=&quot;评论&quot;
            android:textSize=&quot;14sp&quot;/&gt;
        &lt;Button
            android:id=&quot;@+id/write_comment_button&quot;
            android:background=&quot;@drawable/bg_write_comment_button&quot;
            android:layout_width=&quot;48dp&quot;
            android:layout_height=&quot;24dp&quot;
            android:text=&quot;写评论&quot;
            android:textSize=&quot;10sp&quot;
            android:textColor=&quot;@android:color/white&quot;/&gt;
    &lt;/LinearLayout&gt;

    &lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/comments_list&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@id/comment_part&quot;/&gt;
&lt;/RelativeLayout&gt;
</code></pre><h2 id="window-edittext"><a href="#window-edittext" class="headerlink" title="window_edittext"></a>window_edittext</h2><pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;horizontal&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:paddingLeft=&quot;12dp&quot;
    android:paddingRight=&quot;12dp&quot;&gt;

    &lt;EditText
        android:id=&quot;@+id/main_edit_text&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_weight=&quot;1&quot;/&gt;
    &lt;Button
        android:background=&quot;@drawable/bg_send_button&quot;
        android:id=&quot;@+id/send_button&quot;
        android:layout_width=&quot;52dp&quot;
        android:layout_height=&quot;24dp&quot;
        android:layout_marginLeft=&quot;8dp&quot;
        android:text=&quot;发送&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;12sp&quot;/&gt;
&lt;/LinearLayout&gt;
</code></pre><h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity:"></a>MainActivity:</h2><pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    private List&lt;String&gt; data = new ArrayList&lt;&gt;();
    private RecyclerView rv;
    private InputMethodManager imm;

    private View commentPatternView;
    private PopupWindow commentPatternWindow;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);

        initView();
    }

    private void initView() {
        findViewById(R.id.write_comment_button).setOnClickListener(this);
        rv = (RecyclerView) findViewById(R.id.comments_list);
        rv.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));
        rv.setAdapter(new CommentsListAdapter(data));
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.write_comment_button: {
                showCommentPattern();
                break;
            }
            case R.id.send_button: {
                sendComment();
                if (commentPatternWindow != null) {
                    commentPatternWindow.dismiss();
                }
                break;
            }
        }
    }

    private void sendComment() {
        String content = ((EditText) commentPatternView.findViewById(R.id.main_edit_text)).getText().toString();
        data.add(content);
        rv.getAdapter().notifyItemInserted(data.size() - 1);
    }

    private void showCommentPattern() {
        View parent = findViewById(R.id.root);

        if (commentPatternView == null) {
            commentPatternView = getLayoutInflater().inflate(R.layout.window_edit_text, null);
            commentPatternView.findViewById(R.id.send_button).setOnClickListener(this);
        }

        if (commentPatternWindow == null) {
            commentPatternWindow = new PopupWindow(commentPatternView, WindowManager.LayoutParams.MATCH_PARENT,
                    WindowManager.LayoutParams.WRAP_CONTENT, true);
            commentPatternWindow.setBackgroundDrawable(new ColorDrawable(Color.WHITE));
            commentPatternWindow.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
        }

        commentPatternWindow.showAtLocation(parent, Gravity.BOTTOM, 0, 0);
        commentPatternWindow.setOnDismissListener(new PopupWindow.OnDismissListener() {
            @Override
            public void onDismiss() {
                imm.toggleSoftInput(InputMethodManager.HIDE_IMPLICIT_ONLY, 0);
            }
        });

        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                imm.showSoftInput(commentPatternView.findViewById(R.id.main_edit_text), InputMethodManager.SHOW_FORCED);
            }
        }, 100);
    }
}
</code></pre><p>上面两个布局文件没什么好说的，主要是第三个文件，首先要注意的是要调用<strong>PopupWindow</strong>的<strong>setBackgroundDrawable</strong>方法，否则会有各种意想不到的bug；其次要调用<strong>setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE)</strong>，这是为了让<strong>PopupWindow</strong>出现在软键盘之上。</p>
<p>软键盘的调用方式也是值得注意的地方，在<strong>showAtLocation</strong>方法调用完成之后不能立即使软键盘弹出，得有一个延时的过程，软键盘消失的事件与window消失的事件绑定在一起即可。</p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>上述方法有一个缺陷，就是不能禁止掉<strong>outsideTouchable</strong>，因为要接受软键盘的输入，所以<strong>focusable</strong>必须为<strong>true</strong>，而<strong>setOutsideTouchable(false)</strong>方法必须在<strong>focusable</strong>为<strong>false</strong>，<strong>touchable</strong>为<strong>true</strong>时才生效，所以上述方法不能保证点击其余空白区域悬浮窗不消失。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/14/使用Fork-Join架构进行归并排序/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/使用Fork-Join架构进行归并排序/" itemprop="url">
                  使用Fork/Join架构进行归并排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-14T23:37:51+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/使用Fork-Join架构进行归并排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/使用Fork-Join架构进行归并排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>以下部分文字，图片摘自《Java并发编程的艺术》</p>
<h1 id="Fork-Join框架简介"><a href="#Fork-Join框架简介" class="headerlink" title="Fork/Join框架简介"></a>Fork/Join框架简介</h1><p>Fork/Join框架是jdk7中提供的并行框架，其主要的特点是把一个大任务分割成几块不同的小任务，由不同的线程去执行这一系列的小任务，最终结果合并成大任务的结果。</p>
<p>其主要原理如图所示：<br><img src="http://cdn.infoqstatic.com/statics_s1_20170314-0434/resource/articles/fork-join-introduction/zh/resources/21.png" alt=""></p>
<h1 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h1><p>工作窃取算法的意思是每个线程的任务队列执行完毕之后，此线程会将其他线程的任务队列中的任务“窃取”到本线程的任务队列中来。使用窃取算法的好处就是充分利用了线程的并行计算，有关工作窃取算法的更多内容，请看：<a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="external">Work Stealing</a></p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>再实际应用上，要首先确定一个大的任务是否能够分成几个小的任务，是否能把小任务的结果进行合并，这样就自然而然的想到递归。下面笔者实现一个用Fork/Join架构实现的归并排序算法：</p>
<pre><code>public class ForkJoinPractice {
    static class SortTask&lt;T extends Comparable&lt;T&gt;&gt; extends RecursiveAction {
        T[] array;
        int start;
        int end;
        int mid;

        public SortTask(T[] array, int start, int end) {
            this.array = array;
            this.start = start;
            this.end = end;
            this.mid = (this.start + this.end) / 2;
        }

        @Override
        protected void compute() {
            int mid;
            if (start &lt; end) {
                mid = (start + end) / 2;
                //将任务分解
                invokeAll(new SortTask&lt;T&gt;(array, start, mid), new SortTask&lt;T&gt;(array, mid + 1, end));
                merge();
            }
        }

        private void merge() {
            int n1 = mid - start + 1;
            int n2 = end - mid;
            int i, j, k;

            List&lt;T&gt; leftList = new ArrayList&lt;&gt;(n1);
            List&lt;T&gt; rightList = new ArrayList&lt;&gt;(n2);

            for (i = 0; i &lt; n1; i++) {
                leftList.add(array[start + i]);
            }

            for (j = 0; j &lt; n2; j++) {
                rightList.add(array[mid + 1 + j]);
            }

            i = j = 0;
            k = start;

            while (i &lt; n1 &amp;&amp; j &lt; n2) {
                if (leftList.get(i).compareTo(rightList.get(j)) &lt; 0) {
                    array[k++] = leftList.get(i++);
                } else {
                    array[k++] = rightList.get(j++);
                }
            }

            while (i &lt; n1) {
                array[k++] = leftList.get(i++);
            }

            while (j &lt; n2) {
                array[k++] = rightList.get(j++);
            }
        }
    }

    public static void main(String[] args) {
        Integer[] array = new Integer[90];
        for (int i = 0; i &lt; 90; i++) {
            array[i] = 90 - i;
        }

        SortTask&lt;Integer&gt; sortTask = new SortTask&lt;&gt;(array, 0, array.length - 1);
        ForkJoinPool pool = new ForkJoinPool();
        pool.submit(sortTask);
        try {
            //等待任务结束
            pool.awaitTermination(3, TimeUnit.SECONDS);
            pool.shutdown();
            for (int i :  array) {
                System.out.println(i);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/14/Java并发编程-二/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/Java并发编程-二/" itemprop="url">
                  Java并发编程(二)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-14T20:20:52+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/Java并发编程-二/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/Java并发编程-二/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>以下内容均摘自《Java并发编程的艺术》</p>
<h1 id="等待／超时模式"><a href="#等待／超时模式" class="headerlink" title="等待／超时模式"></a>等待／超时模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>等待／超时模式的典型应用场景是，等待一段时间，看是否能得到正确的结果，如果能，则将其返回，不能则返回默认值，其代码如下：</p>
<pre><code>public synchronized Object getObject(long millionSeconds) throws InterruptedException {
    long future = System.currentTimeMillis() + millionSeconds;
    long remainingTime = millionSeconds;
    while (obj == null &amp;&amp; remainingTime &gt; 0) {
        wait(remainingTime);
        remainingTime = future - System.currentTimeMillis();
    }

    return obj;
}
</code></pre><h2 id="应用：数据库连接池"><a href="#应用：数据库连接池" class="headerlink" title="应用：数据库连接池"></a>应用：数据库连接池</h2><p>下面来模拟一个数据库连接池，用来从中获取和释放连接，客户端获取连接被设置为超时等待，程序如下：</p>
<pre><code>public class ConnectionPool {
    private final LinkedList&lt;Connection&gt; connections = new LinkedList&lt;&gt;();

    public ConnectionPool(int initSize) {
        if (initSize &lt;= 0)
            throw new IllegalArgumentException(&quot;Init size must &gt; 0&quot;);
        for (int i = 0; i &lt; initSize; i++) {
            connections.addLast(ConnectionDriver.getConnection());
        }
    }

    public void releaseConnection(Connection connection) {
        synchronized (connections) {
            connections.addLast(connection);
            connections.notifyAll();
        }
    }

    public Connection getConnection(long millionSeconds) throws InterruptedException {
        synchronized (connections) {
            if (millionSeconds &lt;= 0) {
                while (connections.isEmpty()) {
                    connections.wait();
                }
                return connections.removeFirst();
            } else {
                long future = System.currentTimeMillis() + millionSeconds;
                long remaining = millionSeconds;

                while (connections.isEmpty() &amp;&amp; remaining &gt; 0) {
                    connections.wait(remaining);
                    remaining = future - System.currentTimeMillis();
                }

                Connection connection = null;
                if (!connections.isEmpty()) {
                    connection = connections.removeFirst();
                }

                return connection;
            }
        }
    }
}
</code></pre><p>ConnectionDriver通过动态代理技术返回一个Connection:</p>
<pre><code>public class ConnectionDriver {

    public static class ConnectionHandler implements InvocationHandler {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            if (method.getName().equals(&quot;commit&quot;)) {
                Thread.sleep(1000);
            }

            return null;
        }
    }

    public static Connection getConnection() {
        return (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(),
                new Class[] {Connection.class},
                new ConnectionHandler());
    }
}
</code></pre><p>上面的连接池通过构造函数传入的initSize来定义里面的连接数量，通过<strong>release</strong>方法来释放用过的连接，此时连接被重新加入到队列内部，然后通知在<strong>connections</strong>上等待的线程此时有连接可以进行复用。<strong>getConnection</strong>通过制定的参数设置超时时间，并判断队列是否为空，不为空则直接从队列里面取出第一个并返回，不是的话则在<strong>connections</strong>上进行等待，知道超时或者又有复用的connection为止。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/Java并发编程-一/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/Java并发编程-一/" itemprop="url">
                  Java并发编程(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-13T18:46:34+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/13/Java并发编程-一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/13/Java并发编程-一/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>一下部分文字图片来自《Java并发编程的艺术》</p>
<h1 id="多线程简介"><a href="#多线程简介" class="headerlink" title="多线程简介"></a>多线程简介</h1><p>线程是现代操作系统调度的最小单元，一个进程可以包含很多线程。在Java的内存区域里面，每一个线程都有自己的程序计数器和虚拟机栈。处理器通过时间切片的方法在各个线程之间来回切换，可以用下面的代码查看JVM运行时各个线程的信息：</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) {
        ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();
        ThreadInfo[] threadInfoArray = mxBean.dumpAllThreads(false, false);

        for (ThreadInfo info : threadInfoArray) {
            System.out.println(&quot;Thread id: &quot; + info.getThreadId() + &quot; Thread name: &quot; +
                    info.getThreadName() + &quot; Thread state: &quot; + info.getThreadState());
        }
    }
}
</code></pre><p>运行结果如下：</p>
<pre><code>Thread id: 9 Thread name: Monitor Ctrl-Break Thread state: RUNNABLE
Thread id: 4 Thread name: Signal Dispatcher Thread state: RUNNABLE
Thread id: 3 Thread name: Finalizer Thread state: WAITING
Thread id: 2 Thread name: Reference Handler Thread state: WAITING
Thread id: 1 Thread name: main Thread state: RUNNABLE
</code></pre><p>也就是说，运行main函数时，不只是main线程在运行，Java天生就是多线程的。</p>
<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>在Java程序里面，线程的优先级通过<strong>setPriority(int priority)</strong>来设置，<strong>priority</strong>的取值范围为1-10，默认为5，线程的优先级越高，处理器对此线程所切的时间片越长，但是不同的操作系统的表现不同，有些会忽略掉线程的优先级，因此，设置优先级不会保证多线程程序的正确性，在实际编程过程中不应该使用。</p>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>线程的状态分为以下几种：</p>
<ul>
<li><strong>NEW</strong> 被创建成功，还没有调用<strong>start()</strong>方法。</li>
<li><strong>RUNNABLE</strong> 正在运行中。</li>
<li><strong>BLOCKED</strong> 正在处于阻塞状态。</li>
<li><strong>WAITING</strong> 等待状态，此线程在等待其他线程做出特定的动作。</li>
<li><strong>TIME_WAITING</strong> 超时等待状态。</li>
<li><strong>TERMINATED</strong> 终止，线程结束。</li>
</ul>
<p>拿上面的运行结果的线程名为<strong>Finalizer</strong>的线程来说，运行时处于<strong>WAITING</strong>状态，它在等待有对象进入它内部持有的<strong>ReferenceQueue</strong>，并执行清理动作，有关Finalizer的更多信息，查看：<a href="http://blog.csdn.net/rsljdkt/article/details/12242007" target="_blank" rel="external">GC执行finalize的过程</a></p>
<p>为了说明各大状态，我先用开几个线程，然后用<a href="http://blog.csdn.net/fenglibing/article/details/6411940" target="_blank" rel="external">jstack</a>指令查看各线程的状态。</p>
<p>代码如下：</p>
<pre><code>class SleepUtils {
    public static void sleep(int millionSeconds) {
        try {
            Thread.sleep(millionSeconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class ThreadStateTest {

    static class TimeWaitingThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                SleepUtils.sleep(100);
            }
        }
    }

    static class PauseThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                long current = System.currentTimeMillis();
                while (System.currentTimeMillis() - current &lt;= 3000);
            }
        }
    }

    static class Waiting implements Runnable {
        @Override
        public void run() {
            while (true) {
                synchronized (Waiting.class) {
                    try {
                        Waiting.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    static class Block implements Runnable {
        @Override
        public void run() {
            synchronized (Block.class) {
                while (true) {
                    SleepUtils.sleep(4000);
                }
            }
        }
    }

    public static void main(String[] args) {
        new Thread(new TimeWaitingThread(), &quot;TimedWaitingThread&quot;).start();
        new Thread(new PauseThread(), &quot;PauseThread&quot;).start();
        new Thread(new Waiting(), &quot;WaitingThread&quot;).start();
        new Thread(new Block(), &quot;Block1&quot;).start();
        new Thread(new Block(), &quot;Block2&quot;).start();
    }
}
</code></pre><p>运行之后，先在终端运行<a href="http://blog.csdn.net/fenglibing/article/details/6411932" target="_blank" rel="external">jps</a>命令，结果如下：</p>
<pre><code>37729 
38982 Launcher
38983 AppMain
38986 Jps
</code></pre><p>其中<strong>AppMain</strong>就是刚才开启的进程pid，现在运行<strong>jstack 38983</strong>，运行结果如下（部分）：</p>
<pre><code>&quot;Block2&quot; #14 prio=5 os_prio=31 tid=0x00007fc65c835000 nid=0x5703 waiting for monitor entry [0x0000700002ba2000]
   java.lang.Thread.State: BLOCKED (on object monitor)
    at com.stephen.ThreadStateTest$Block.run(ThreadStateTest.java:58)
    - waiting to lock &lt;0x00000007956f6ea8&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Block)
    at java.lang.Thread.run(Thread.java:745)

&quot;Block1&quot; #13 prio=5 os_prio=31 tid=0x00007fc65d82a000 nid=0x5503 waiting on condition [0x0000700002a9f000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
    at java.lang.Thread.sleep(Native Method)
    at com.stephen.SleepUtils.sleep(ThreadStateTest.java:10)
    at com.stephen.ThreadStateTest$Block.run(ThreadStateTest.java:58)
    - locked &lt;0x00000007956f6ea8&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Block)
    at java.lang.Thread.run(Thread.java:745)

&quot;WaitingThread&quot; #12 prio=5 os_prio=31 tid=0x00007fc65d82f800 nid=0x5303 in Object.wait() [0x000070000299c000]
   java.lang.Thread.State: WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    - waiting on &lt;0x00000007956f37f0&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Waiting)
    at java.lang.Object.wait(Object.java:502)
    at com.stephen.ThreadStateTest$Waiting.run(ThreadStateTest.java:44)
    - locked &lt;0x00000007956f37f0&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Waiting)
    at java.lang.Thread.run(Thread.java:745)

&quot;PauseThread&quot; #11 prio=5 os_prio=31 tid=0x00007fc65e01e000 nid=0x5103 runnable [0x0000700002899000]
   java.lang.Thread.State: RUNNABLE
    at com.stephen.ThreadStateTest$PauseThread.run(ThreadStateTest.java:33)
    at java.lang.Thread.run(Thread.java:745)

&quot;TimedWaitingThread&quot; #10 prio=5 os_prio=31 tid=0x00007fc65c80e000 nid=0x4f03 waiting on condition [0x0000700002796000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
    at java.lang.Thread.sleep(Native Method)
    at com.stephen.SleepUtils.sleep(ThreadStateTest.java:10)
    at com.stephen.ThreadStateTest$TimeWaitingThread.run(ThreadStateTest.java:23)
    at java.lang.Thread.run(Thread.java:745)
</code></pre><p>现在来逐一解释：</p>
<ul>
<li><strong>Block2</strong>：由于<strong>Block1</strong>已经获得<strong>Block.class</strong>锁，所以此线程处于阻塞状态。</li>
<li><strong>Block1</strong>：此线程不断的进行睡眠，且睡眠操作具有时间限制，因此处在超时等待操作状态。</li>
<li><strong>WaitingThread</strong>：此线程在<strong>Waiting.class</strong>上等待，且没有时间限制，所以处在waiting状态。</li>
<li><strong>PauseThread</strong>：此线程和<strong>TimedWaitingThread</strong>线程达到的效果相同，但是实现的手段不同，没有调用<strong>Thread.sleep(int millionSeconds)</strong>方法，处在<strong>Runnable</strong>状态。</li>
<li><strong>TimedWaitingThread</strong>：此线程不断调用<strong>Thread.sleep(int millionSeconds)</strong>方法，处于超时等待状态。</li>
</ul>
<h1 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h1><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><p>其他线程可以调用另一个线程的<strong>interrupt()</strong>方法来中断线程，可以调用线程的<strong>isInterrupted()</strong>来判断一个线程是否被中断，但是这个方法不总是返回true:</p>
<ul>
<li>当线程终止时，此方法会返回false。</li>
<li>抛出<strong>InterruptedException</strong>的方法，在抛出异常之前，会将标识位设置为false，因此方法也总是返回false。</li>
</ul>
<p>现在用如下程序做出证明：</p>
<pre><code>public class InterruptTest {
    static class SleepThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                SleepUtils.sleep(3000);
            }
        }
    }

    static class NormalThread implements Runnable {
        @Override
        public void run() {
            while (true);
        }
    }

    public static void main(String[] args) {
        Thread sleepThread = new Thread(new SleepThread(), &quot;Sleep&quot;);
        Thread normalThread = new Thread(new NormalThread(), &quot;Normal&quot;);

        sleepThread.start();
        normalThread.start();

        SleepUtils.sleep(2000);

        sleepThread.interrupt();
        normalThread.interrupt();

        System.out.println(&quot;Sleep thread interrupted is &quot; + sleepThread.isInterrupted());
        System.out.println(&quot;Normal thread interrupted is &quot; + normalThread.isInterrupted());
    }
}
</code></pre><p>结果如下：</p>
<pre><code>Sleep thread interrupted is false    
Normal thread interrupted is true
</code></pre><h2 id="设置boolean变量"><a href="#设置boolean变量" class="headerlink" title="设置boolean变量"></a>设置boolean变量</h2><p>还可以设置boolean变量来通知线程的结束，这种方式比上面的<strong>interrupt</strong>方法更为优雅：</p>
<pre><code>public class BooleanFlagThread {
    static class CounterRunnable implements Runnable {
        long i = 0L;
        private volatile boolean isCancelled = false;

        public void cancel() {
            isCancelled = true;
        }

        @Override
        public void run() {
            while (!isCancelled &amp;&amp; !Thread.currentThread().isInterrupted()) {
                i++;
            }
        }
    }

    public static void main(String[] args) {
        CounterRunnable cr = new CounterRunnable();
        Thread countThread = new Thread(cr, &quot;Count&quot;);
        countThread.start();

        SleepUtils.sleep(2000);
        cr.cancel();

        System.out.println(&quot;&quot; + cr.i);
    }
}
</code></pre><h1 id="线程之间的通信：notify-wait"><a href="#线程之间的通信：notify-wait" class="headerlink" title="线程之间的通信：notify(), wait()"></a>线程之间的通信：notify(), wait()</h1><p>线程除了用<strong>synchronized</strong>,<strong>volatile</strong>来进行通信之外，还可以用notify和wait方法，使用这两个方法的前提是某个线程获取了相应对象的锁，典型应用的示例代码如下：</p>
<pre><code>public class NotifyWaitTest {
    static Object lock = new Object();
    static boolean flag = true;

    static class Wait implements Runnable {
        @Override
        public void run() {
            //获取对象的锁
            synchronized (lock) {
                while (flag) { // 2
                    System.out.println(&quot;不满足相应的条件&quot;);
                    try {
                        //进入wait状态，同时释放对象的锁
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(&quot;条件满足&quot;);
            }
        }
    }

    static class Notify implements Runnable {
        @Override
        public void run() {
            //获取对象的锁
            synchronized (lock) {
                if (flag) {
                    flag = false; // 1
                    //通知改变
                    lock.notify();
                }

                System.out.println(&quot;条件已改变&quot;);
            }
        }
    }

    public static void main(String[] args) {
        Thread waitThread = new Thread(new Wait(), &quot;Wait&quot;);
        Thread notifyThread = new Thread(new Notify(), &quot;Notify&quot;);
        waitThread.start();
        //保证wait先执行的方式
        SleepUtils.sleep(2000);
        notifyThread.start();
    }
}
</code></pre><p>输出的结果如下：</p>
<pre><code>不满足相应的条件
条件已改变
条件满足
</code></pre><p>需要注意的是：</p>
<ul>
<li>在调用notify, wait方法之前，要先获得对象的锁。</li>
<li>wait方法，会释放相应的锁。</li>
<li>notify方法会将调用wait的线程从等待队列到同步队列，此时wait线程将从WAITING状态转到BLOCK状态。</li>
<li>只有当notify的线程释放对象锁时，另一个wait线程才会返回继续工作。</li>
<li>notify和wait具有happens-before关系。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/Java内存模型-三/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/Java内存模型-三/" itemprop="url">
                  Java内存模型(三)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-13T18:44:31+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/13/Java内存模型-三/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/13/Java内存模型-三/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>一下部分文字图片来自《Java并发编程的艺术》</p>
<h1 id="双重检查锁解决方案"><a href="#双重检查锁解决方案" class="headerlink" title="双重检查锁解决方案"></a>双重检查锁解决方案</h1><p>Java程序有时需要用到单例模式，通常用延迟初始化的方式实现单例模式，但是只是简单的延迟初始化可能会有线程安全问题，例如：</p>
<pre><code>public class Instance {
    private static Instance instance;

    public static Instance getInstance() {
        if (instance == null) { //1
            instance = new Instance();
        }

        return instance;
    }
}
</code></pre><p>这段代码有很严重的问题，加入两个线程同时处于1操作并且判断instance为空的话，那么instance就会被初始化两次。</p>
<h2 id="synchronized解决方案"><a href="#synchronized解决方案" class="headerlink" title="synchronized解决方案"></a>synchronized解决方案</h2><p>解决上述问题最简单的方法便是用<strong>synchronized</strong>关键字标注<strong>getInstance</strong>方法：</p>
<pre><code>public synchronized static Instance getInstance() {
    if (instance == null) {
        instance = new Instance();
    }

    return instance;
}
</code></pre><p>此方法解决了多线程冲突的问题，但是如果线程太多且<strong>instance</strong>初始化过程太耗时的话，就会转成重量级锁，性能问题随之而来。</p>
<h2 id="双重检查锁定-Double-Checked-Lock"><a href="#双重检查锁定-Double-Checked-Lock" class="headerlink" title="双重检查锁定(Double Checked Lock)"></a>双重检查锁定(Double Checked Lock)</h2><p>为了解决性能的开销，采取了下述办法来解决：</p>
<pre><code>public class Instance {
    private static Instance instance;

    public static Instance getInstance() {
        if (instance == null) { //1
            synchronized (Instance.class) { //2
                if (instance == null) { //3
                    instance = new Instance();
                }
            }
        }

        return instance;
    }
}
</code></pre><p>采用上述办法不能完美地解决问题，出现的问题是返回的引用可能指向一个未被完全正确初始化的对象，下面来分析一下。</p>
<p>假设初始有两个线程A,B同时调用<strong>getInstance</strong>方法，判断instance为空之后开始竞争<strong>Instance</strong>锁，设B线程首先获得了锁，并在成功初始化<strong>instance</strong>对象之后释放锁，此时线程A再获取锁，根据happens-before关系，此时线程A对<strong>instance</strong>对象的改变是可以看到的，因此整个过程只初始化了一次，截止到现在是没有问题的。</p>
<h3 id="对象的初始化过程"><a href="#对象的初始化过程" class="headerlink" title="对象的初始化过程"></a>对象的初始化过程</h3><p>上述办法的问题来自于对象初始化过程的重排序，<strong>instance</strong>初始化可以分成以下三个过程：</p>
<ul>
<li>分配对象的存储空间。</li>
<li>进行初始化。</li>
<li>将对象的地址赋值给引用。</li>
</ul>
<p>问题来自于第二步和第三步的重排序。加入现在有两个线程A,B同时执行，B 先获得了锁先执行，此时A执行到上面的1操作，但是B线程此刻已经把对象地址赋值给了引用，但是并没有正确的初始化（3和1不具备happens-before）关系，此刻A线程读到的<strong>instance</strong>引用是不为空的，但是对象并没有正确的初始化，便即刻将其暴露给外部，问题就出现了。</p>
<h3 id="基于volatile的解决方案"><a href="#基于volatile的解决方案" class="headerlink" title="基于volatile的解决方案"></a>基于volatile的解决方案</h3><p>在<strong>instance</strong>对象前面加上<strong>volatile</strong>关键字可以禁止上述初始化过程的重排序：</p>
<pre><code>public class Instance {
    private volatile static Instance instance;

    public static Instance getInstance() {
        if (instance == null) {
            synchronized (Instance.class) {
                if (instance == null) {
                    instance = new Instance();
                }
            }
        }

        return instance;
    }
}
</code></pre><p><strong>volatile</strong>关键字保证了读取到引用不为空时对象已经被正确地初始化，问题解决。</p>
<h3 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h3><pre><code>public class Instance {
    private static class InstanceHolder {
        private static Instance instance = new Instance();
    }

    public static Instance getInstance() {
        return InstanceHolder.instance;
    }
}
</code></pre><p>此种方法适合包含无参构造函数的类的单例模式，原理如下：</p>
<p>假设有两个线程A,B当两个线程同时开始访问<strong>Instance</strong>类的时候，开始类的初始化，此时JVM将尝试获取<strong>Instance</strong>类上的锁，防止多个线程同时初始化。</p>
<p>假定线程B获取了初始化的锁，当执行完<strong>instance = new Instance()</strong>语句时，释放锁，线程A执行时将会看到已经初始化的<strong>instance</strong>实例并将其返回，初始化过程的重排序对于线程A此时是不可见的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/11/Java内存模型-二/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/11/Java内存模型-二/" itemprop="url">
                  Java内存模型(二)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-11T11:08:01+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/11/Java内存模型-二/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/11/Java内存模型-二/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>一下部分文字图片来自《Java并发编程的艺术》</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>volatile</strong>的典型特性之一是一个线程对<strong>volatile</strong>变量的写入对其他线程来说是立即可见的。假设有以下程序：</p>
<pre><code>public class VolatileFeaturesExample {
    private volatile int a;

    public int getA() {
        return a;
    }

    public void setA(int a) {
        this.a = a;
    }
}
</code></pre><p>与下面这段代码的执行效果是等效的：</p>
<pre><code>public class VolatileFeaturesExample {
    private int a;

    public synchronized void setA(int a) {
        this.a = a;
    }

    public synchronized int getA() {
        return a;
    }
}
</code></pre><p>根据happens-before规则，锁的解锁happens before于此锁被加锁之前，所以一个线程对<strong>a</strong>变量的写入对另一个线程是可见的。</p>
<p>另外，锁的语义决定了<strong>volatile</strong>的读写具备原子性，也就是说即便对于<strong>long</strong>和<strong>double</strong>类型，只要有<strong>volatile</strong>关键字修饰，对其赋值也是原子操作。</p>
<h2 id="限制重排序"><a href="#限制重排序" class="headerlink" title="限制重排序"></a>限制重排序</h2><p>为了实现volatile的内存语义， JMM针对volatile变量制定了一套特殊的重排序规则，规则如下表：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-11%20%E4%B8%8B%E5%8D%884.22.57.png" alt=""></p>
<p>从图中可以看出：</p>
<ul>
<li>若第二个操作是对volatile对象的写操作，那么无论第一个操作是什么，都不会发生重排序。</li>
<li>若第一个操作是对volatile变量的读操作，那么无论第二个操作是什么，都不会发生重排序。</li>
</ul>
<p>上一篇博客曾经提到<strong>volatile</strong>的实现是通过增加内存屏障来实现的，针对<strong>volatile</strong>的内存屏障策略如下：</p>
<ul>
<li>在volatile变量写之前加入store屏障。</li>
<li>在volatile变量写之后加入store-load屏障。</li>
<li>在读操作的后面加上load屏障。</li>
<li>在读操作的后面加上load-store屏障。</li>
</ul>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><p>先看下面这段代码：</p>
<pre><code>public class LockExample {
    private int a;

    public synchronized void increase() { // 1
        a++; // 2
    } // 3

    public synchronized void get() { // 4
        int i = a; // 5
    } // 6
}
</code></pre><p>根据happens-before原则，1发生在2之前，2发生在3之前……最终得出的结论是2发生在5之前，也就是说，两个线程，线程1获得锁之后对所有共享变量的修改，对下一个线程获得锁的时候是可见的。</p>
<h2 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h2><p>锁的内存语义如下：</p>
<ul>
<li>一个线程释放锁，会将本地内存中的变量推送到主内存当中。</li>
<li>一个线程获得锁的时候，会将本地内存的变量设置为无效状态，强制从主内存中读取。</li>
</ul>
<p>可见，锁的内存语义和<strong>volatile</strong>的内存语义差不多，区别就是锁对于共享变量的刷新和重新读取是全局的，volatile是局部的。</p>
<h2 id="内存语义的实现"><a href="#内存语义的实现" class="headerlink" title="内存语义的实现"></a>内存语义的实现</h2><p>下篇再更新，可以先看这篇文章：<a href="http://blog.csdn.net/yuhongye111/article/details/39053067" target="_blank" rel="external">ReentrantLock源码分析</a></p>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h2><p>被final修饰的变量只要在构造器之内进行合理的初始化并且没有发生<a href="http://blog.csdn.net/flysqrlboy/article/details/10607295" target="_blank" rel="external">this引用逃逸</a>，那么此字段对其他线程来说就是可见的。</p>
<h2 id="写重排序规则"><a href="#写重排序规则" class="headerlink" title="写重排序规则"></a>写重排序规则</h2><p>对final域进行写入的重排序规则为：在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给另一个引用，这两个指令不能发生重排序。</p>
<p>如下代码：</p>
<pre><code>public class FinalExample {
    int i = 0;
    final int j;
    static FinalExample fe;

    public FinalExample() {
        i = 1;
        j = 1;
    }

    public static void writer() {
        fe = new FinalExample();
    }

    public static void reader() {
        FinalExample obj = fe; //1
        int a = obj.i; //2
        int b = obj.j; //3
    }
}
</code></pre><p>假设线程A执行writer函数，final的重排序规则保证了在对fe赋值之前j已经得到了合理的初始化，但是对于普通域而言，在fe被赋值时，i可能未被得到合理的初始化，原因是i = 1可能因为重排序的关系放在了构造函数之外。</p>
<h2 id="读重排序规则"><a href="#读重排序规则" class="headerlink" title="读重排序规则"></a>读重排序规则</h2><p>在一个线程中，初次读对象引用和读取对象的final域，这两条指令不能发生重排序。还是上面的代码，若线程B执行reader函数，假设此时fe已经不是null，那么1和3操作就不能发生重排序，b的值便是j的值。但是对于普通域i来说情况就不一定了，因为此时i可能因为重排序的关系，初始化过程还没有进行。</p>
<h2 id="final引用类型"><a href="#final引用类型" class="headerlink" title="final引用类型"></a>final引用类型</h2><p>对于引用类型，final重排序规则如下：</p>
<p>在构造器内对final引用进行修改，与之后将此被构造对象赋值给其他引用，这两个操作不能发生重排序。例如：</p>
<pre><code>public class FinalExample {
    final int[] finalArrayReference;
    static FinalExample fe;

    public FinalExample() {
        finalArrayReference = new int[10];
        finalArrayReference[0] = 1;
    }

    public static void writer() {
        fe = new FinalExample();
    }
}
</code></pre><p>此时若有线程A执行writer函数，那么对于此时fe的finalArrayReference域不为空，其第一个位置的值也得到了初始化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/10/Java内存模型-一/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/10/Java内存模型-一/" itemprop="url">
                  Java内存模型(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-10T20:06:10+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/10/Java内存模型-一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/10/Java内存模型-一/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>一下部分文字图片来自《Java并发编程的艺术》</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JMM(Java Memory Model),即Java内存模型，是Java实现并发的主要机制。多个线程通过JMM共享程序公有状态进而实现隐式通信。</p>
<h1 id="抽象结构"><a href="#抽象结构" class="headerlink" title="抽象结构"></a>抽象结构</h1><p>程序的公有状态，共享变量等储存在主内存(Main Memory)当中。每个线程都有一个本地内存(Local Memory)来储存主内存中共享变量的副本，其结构如下图所示：<br><img src="http://cdn.infoqstatic.com/statics_s1_20170228-0434_4/resource/articles/java-memory-model-1/zh/resources/11.png" alt=""><br>（本图作者为Java资深软件工程师：<a href="http://ifeve.com/author/25622818/" target="_blank" rel="external">程晓明</a>）</p>
<p>此时两个线程A,B的通信流程为：</p>
<ul>
<li>线程A更新本地内存中共享变量的副本，并将其写入主内存。</li>
<li>线程B从主内存中读取更新过的共享变量。</li>
</ul>
<h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><p>重排序是指为了提高程序运行的性能，充分利用并行，来对指令进行重新排序，主要分为编译器优化重排序和指令级并行重排序。关于重排序的更多理解，参见：<a href="http://blog.hesey.net/2011/07/reordering.html" target="_blank" rel="external">理解重排序</a></p>
<h2 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h2><p>数据依赖性分为三种情况：</p>
<ul>
<li>写后读，对一个变量写之后再进行读取。</li>
<li>读后写，对一个变量读取之后再进行写入。</li>
<li>写后写，对一个变量写之后再进行写入。</li>
</ul>
<p>以上三种情况若两个指令发生了重排序，则产生的结果与预期不一致，称以上三个指令对两指令之间存在数据依赖性，存在数据依赖性的两个指令不会发生重排序。</p>
<h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><p><strong>as-if-serial</strong>的含义是指，对于一个单线程而言，无论怎么重排序，其结果与顺序执行的结果一致。为了遵循这个原则，在单线程环境中，如果两个指令指令之间存在数据依赖性，那么这两个指令便不会发生重排序。</p>
<h2 id="对多线程的影响"><a href="#对多线程的影响" class="headerlink" title="对多线程的影响"></a>对多线程的影响</h2><p>假设有以下程序：</p>
<pre><code>public class RecorderExample {
    private boolean flag = false;
    private int i = 0;

    public void write() {
        i = 1;       //1
        flag = true; //2
    }

    public void read() {
        if (flag) {
            int a = i * i; 
        }
    }

    public static void main(String[] args) {
        RecorderExample re = new RecorderExample();
        new Thread(re::write).start();
        new Thread(re::read).start();
    }
}
</code></pre><p>在第一个线程里面，1、2指令由于没有数据依赖，所以可以进行重排序，若两个进行了重排序，<strong>flag</strong>设置成true之后，切换到第二个线程进行条件判断，判断完成后对a进行赋值，此时变量<strong>i</strong>并没有进行设置，所以会发生异常的结果，也就是说，<strong>重排序会破坏多线程的语义</strong>。</p>
<h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>它指的是一组用来实现对内存操作的顺序限制的处理器指令，会根据需求禁止特定类型的重排序。先假定这样一个事实：内存数据被推送到缓冲区，就会有消息协议来保证缓存和内存的数据一致性，这种尽快保证数据可见性的技术称为内存屏障。</p>
<p>内存屏障有三种类型：</p>
<ul>
<li>Store屏障：在该屏障之前的Store指令都会被执行，即写操作都会刷新到主内存当中去。</li>
<li>Load屏障，在该屏障之后的load指令在该屏障之后执行，保证了处理器缓存加载成功后进行读操作。</li>
<li>Full Barrier:即结合了上述两种屏障功能的屏障。</li>
</ul>
<p>一个比较典型的例子是Java当中的<strong>volatile</strong>关键字，对<strong>volatile</strong>变量写指令的后面会加上store屏障，对<strong>volatile</strong>变量读命令的前面会加上load屏障。</p>
<p>关于内存屏障的更多内容，参见<a href="http://www.infoq.com/cn/articles/memory_barriers_jvm_concurrency" target="_blank" rel="external">内存屏障与JVM并发</a></p>
<h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h1><p>如果一个操作的结果对另一个操作是可见的，那么这两个操作必须遵循<strong>happens-before</strong>关系。在这里两个操作可以在同一个线程里面，也可以在不同的线程里面，常见的规则如下：</p>
<ul>
<li>单个线程中的操作，happens-before于其后续操作。</li>
</ul>
<p>这句话很好理解，假定单个线程中的两条指令不存在数据依赖性，那这两条指令则不满足<strong>happens-before</strong>的先决条件；若存在数据的依赖性，则一条指令必定发生在另一条之前。</p>
<ul>
<li>对一个锁的解锁，happens-before于对这个锁的加锁。</li>
<li>对一个<strong>volatile</strong>写操作happens-before于对这个变量的读操作。</li>
</ul>
<h1 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h1><p>是一个理想化的理论模型，主要有两大特征：</p>
<ul>
<li>单个线程的操作必须按照程序的顺序来执行。</li>
<li>每个线程都只有一个单一的执行序列（不管是否同步），且每个操作必须立刻对所有线程可见。</li>
</ul>
<h2 id="JVM的实现"><a href="#JVM的实现" class="headerlink" title="JVM的实现"></a>JVM的实现</h2><h3 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h3><p>还是刚才的RecorderExample,现在修改如下：</p>
<pre><code>public class RecorderExample {
    private boolean flag = false;
    private int i = 0;

    public synchronized void write() {
        i = 1; //1
        flag = true; //2
    }

    public synchronized void read() {
        if (flag) {
            int a = i * i;
        }
    }

    public static void main(String[] args) {
        RecorderExample re = new RecorderExample();
        new Thread(re::write).start();
        new Thread(re::read).start();
    }
}
</code></pre><p>加上<strong>synchronized</strong>关键字之后，<strong>write</strong> happens-before <strong>read</strong>，但是在第一个线程当中，1和2操作是有可能被重排序的，但是对结果没有任何的影响，可以看成是和顺序一致性模型达到了相同的效果。</p>
<h3 id="非同步执行"><a href="#非同步执行" class="headerlink" title="非同步执行"></a>非同步执行</h3><p>非同步的执行结果无法预知，也没有什么实际意义。JVM对非同步执行只提供一种安全性，即在读一个变量的时候，要么是某个其他线程已经设置好的值，要么是零值，这里无需再做分析。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/02/SQL使用（一）/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/02/SQL使用（一）/" itemprop="url">
                  MySQL使用（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-02T21:37:05+08:00">
                2017-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/02/SQL使用（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/02/SQL使用（一）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>在这里我不想说这些无聊的配置内容（懒），在这里给出两个讲的不错的地址：</p>
<ul>
<li>Mac: <a href="http://www.jianshu.com/p/fd3aae701db9" target="_blank" rel="external">mac安装mysql的两种方法（含配置）</a></li>
<li>Windows: <a href="http://0000-bigtree.github.io/blog/2016/04/06/mysql-on-windows.html" target="_blank" rel="external">在 Windows 下安装 MySQL 5.7.11</a></li>
</ul>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>笔者喜欢用ide来进行开发，并且是JetBrains的忠实拥护者，特此向大家推荐一个JetBrains的SQL ide: <a href="https://www.jetbrains.com/datagrip/" target="_blank" rel="external">DataGrip</a></p>
<p>当然使用终端操作也不是不可以，这里还是要看个人的习惯。</p>
<p>打开DataGrip，这里不像其他ide，没有项目的概念。command + 1打开左边侧栏，command + N，依次选中Data Source, MySQL,配置如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-02%20%E4%B8%8B%E5%8D%8810.00.40.png" alt=""><br>⚠️注意：要先加载MySQL的启动文件才可正常运行</p>
<p>上图中host为localhost，端口默认3306，user和password可以用自带的root，也可以在终端启动MySQL，以root用户登录，新建一个用户，这里不再细谈，笔者直接用root用户进行操作。</p>
<p>打开之后，左侧栏如下图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-02%20%E4%B8%8B%E5%8D%8810.16.00.png" alt=""><br>从上到下依次是：数据库的根容器，数据库，表，表中的各个列。</p>
<p>要在某个数据库中进行操作，可以用两种办法，一种是在根标签（<strong>@localhost</strong>标签）上选中，右键，打开Console File，输入指令：</p>
<pre><code>USE Persons;
</code></pre><p>command + enter运行，即切换到Persons数据库进行工作。或者直接选中<strong>Persons</strong>标签，右键打开Console File，这时的工作环境便自动在<strong>Persons</strong>数据库之下了。</p>
<h2 id="创建、删除表"><a href="#创建、删除表" class="headerlink" title="创建、删除表"></a>创建、删除表</h2><p>表的创建：</p>
<pre><code>CREATE TABLE students (
  id             INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  name           VARCHAR(255),
  age            INT,
  grade          INT,
  class          INT,
  math_scores    FLOAT(3, 1),
  chinese_scores FLOAT(3, 1),
  englih_scores  FLOAT(3, 1),
  average_scores FLOAT(3, 1)
)
  CHARACTER SET = utf8;
</code></pre><p>MySQL的数据类型实在是太多，下面三张图摘自w3cschool:</p>
<p><img src="http://ok34fi9ya.bkt.clouddn.com/text_type.png" alt=""><br><img src="http://ok34fi9ya.bkt.clouddn.com/num_type.png" alt=""><br><img src="http://ok34fi9ya.bkt.clouddn.com/date_type.png" alt=""><br>至于<strong>NOT NULL, AUTO_INCREMENT, PRIMARY KEY</strong>后面再讲。</p>
<p>⚠️注意：上面代码中最后一行的<strong>CHARACTER SET = utf8</strong>是告诉MySQL此表使用utf8进行编码，因为MySQL默认不支持中文字体。</p>
<p>表的删除：</p>
<pre><code>DROP TABLE temp;
</code></pre><h2 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h2><p>此指令用于向表中插入数据，用法如下：</p>
<pre><code>INSERT INTO students (name, age, grade, class, math_scores, chinese_scores, englih_scores, average_scores)
VALUES (&apos;张师睿&apos;, 19, 2, 3, 127, 127, 138, (127 + 127 + 138) / 3.0);
</code></pre><p>注意两个括号里面的键值要一一对应，凡是在声明时标注<strong>NOT NULL</strong>的是必须要填的（PRIMARY KEY除外）。</p>
<h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p>此指令用于更新表中的数据，用法如下：</p>
<pre><code>UPDATE students SET grade = 3 WHERE name = &apos;张师睿&apos;;
</code></pre><p>SET后面是要更新的column和对应的新值，WHERE子句用来指定一个条件。</p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>此指令用于删除表中的行，用法如下：</p>
<pre><code>DELETE FROM students WHERE id = 2;
</code></pre><p>同样的WHERE指明了一个限定的条件，如果没有WHERE子句的话，那么此表中所有的行都将被删去，因此用此指令时不要忘记添加WHERE子句。</p>
<h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p>此指令用于查询表中的数据，用法如下：</p>
<pre><code>SELECT [DISTINCT] 列名称 FROM 表名称 [WHERE子句];
</code></pre><p>⚠️注意：DISTINCT关键字的作用是选出唯一的列值，因为对于某一列，多个行可能具有相同的值。</p>
<p>如：进行如下操作</p>
<pre><code>SELECT * FROM students;
</code></pre><p>结果：</p>
<p><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-02%20%E4%B8%8B%E5%8D%8811.28.46.png" alt=""><br>⚠️注意：SELECT *是取表中所有的列。</p>
<h2 id="ALERT"><a href="#ALERT" class="headerlink" title="ALERT"></a>ALERT</h2><p>此指令用于更改表的性质，例如：增加、删除列，改变列的值类型。用法如下：</p>
<p>增加列：</p>
<pre><code>ALERT TABLE 表名 ADD 列名 值类型;
</code></pre><p>删除列：</p>
<pre><code>ALTER TABLE 表名 DROP COLUMN 列名;
</code></pre><p>改变列的值类型：</p>
<pre><code>ALTER TABLE 表名 MODIFY 列名 值类型;
</code></pre><p>⚠️注意：更改列值类型的指令仅适用于MySQL!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/lion.jpg"
               alt="Stephen Zhang" />
          <p class="site-author-name" itemprop="name">Stephen Zhang</p>
          <p class="site-description motion-element" itemprop="description">Stephen Zhang's notes.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Zhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zsrcodingme"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
