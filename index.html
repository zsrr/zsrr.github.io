<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Stephen Zhang&apos;s notes.">
<meta property="og:type" content="website">
<meta property="og:title" content="Stephen's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Stephen's blog">
<meta property="og:description" content="Stephen Zhang&apos;s notes.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stephen's blog">
<meta name="twitter:description" content="Stephen Zhang&apos;s notes.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Stephen's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Stephen's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/14/使用Fork-Join架构进行归并排序/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/使用Fork-Join架构进行归并排序/" itemprop="url">
                  使用Fork/Join架构进行归并排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-14T23:37:51+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/使用Fork-Join架构进行归并排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/使用Fork-Join架构进行归并排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>以下部分文字，图片摘自《Java并发编程的艺术》</p>
<h1 id="Fork-Join框架简介"><a href="#Fork-Join框架简介" class="headerlink" title="Fork/Join框架简介"></a>Fork/Join框架简介</h1><p>Fork/Join框架是jdk7中提供的并行框架，其主要的特点是把一个大任务分割成几块不同的小任务，由不同的线程去执行这一系列的小任务，最终结果合并成大任务的结果。</p>
<p>其主要原理如图所示：<br><img src="http://cdn.infoqstatic.com/statics_s1_20170314-0434/resource/articles/fork-join-introduction/zh/resources/21.png" alt=""></p>
<h1 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h1><p>工作窃取算法的意思是每个线程的任务队列执行完毕之后，此线程会将其他线程的任务队列中的任务“窃取”到本线程的任务队列中来。使用窃取算法的好处就是充分利用了线程的并行计算，有关工作窃取算法的更多内容，请看：<a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="external">Work Stealing</a></p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>再实际应用上，要首先确定一个大的任务是否能够分成几个小的任务，是否能把小任务的结果进行合并，这样就自然而然的想到递归。下面笔者实现一个用Fork/Join架构实现的归并排序算法：</p>
<pre><code>public class ForkJoinPractice {
    static class SortTask&lt;T extends Comparable&lt;T&gt;&gt; extends RecursiveAction {
        T[] array;
        int start;
        int end;
        int mid;

        public SortTask(T[] array, int start, int end) {
            this.array = array;
            this.start = start;
            this.end = end;
            this.mid = (this.start + this.end) / 2;
        }

        @Override
        protected void compute() {
            int mid;
            if (start &lt; end) {
                mid = (start + end) / 2;
                //将任务分解
                invokeAll(new SortTask&lt;T&gt;(array, start, mid), new SortTask&lt;T&gt;(array, mid + 1, end));
                merge();
            }
        }

        private void merge() {
            int n1 = mid - start + 1;
            int n2 = end - mid;
            int i, j, k;

            List&lt;T&gt; leftList = new ArrayList&lt;&gt;(n1);
            List&lt;T&gt; rightList = new ArrayList&lt;&gt;(n2);

            for (i = 0; i &lt; n1; i++) {
                leftList.add(array[start + i]);
            }

            for (j = 0; j &lt; n2; j++) {
                rightList.add(array[mid + 1 + j]);
            }

            i = j = 0;
            k = start;

            while (i &lt; n1 &amp;&amp; j &lt; n2) {
                if (leftList.get(i).compareTo(rightList.get(j)) &lt; 0) {
                    array[k++] = leftList.get(i++);
                } else {
                    array[k++] = rightList.get(j++);
                }
            }

            while (i &lt; n1) {
                array[k++] = leftList.get(i++);
            }

            while (j &lt; n2) {
                array[k++] = rightList.get(j++);
            }
        }
    }

    public static void main(String[] args) {
        Integer[] array = new Integer[90];
        for (int i = 0; i &lt; 90; i++) {
            array[i] = 90 - i;
        }

        SortTask&lt;Integer&gt; sortTask = new SortTask&lt;&gt;(array, 0, array.length - 1);
        ForkJoinPool pool = new ForkJoinPool();
        pool.submit(sortTask);
        try {
            //等待任务结束
            pool.awaitTermination(3, TimeUnit.SECONDS);
            pool.shutdown();
            for (int i :  array) {
                System.out.println(i);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/Java并发编程-一/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/Java并发编程-一/" itemprop="url">
                  Java并发编程(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-13T18:46:34+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/13/Java并发编程-一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/13/Java并发编程-一/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="多线程简介"><a href="#多线程简介" class="headerlink" title="多线程简介"></a>多线程简介</h1><p>线程是现代操作系统调度的最小单元，一个进程可以包含很多线程。在Java的内存区域里面，每一个线程都有自己的程序计数器和虚拟机栈。处理器通过时间切片的方法在各个线程之间来回切换，可以用下面的代码查看JVM运行时各个线程的信息：</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) {
        ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();
        ThreadInfo[] threadInfoArray = mxBean.dumpAllThreads(false, false);

        for (ThreadInfo info : threadInfoArray) {
            System.out.println(&quot;Thread id: &quot; + info.getThreadId() + &quot; Thread name: &quot; +
                    info.getThreadName() + &quot; Thread state: &quot; + info.getThreadState());
        }
    }
}
</code></pre><p>运行结果如下：</p>
<pre><code>Thread id: 9 Thread name: Monitor Ctrl-Break Thread state: RUNNABLE
Thread id: 4 Thread name: Signal Dispatcher Thread state: RUNNABLE
Thread id: 3 Thread name: Finalizer Thread state: WAITING
Thread id: 2 Thread name: Reference Handler Thread state: WAITING
Thread id: 1 Thread name: main Thread state: RUNNABLE
</code></pre><p>也就是说，运行main函数时，不只是main线程在运行，Java天生就是多线程的。</p>
<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>在Java程序里面，线程的优先级通过<strong>setPriority(int priority)</strong>来设置，<strong>priority</strong>的取值范围为1-10，默认为5，线程的优先级越高，处理器对此线程所切的时间片越长，但是不同的操作系统的表现不同，有些会忽略掉线程的优先级，因此，设置优先级不会保证多线程程序的正确性，在实际编程过程中不应该使用。</p>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>线程的状态分为以下几种：</p>
<ul>
<li><strong>NEW</strong> 被创建成功，还没有调用<strong>start()</strong>方法。</li>
<li><strong>RUNNABLE</strong> 正在运行中。</li>
<li><strong>BLOCKED</strong> 正在处于阻塞状态。</li>
<li><strong>WAITING</strong> 等待状态，此线程在等待其他线程做出特定的动作。</li>
<li><strong>TIME_WAITING</strong> 超时等待状态。</li>
<li><strong>TERMINATED</strong> 终止，线程结束。</li>
</ul>
<p>拿上面的运行结果的线程名为<strong>Finalizer</strong>的线程来说，运行时处于<strong>WAITING</strong>状态，它在等待有对象进入它内部持有的<strong>ReferenceQueue</strong>，并执行清理动作，有关Finalizer的更多信息，查看：<a href="http://blog.csdn.net/rsljdkt/article/details/12242007" target="_blank" rel="external">GC执行finalize的过程</a></p>
<p>为了说明各大状态，我先用开几个线程，然后用<a href="http://blog.csdn.net/fenglibing/article/details/6411940" target="_blank" rel="external">jstack</a>指令查看各线程的状态。</p>
<p>代码如下：</p>
<pre><code>class SleepUtils {
    public static void sleep(int millionSeconds) {
        try {
            Thread.sleep(millionSeconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class ThreadStateTest {

    static class TimeWaitingThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                SleepUtils.sleep(100);
            }
        }
    }

    static class PauseThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                long current = System.currentTimeMillis();
                while (System.currentTimeMillis() - current &lt;= 3000);
            }
        }
    }

    static class Waiting implements Runnable {
        @Override
        public void run() {
            while (true) {
                synchronized (Waiting.class) {
                    try {
                        Waiting.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    static class Block implements Runnable {
        @Override
        public void run() {
            synchronized (Block.class) {
                while (true) {
                    SleepUtils.sleep(4000);
                }
            }
        }
    }

    public static void main(String[] args) {
        new Thread(new TimeWaitingThread(), &quot;TimedWaitingThread&quot;).start();
        new Thread(new PauseThread(), &quot;PauseThread&quot;).start();
        new Thread(new Waiting(), &quot;WaitingThread&quot;).start();
        new Thread(new Block(), &quot;Block1&quot;).start();
        new Thread(new Block(), &quot;Block2&quot;).start();
    }
}
</code></pre><p>运行之后，先在终端运行<a href="http://blog.csdn.net/fenglibing/article/details/6411932" target="_blank" rel="external">jps</a>命令，结果如下：</p>
<pre><code>37729 
38982 Launcher
38983 AppMain
38986 Jps
</code></pre><p>其中<strong>AppMain</strong>就是刚才开启的进程pid，现在运行<strong>jstack 38983</strong>，运行结果如下（部分）：</p>
<pre><code>&quot;Block2&quot; #14 prio=5 os_prio=31 tid=0x00007fc65c835000 nid=0x5703 waiting for monitor entry [0x0000700002ba2000]
   java.lang.Thread.State: BLOCKED (on object monitor)
    at com.stephen.ThreadStateTest$Block.run(ThreadStateTest.java:58)
    - waiting to lock &lt;0x00000007956f6ea8&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Block)
    at java.lang.Thread.run(Thread.java:745)

&quot;Block1&quot; #13 prio=5 os_prio=31 tid=0x00007fc65d82a000 nid=0x5503 waiting on condition [0x0000700002a9f000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
    at java.lang.Thread.sleep(Native Method)
    at com.stephen.SleepUtils.sleep(ThreadStateTest.java:10)
    at com.stephen.ThreadStateTest$Block.run(ThreadStateTest.java:58)
    - locked &lt;0x00000007956f6ea8&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Block)
    at java.lang.Thread.run(Thread.java:745)

&quot;WaitingThread&quot; #12 prio=5 os_prio=31 tid=0x00007fc65d82f800 nid=0x5303 in Object.wait() [0x000070000299c000]
   java.lang.Thread.State: WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    - waiting on &lt;0x00000007956f37f0&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Waiting)
    at java.lang.Object.wait(Object.java:502)
    at com.stephen.ThreadStateTest$Waiting.run(ThreadStateTest.java:44)
    - locked &lt;0x00000007956f37f0&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Waiting)
    at java.lang.Thread.run(Thread.java:745)

&quot;PauseThread&quot; #11 prio=5 os_prio=31 tid=0x00007fc65e01e000 nid=0x5103 runnable [0x0000700002899000]
   java.lang.Thread.State: RUNNABLE
    at com.stephen.ThreadStateTest$PauseThread.run(ThreadStateTest.java:33)
    at java.lang.Thread.run(Thread.java:745)

&quot;TimedWaitingThread&quot; #10 prio=5 os_prio=31 tid=0x00007fc65c80e000 nid=0x4f03 waiting on condition [0x0000700002796000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
    at java.lang.Thread.sleep(Native Method)
    at com.stephen.SleepUtils.sleep(ThreadStateTest.java:10)
    at com.stephen.ThreadStateTest$TimeWaitingThread.run(ThreadStateTest.java:23)
    at java.lang.Thread.run(Thread.java:745)
</code></pre><p>现在来逐一解释：</p>
<ul>
<li><strong>Block2</strong>：由于<strong>Block1</strong>已经获得<strong>Block.class</strong>锁，所以此线程处于阻塞状态。</li>
<li><strong>Block1</strong>：此线程不断的进行睡眠，且睡眠操作具有时间限制，因此处在超时等待操作状态。</li>
<li><strong>WaitingThread</strong>：此线程在<strong>Waiting.class</strong>上等待，且没有时间限制，所以处在waiting状态。</li>
<li><strong>PauseThread</strong>：此线程和<strong>TimedWaitingThread</strong>线程达到的效果相同，但是实现的手段不同，没有调用<strong>Thread.sleep(int millionSeconds)</strong>方法，处在<strong>Runnable</strong>状态。</li>
<li><strong>TimedWaitingThread</strong>：此线程不断调用<strong>Thread.sleep(int millionSeconds)</strong>方法，处于超时等待状态。</li>
</ul>
<h1 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h1><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><p>其他线程可以调用另一个线程的<strong>interrupt()</strong>方法来中断线程，可以调用线程的<strong>isInterrupted()</strong>来判断一个线程是否被中断，但是这个方法不总是返回true:</p>
<ul>
<li>当线程终止时，此方法会返回false。</li>
<li>抛出<strong>InterruptedException</strong>的方法，在抛出异常之前，会将标识位设置为false，因此方法也总是返回false。</li>
</ul>
<p>现在用如下程序做出证明：</p>
<pre><code>public class InterruptTest {
    static class SleepThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                SleepUtils.sleep(3000);
            }
        }
    }

    static class NormalThread implements Runnable {
        @Override
        public void run() {
            while (true);
        }
    }

    public static void main(String[] args) {
        Thread sleepThread = new Thread(new SleepThread(), &quot;Sleep&quot;);
        Thread normalThread = new Thread(new NormalThread(), &quot;Normal&quot;);

        sleepThread.start();
        normalThread.start();

        SleepUtils.sleep(2000);

        sleepThread.interrupt();
        normalThread.interrupt();

        System.out.println(&quot;Sleep thread interrupted is &quot; + sleepThread.isInterrupted());
        System.out.println(&quot;Normal thread interrupted is &quot; + normalThread.isInterrupted());
    }
}
</code></pre><p>结果如下：</p>
<pre><code>Sleep thread interrupted is false    
Normal thread interrupted is true
</code></pre><h2 id="设置boolean变量"><a href="#设置boolean变量" class="headerlink" title="设置boolean变量"></a>设置boolean变量</h2><p>还可以设置boolean变量来通知线程的结束，这种方式比上面的<strong>interrupt</strong>方法更为优雅：</p>
<pre><code>public class BooleanFlagThread {
    static class CounterRunnable implements Runnable {
        long i = 0L;
        private volatile boolean isCancelled = false;

        public void cancel() {
            isCancelled = true;
        }

        @Override
        public void run() {
            while (!isCancelled &amp;&amp; !Thread.currentThread().isInterrupted()) {
                i++;
            }
        }
    }

    public static void main(String[] args) {
        CounterRunnable cr = new CounterRunnable();
        Thread countThread = new Thread(cr, &quot;Count&quot;);
        countThread.start();

        SleepUtils.sleep(2000);
        cr.cancel();

        System.out.println(&quot;&quot; + cr.i);
    }
}
</code></pre><h1 id="线程之间的通信：notify-wait"><a href="#线程之间的通信：notify-wait" class="headerlink" title="线程之间的通信：notify(), wait()"></a>线程之间的通信：notify(), wait()</h1><p>线程除了用<strong>synchronized</strong>,<strong>volatile</strong>来进行通信之外，还可以用notify和wait方法，使用这两个方法的前提是某个线程获取了相应对象的锁，典型应用的示例代码如下：</p>
<pre><code>public class NotifyWaitTest {
    static Object lock = new Object();
    static boolean flag = true;

    static class Wait implements Runnable {
        @Override
        public void run() {
            //获取对象的锁
            synchronized (lock) {
                while (flag) { // 2
                    System.out.println(&quot;不满足相应的条件&quot;);
                    try {
                        //进入wait状态，同时释放对象的锁
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(&quot;条件满足&quot;);
            }
        }
    }

    static class Notify implements Runnable {
        @Override
        public void run() {
            //获取对象的锁
            synchronized (lock) {
                if (flag) {
                    flag = false; // 1
                    //通知改变
                    lock.notify();
                }

                System.out.println(&quot;条件已改变&quot;);
            }
        }
    }

    public static void main(String[] args) {
        Thread waitThread = new Thread(new Wait(), &quot;Wait&quot;);
        Thread notifyThread = new Thread(new Notify(), &quot;Notify&quot;);
        waitThread.start();
        //保证wait先执行的方式
        SleepUtils.sleep(2000);
        notifyThread.start();
    }
}
</code></pre><p>输出的结果如下：</p>
<pre><code>不满足相应的条件
条件已改变
条件满足
</code></pre><p>需要注意的是：</p>
<ul>
<li>在调用notify, wait方法之前，要先获得对象的锁。</li>
<li>wait方法，会释放相应的锁。</li>
<li>notify方法会将调用wait的线程从等待队列到同步队列，此时wait线程将从WAITING状态转到BLOCK状态。</li>
<li>只有当notify的线程释放对象锁时，另一个wait线程才会返回继续工作。</li>
<li>notify和wait具有happens-before关系。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/Java内存模型-三/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/Java内存模型-三/" itemprop="url">
                  Java内存模型(三)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-13T18:44:31+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/13/Java内存模型-三/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/13/Java内存模型-三/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="双重检查锁解决方案"><a href="#双重检查锁解决方案" class="headerlink" title="双重检查锁解决方案"></a>双重检查锁解决方案</h1><p>Java程序有时需要用到单例模式，通常用延迟初始化的方式实现单例模式，但是只是简单的延迟初始化可能会有线程安全问题，例如：</p>
<pre><code>public class Instance {
    private static Instance instance;

    public static Instance getInstance() {
        if (instance == null) { //1
            instance = new Instance();
        }

        return instance;
    }
}
</code></pre><p>这段代码有很严重的问题，加入两个线程同时处于1操作并且判断instance为空的话，那么instance就会被初始化两次。</p>
<h2 id="synchronized解决方案"><a href="#synchronized解决方案" class="headerlink" title="synchronized解决方案"></a>synchronized解决方案</h2><p>解决上述问题最简单的方法便是用<strong>synchronized</strong>关键字标注<strong>getInstance</strong>方法：</p>
<pre><code>public synchronized static Instance getInstance() {
    if (instance == null) {
        instance = new Instance();
    }

    return instance;
}
</code></pre><p>此方法解决了多线程冲突的问题，但是如果线程太多且<strong>instance</strong>初始化过程太耗时的话，就会转成重量级锁，性能问题随之而来。</p>
<h2 id="双重检查锁定-Double-Checked-Lock"><a href="#双重检查锁定-Double-Checked-Lock" class="headerlink" title="双重检查锁定(Double Checked Lock)"></a>双重检查锁定(Double Checked Lock)</h2><p>为了解决性能的开销，采取了下述办法来解决：</p>
<pre><code>public class Instance {
    private static Instance instance;

    public static Instance getInstance() {
        if (instance == null) { //1
            synchronized (Instance.class) { //2
                if (instance == null) { //3
                    instance = new Instance();
                }
            }
        }

        return instance;
    }
}
</code></pre><p>采用上述办法不能完美地解决问题，出现的问题是返回的引用可能指向一个未被完全正确初始化的对象，下面来分析一下。</p>
<p>假设初始有两个线程A,B同时调用<strong>getInstance</strong>方法，判断instance为空之后开始竞争<strong>Instance</strong>锁，设B线程首先获得了锁，并在成功初始化<strong>instance</strong>对象之后释放锁，此时线程A再获取锁，根据happens-before关系，此时线程A对<strong>instance</strong>对象的改变是可以看到的，因此整个过程只初始化了一次，截止到现在是没有问题的。</p>
<h3 id="对象的初始化过程"><a href="#对象的初始化过程" class="headerlink" title="对象的初始化过程"></a>对象的初始化过程</h3><p>上述办法的问题来自于对象初始化过程的重排序，<strong>instance</strong>初始化可以分成以下三个过程：</p>
<ul>
<li>分配对象的存储空间。</li>
<li>进行初始化。</li>
<li>将对象的地址赋值给引用。</li>
</ul>
<p>问题来自于第二步和第三步的重排序。加入现在有两个线程A,B同时执行，B 先获得了锁先执行，此时A执行到上面的1操作，但是B线程此刻已经把对象地址赋值给了引用，但是并没有正确的初始化（3和1不具备happens-before）关系，此刻A线程读到的<strong>instance</strong>引用是不为空的，但是对象并没有正确的初始化，便即刻将其暴露给外部，问题就出现了。</p>
<h3 id="基于volatile的解决方案"><a href="#基于volatile的解决方案" class="headerlink" title="基于volatile的解决方案"></a>基于volatile的解决方案</h3><p>在<strong>instance</strong>对象前面加上<strong>volatile</strong>关键字可以禁止上述初始化过程的重排序：</p>
<pre><code>public class Instance {
    private volatile static Instance instance;

    public static Instance getInstance() {
        if (instance == null) {
            synchronized (Instance.class) {
                if (instance == null) {
                    instance = new Instance();
                }
            }
        }

        return instance;
    }
}
</code></pre><p><strong>volatile</strong>关键字保证了读取到引用不为空时对象已经被正确地初始化，问题解决。</p>
<h3 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h3><pre><code>public class Instance {
    private static class InstanceHolder {
        private static Instance instance = new Instance();
    }

    public static Instance getInstance() {
        return InstanceHolder.instance;
    }
}
</code></pre><p>此种方法适合包含无参构造函数的类的单例模式，原理如下：</p>
<p>假设有两个线程A,B当两个线程同时开始访问<strong>Instance</strong>类的时候，开始类的初始化，此时JVM将尝试获取<strong>Instance</strong>类上的锁，防止多个线程同时初始化。</p>
<p>假定线程B获取了初始化的锁，当执行完<strong>instance = new Instance()</strong>语句时，释放锁，线程A执行时将会看到已经初始化的<strong>instance</strong>实例并将其返回，初始化过程的重排序对于线程A此时是不可见的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/11/Java内存模型-二/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/11/Java内存模型-二/" itemprop="url">
                  Java内存模型(二)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-11T11:08:01+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/11/Java内存模型-二/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/11/Java内存模型-二/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>volatile</strong>的典型特性之一是一个线程对<strong>volatile</strong>变量的写入对其他线程来说是立即可见的。假设有以下程序：</p>
<pre><code>public class VolatileFeaturesExample {
    private volatile int a;

    public int getA() {
        return a;
    }

    public void setA(int a) {
        this.a = a;
    }
}
</code></pre><p>与下面这段代码的执行效果是等效的：</p>
<pre><code>public class VolatileFeaturesExample {
    private int a;

    public synchronized void setA(int a) {
        this.a = a;
    }

    public synchronized int getA() {
        return a;
    }
}
</code></pre><p>根据happens-before规则，锁的解锁happens before于此锁被加锁之前，所以一个线程对<strong>a</strong>变量的写入对另一个线程是可见的。</p>
<p>另外，锁的语义决定了<strong>volatile</strong>的读写具备原子性，也就是说即便对于<strong>long</strong>和<strong>double</strong>类型，只要有<strong>volatile</strong>关键字修饰，对其赋值也是原子操作。</p>
<h2 id="限制重排序"><a href="#限制重排序" class="headerlink" title="限制重排序"></a>限制重排序</h2><p>为了实现volatile的内存语义， JMM针对volatile变量制定了一套特殊的重排序规则，规则如下表：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-11%20%E4%B8%8B%E5%8D%884.22.57.png" alt=""></p>
<p>从图中可以看出：</p>
<ul>
<li>若第二个操作是对volatile对象的写操作，那么无论第一个操作是什么，都不会发生重排序。</li>
<li>若第一个操作是对volatile变量的读操作，那么无论第二个操作是什么，都不会发生重排序。</li>
</ul>
<p>上一篇博客曾经提到<strong>volatile</strong>的实现是通过增加内存屏障来实现的，针对<strong>volatile</strong>的内存屏障策略如下：</p>
<ul>
<li>在volatile变量写之前加入store屏障。</li>
<li>在volatile变量写之后加入store-load屏障。</li>
<li>在读操作的后面加上load屏障。</li>
<li>在读操作的后面加上load-store屏障。</li>
</ul>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><p>先看下面这段代码：</p>
<pre><code>public class LockExample {
    private int a;

    public synchronized void increase() { // 1
        a++; // 2
    } // 3

    public synchronized void get() { // 4
        int i = a; // 5
    } // 6
}
</code></pre><p>根据happens-before原则，1发生在2之前，2发生在3之前……最终得出的结论是2发生在5之前，也就是说，两个线程，线程1获得锁之后对所有共享变量的修改，对下一个线程获得锁的时候是可见的。</p>
<h2 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h2><p>锁的内存语义如下：</p>
<ul>
<li>一个线程释放锁，会将本地内存中的变量推送到主内存当中。</li>
<li>一个线程获得锁的时候，会将本地内存的变量设置为无效状态，强制从主内存中读取。</li>
</ul>
<p>可见，锁的内存语义和<strong>volatile</strong>的内存语义差不多，区别就是锁对于共享变量的刷新和重新读取是全局的，volatile是局部的。</p>
<h2 id="内存语义的实现"><a href="#内存语义的实现" class="headerlink" title="内存语义的实现"></a>内存语义的实现</h2><p>下篇再更新，可以先看这篇文章：<a href="http://blog.csdn.net/yuhongye111/article/details/39053067" target="_blank" rel="external">ReentrantLock源码分析</a></p>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h2><p>被final修饰的变量只要在构造器之内进行合理的初始化并且没有发生<a href="http://blog.csdn.net/flysqrlboy/article/details/10607295" target="_blank" rel="external">this引用逃逸</a>，那么此字段对其他线程来说就是可见的。</p>
<h2 id="写重排序规则"><a href="#写重排序规则" class="headerlink" title="写重排序规则"></a>写重排序规则</h2><p>对final域进行写入的重排序规则为：在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给另一个引用，这两个指令不能发生重排序。</p>
<p>如下代码：</p>
<pre><code>public class FinalExample {
    int i = 0;
    final int j;
    static FinalExample fe;

    public FinalExample() {
        i = 1;
        j = 1;
    }

    public static void writer() {
        fe = new FinalExample();
    }

    public static void reader() {
        FinalExample obj = fe; //1
        int a = obj.i; //2
        int b = obj.j; //3
    }
}
</code></pre><p>假设线程A执行writer函数，final的重排序规则保证了在对fe赋值之前j已经得到了合理的初始化，但是对于普通域而言，在fe被赋值时，i可能未被得到合理的初始化，原因是i = 1可能因为重排序的关系放在了构造函数之外。</p>
<h2 id="读重排序规则"><a href="#读重排序规则" class="headerlink" title="读重排序规则"></a>读重排序规则</h2><p>在一个线程中，初次读对象引用和读取对象的final域，这两条指令不能发生重排序。还是上面的代码，若线程B执行reader函数，假设此时fe已经不是null，那么1和3操作就不能发生重排序，b的值便是j的值。但是对于普通域i来说情况就不一定了，因为此时i可能因为重排序的关系，初始化过程还没有进行。</p>
<h2 id="final引用类型"><a href="#final引用类型" class="headerlink" title="final引用类型"></a>final引用类型</h2><p>对于引用类型，final重排序规则如下：</p>
<p>在构造器内对final引用进行修改，与之后将此被构造对象赋值给其他引用，这两个操作不能发生重排序。例如：</p>
<pre><code>public class FinalExample {
    final int[] finalArrayReference;
    static FinalExample fe;

    public FinalExample() {
        finalArrayReference = new int[10];
        finalArrayReference[0] = 1;
    }

    public static void writer() {
        fe = new FinalExample();
    }
}
</code></pre><p>此时若有线程A执行writer函数，那么对于此时fe的finalArrayReference域不为空，其第一个位置的值也得到了初始化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/10/Java内存模型-一/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/10/Java内存模型-一/" itemprop="url">
                  Java内存模型(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-10T20:06:10+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/10/Java内存模型-一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/10/Java内存模型-一/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JMM(Java Memory Model),即Java内存模型，是Java实现并发的主要机制。多个线程通过JMM共享程序公有状态进而实现隐式通信。</p>
<h1 id="抽象结构"><a href="#抽象结构" class="headerlink" title="抽象结构"></a>抽象结构</h1><p>程序的公有状态，共享变量等储存在主内存(Main Memory)当中。每个线程都有一个本地内存(Local Memory)来储存主内存中共享变量的副本，其结构如下图所示：<br><img src="http://cdn.infoqstatic.com/statics_s1_20170228-0434_4/resource/articles/java-memory-model-1/zh/resources/11.png" alt=""><br>（本图作者为Java资深软件工程师：<a href="http://ifeve.com/author/25622818/" target="_blank" rel="external">程晓明</a>）</p>
<p>此时两个线程A,B的通信流程为：</p>
<ul>
<li>线程A更新本地内存中共享变量的副本，并将其写入主内存。</li>
<li>线程B从主内存中读取更新过的共享变量。</li>
</ul>
<h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><p>重排序是指为了提高程序运行的性能，充分利用并行，来对指令进行重新排序，主要分为编译器优化重排序和指令级并行重排序。关于重排序的更多理解，参见：<a href="http://blog.hesey.net/2011/07/reordering.html" target="_blank" rel="external">理解重排序</a></p>
<h2 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h2><p>数据依赖性分为三种情况：</p>
<ul>
<li>写后读，对一个变量写之后再进行读取。</li>
<li>读后写，对一个变量读取之后再进行写入。</li>
<li>写后写，对一个变量写之后再进行写入。</li>
</ul>
<p>以上三种情况若两个指令发生了重排序，则产生的结果与预期不一致，称以上三个指令对两指令之间存在数据依赖性，存在数据依赖性的两个指令不会发生重排序。</p>
<h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><p><strong>as-if-serial</strong>的含义是指，对于一个单线程而言，无论怎么重排序，其结果与顺序执行的结果一致。为了遵循这个原则，在单线程环境中，如果两个指令指令之间存在数据依赖性，那么这两个指令便不会发生重排序。</p>
<h2 id="对多线程的影响"><a href="#对多线程的影响" class="headerlink" title="对多线程的影响"></a>对多线程的影响</h2><p>假设有以下程序：</p>
<pre><code>public class RecorderExample {
    private boolean flag = false;
    private int i = 0;

    public void write() {
        i = 1;       //1
        flag = true; //2
    }

    public void read() {
        if (flag) {
            int a = i * i; 
        }
    }

    public static void main(String[] args) {
        RecorderExample re = new RecorderExample();
        new Thread(re::write).start();
        new Thread(re::read).start();
    }
}
</code></pre><p>在第一个线程里面，1、2指令由于没有数据依赖，所以可以进行重排序，若两个进行了重排序，<strong>flag</strong>设置成true之后，切换到第二个线程进行条件判断，判断完成后对a进行赋值，此时变量<strong>i</strong>并没有进行设置，所以会发生异常的结果，也就是说，<strong>重排序会破坏多线程的语义</strong>。</p>
<h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>它指的是一组用来实现对内存操作的顺序限制的处理器指令，会根据需求禁止特定类型的重排序。先假定这样一个事实：内存数据被推送到缓冲区，就会有消息协议来保证缓存和内存的数据一致性，这种尽快保证数据可见性的技术称为内存屏障。</p>
<p>内存屏障有三种类型：</p>
<ul>
<li>Store屏障：在该屏障之前的Store指令都会被执行，即写操作都会刷新到主内存当中去。</li>
<li>Load屏障，在该屏障之后的load指令在该屏障之后执行，保证了处理器缓存加载成功后进行读操作。</li>
<li>Full Barrier:即结合了上述两种屏障功能的屏障。</li>
</ul>
<p>一个比较典型的例子是Java当中的<strong>volatile</strong>关键字，对<strong>volatile</strong>变量写指令的后面会加上store屏障，对<strong>volatile</strong>变量读命令的前面会加上load屏障。</p>
<p>关于内存屏障的更多内容，参见<a href="http://www.infoq.com/cn/articles/memory_barriers_jvm_concurrency" target="_blank" rel="external">内存屏障与JVM并发</a></p>
<h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h1><p>如果一个操作的结果对另一个操作是可见的，那么这两个操作必须遵循<strong>happens-before</strong>关系。在这里两个操作可以在同一个线程里面，也可以在不同的线程里面，常见的规则如下：</p>
<ul>
<li>单个线程中的操作，happens-before于其后续操作。</li>
</ul>
<p>这句话很好理解，假定单个线程中的两条指令不存在数据依赖性，那这两条指令则不满足<strong>happens-before</strong>的先决条件；若存在数据的依赖性，则一条指令必定发生在另一条之前。</p>
<ul>
<li>对一个锁的解锁，happens-before于对这个锁的加锁。</li>
<li>对一个<strong>volatile</strong>写操作happens-before于对这个变量的读操作。</li>
</ul>
<h1 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h1><p>是一个理想化的理论模型，主要有两大特征：</p>
<ul>
<li>单个线程的操作必须按照程序的顺序来执行。</li>
<li>每个线程都只有一个单一的执行序列（不管是否同步），且每个操作必须立刻对所有线程可见。</li>
</ul>
<h2 id="JVM的实现"><a href="#JVM的实现" class="headerlink" title="JVM的实现"></a>JVM的实现</h2><h3 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h3><p>还是刚才的RecorderExample,现在修改如下：</p>
<pre><code>public class RecorderExample {
    private boolean flag = false;
    private int i = 0;

    public synchronized void write() {
        i = 1; //1
        flag = true; //2
    }

    public synchronized void read() {
        if (flag) {
            int a = i * i;
        }
    }

    public static void main(String[] args) {
        RecorderExample re = new RecorderExample();
        new Thread(re::write).start();
        new Thread(re::read).start();
    }
}
</code></pre><p>加上<strong>synchronized</strong>关键字之后，<strong>write</strong> happens-before <strong>read</strong>，但是在第一个线程当中，1和2操作是有可能被重排序的，但是对结果没有任何的影响，可以看成是和顺序一致性模型达到了相同的效果。</p>
<h3 id="非同步执行"><a href="#非同步执行" class="headerlink" title="非同步执行"></a>非同步执行</h3><p>非同步的执行结果无法预知，也没有什么实际意义。JVM对非同步执行只提供一种安全性，即在读一个变量的时候，要么是某个其他线程已经设置好的值，要么是零值，这里无需再做分析。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/02/SQL使用（一）/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/02/SQL使用（一）/" itemprop="url">
                  MySQL使用（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-02T21:37:05+08:00">
                2017-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/02/SQL使用（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/02/SQL使用（一）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>在这里我不想说这些无聊的配置内容（懒），在这里给出两个讲的不错的地址：</p>
<ul>
<li>Mac: <a href="http://www.jianshu.com/p/fd3aae701db9" target="_blank" rel="external">mac安装mysql的两种方法（含配置）</a></li>
<li>Windows: <a href="http://0000-bigtree.github.io/blog/2016/04/06/mysql-on-windows.html" target="_blank" rel="external">在 Windows 下安装 MySQL 5.7.11</a></li>
</ul>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>笔者喜欢用ide来进行开发，并且是JetBrains的忠实拥护者，特此向大家推荐一个JetBrains的SQL ide: <a href="https://www.jetbrains.com/datagrip/" target="_blank" rel="external">DataGrip</a></p>
<p>当然使用终端操作也不是不可以，这里还是要看个人的习惯。</p>
<p>打开DataGrip，这里不像其他ide，没有项目的概念。command + 1打开左边侧栏，command + N，依次选中Data Source, MySQL,配置如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-02%20%E4%B8%8B%E5%8D%8810.00.40.png" alt=""><br>⚠️注意：要先加载MySQL的启动文件才可正常运行</p>
<p>上图中host为localhost，端口默认3306，user和password可以用自带的root，也可以在终端启动MySQL，以root用户登录，新建一个用户，这里不再细谈，笔者直接用root用户进行操作。</p>
<p>打开之后，左侧栏如下图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-02%20%E4%B8%8B%E5%8D%8810.16.00.png" alt=""><br>从上到下依次是：数据库的根容器，数据库，表，表中的各个列。</p>
<p>要在某个数据库中进行操作，可以用两种办法，一种是在根标签（<strong>@localhost</strong>标签）上选中，右键，打开Console File，输入指令：</p>
<pre><code>USE Persons;
</code></pre><p>command + enter运行，即切换到Persons数据库进行工作。或者直接选中<strong>Persons</strong>标签，右键打开Console File，这时的工作环境便自动在<strong>Persons</strong>数据库之下了。</p>
<h2 id="创建、删除表"><a href="#创建、删除表" class="headerlink" title="创建、删除表"></a>创建、删除表</h2><p>表的创建：</p>
<pre><code>CREATE TABLE students (
  id             INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  name           VARCHAR(255),
  age            INT,
  grade          INT,
  class          INT,
  math_scores    FLOAT(3, 1),
  chinese_scores FLOAT(3, 1),
  englih_scores  FLOAT(3, 1),
  average_scores FLOAT(3, 1)
)
  CHARACTER SET = utf8;
</code></pre><p>MySQL的数据类型实在是太多，下面三张图摘自w3cschool:</p>
<p><img src="http://ok34fi9ya.bkt.clouddn.com/text_type.png" alt=""><br><img src="http://ok34fi9ya.bkt.clouddn.com/num_type.png" alt=""><br><img src="http://ok34fi9ya.bkt.clouddn.com/date_type.png" alt=""><br>至于<strong>NOT NULL, AUTO_INCREMENT, PRIMARY KEY</strong>后面再讲。</p>
<p>⚠️注意：上面代码中最后一行的<strong>CHARACTER SET = utf8</strong>是告诉MySQL此表使用utf8进行编码，因为MySQL默认不支持中文字体。</p>
<p>表的删除：</p>
<pre><code>DROP TABLE temp;
</code></pre><h2 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h2><p>此指令用于向表中插入数据，用法如下：</p>
<pre><code>INSERT INTO students (name, age, grade, class, math_scores, chinese_scores, englih_scores, average_scores)
VALUES (&apos;张师睿&apos;, 19, 2, 3, 127, 127, 138, (127 + 127 + 138) / 3.0);
</code></pre><p>注意两个括号里面的键值要一一对应，凡是在声明时标注<strong>NOT NULL</strong>的是必须要填的（PRIMARY KEY除外）。</p>
<h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p>此指令用于更新表中的数据，用法如下：</p>
<pre><code>UPDATE students SET grade = 3 WHERE name = &apos;张师睿&apos;;
</code></pre><p>SET后面是要更新的column和对应的新值，WHERE子句用来指定一个条件。</p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>此指令用于删除表中的行，用法如下：</p>
<pre><code>DELETE FROM students WHERE id = 2;
</code></pre><p>同样的WHERE指明了一个限定的条件，如果没有WHERE子句的话，那么此表中所有的行都将被删去，因此用此指令时不要忘记添加WHERE子句。</p>
<h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p>此指令用于查询表中的数据，用法如下：</p>
<pre><code>SELECT [DISTINCT] 列名称 FROM 表名称 [WHERE子句];
</code></pre><p>⚠️注意：DISTINCT关键字的作用是选出唯一的列值，因为对于某一列，多个行可能具有相同的值。</p>
<p>如：进行如下操作</p>
<pre><code>SELECT * FROM students;
</code></pre><p>结果：</p>
<p><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-02%20%E4%B8%8B%E5%8D%8811.28.46.png" alt=""><br>⚠️注意：SELECT *是取表中所有的列。</p>
<h2 id="ALERT"><a href="#ALERT" class="headerlink" title="ALERT"></a>ALERT</h2><p>此指令用于更改表的性质，例如：增加、删除列，改变列的值类型。用法如下：</p>
<p>增加列：</p>
<pre><code>ALERT TABLE 表名 ADD 列名 值类型;
</code></pre><p>删除列：</p>
<pre><code>ALTER TABLE 表名 DROP COLUMN 列名;
</code></pre><p>改变列的值类型：</p>
<pre><code>ALTER TABLE 表名 MODIFY 列名 值类型;
</code></pre><p>⚠️注意：更改列值类型的指令仅适用于MySQL!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/26/Android自定义字体解决方案/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/26/Android自定义字体解决方案/" itemprop="url">
                  Android自定义字体解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-26T16:04:26+08:00">
                2017-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/26/Android自定义字体解决方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/26/Android自定义字体解决方案/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在安卓开发中我们通常需要自定义字体，下面笔者给出两种解决方案，以供参考。</p>
<h1 id="利用反射"><a href="#利用反射" class="headerlink" title="利用反射"></a>利用反射</h1><p>这种方案通常情况下适用于替换整个app的默认字体，方法是利用反射更改<strong>Typeface</strong>类的静态<strong>DEFAULT</strong>成员，如下所示：</p>
<pre><code>public class MyApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        Typeface typeface = Typeface.createFromAsset(getAssets(), &quot;fonts/CourierNewBold.ttf&quot;);
        try {
            Field field = Typeface.class.getDeclaredField(&quot;MONOSPACE&quot;);
            field.setAccessible(true);
            field.set(null, typeface);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
            Log.e(&quot;Application&quot;, &quot;Error happened!&quot;);
        }
    }
}
</code></pre><p>style文件：</p>
<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;android:Theme.Holo.Light.DarkActionBar&quot;&gt;
    &lt;!-- Customize your theme here. --&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name=&quot;android:typeface&quot;&gt;monospace&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>运行效果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/Screenshot_1488099698.png" alt=""><br>这种方法的局限也很明显，就是在Android 5.0默认主题之上并不能运行，需要更换一个旧的主题，如果主题不是很重要的话，这种方法就比较合适了。</p>
<h1 id="利用DataBinding"><a href="#利用DataBinding" class="headerlink" title="利用DataBinding"></a>利用DataBinding</h1><p>这是笔者认为最快速，最便捷的方法了，用<strong>BindingAdapters</strong>注解标注方法即可在xml文件中指定<strong>Typeface</strong>，方法如下：</p>
<p>MyApplication:</p>
<pre><code>public class MyApplication extends Application {

    public static final Map&lt;String, Typeface&gt; FONTS_MAP = new HashMap&lt;&gt;();

    @Override
    public void onCreate() {
        super.onCreate();

        FONTS_MAP.put(getString(R.string.courier_new_bold),
                Typeface.createFromAsset(getAssets(), &quot;fonts/&quot; +
                        getString(R.string.courier_new_bold)));
        FONTS_MAP.put(getString(R.string.lao_sangam_mn),
                Typeface.createFromAsset(getAssets(), &quot;fonts/&quot; +
                        getString(R.string.lao_sangam_mn)));
        FONTS_MAP.put(getString(R.string.microsoft_sans_serif),
                Typeface.createFromAsset(getAssets(), &quot;fonts/&quot; +
                        getString(R.string.microsoft_sans_serif)));
    }
}
</code></pre><p>FontsUtils:</p>
<pre><code>public class FontsUtils {
    @BindingAdapter({&quot;fonts&quot;})
    public static void setTextViewFonts(TextView tv, String fontName) {
        tv.setTypeface(MyApplication.FONTS_MAP.get(fontName));
    }
}
</code></pre><p>xml:</p>
<pre><code>&lt;layout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
    &lt;data&gt;
        &lt;import type=&quot;com.stephen.customfontdemo.FontsUtils&quot;/&gt;
    &lt;/data&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:id=&quot;@+id/activity_main&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:padding=&quot;16dp&quot;
        android:orientation=&quot;vertical&quot;
        tools:context=&quot;com.stephen.customfontdemo.MainActivity&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;测试字体1&quot;
            app:fonts=&quot;@{@string/courier_new_bold}&quot;/&gt;
        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;测试字体2&quot;
            app:fonts=&quot;@{@string/lao_sangam_mn}&quot;/&gt;
        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;测试字体3&quot;
            app:fonts=&quot;@{@string/microsoft_sans_serif}&quot;/&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre><p>运行效果：<img src="http://ok34fi9ya.bkt.clouddn.com/Screenshot_1488100937.png" alt=""><br>额……可能2和3看不出效果，不过确实已经更改了。</p>
<p>需要注意的是： <strong>Typeface</strong>的加载要放在Application类当中，或者放在另一个线程当中进行，因为它是一个比较耗时的操作，如果大量的<strong>TextView</strong>用到自定义字体会造成卡顿。</p>
<p>这样在需要自定义字体时，只需要在<strong>FONTS_MAP</strong>和strings.xml当中注册，在xml中一行代码即可指定！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/16/Mac-OS-Sierra下编译Android-7-1-1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/16/Mac-OS-Sierra下编译Android-7-1-1/" itemprop="url">
                  Mac OS Sierra下编译Android 7.1.1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-16T19:46:37+08:00">
                2017-02-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/16/Mac-OS-Sierra下编译Android-7-1-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/16/Mac-OS-Sierra下编译Android-7-1-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要编译源码"><a href="#为什么要编译源码" class="headerlink" title="为什么要编译源码"></a>为什么要编译源码</h1><p>安卓进阶的最好方式就是Read the fucking source code!不去研究源码的程序员不是好程序员，呵呵呵……好吧，其实笔者要编译源码的原因是因为想研究DataBinding源码结果发现自带的sdk看不到核心逻辑，而笔者却是一个处女座……</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="配置repo"><a href="#配置repo" class="headerlink" title="配置repo"></a>配置repo</h2><p>repo是google为了方便Android源代码的管理，用一系列Python脚本封装git命令做成的工具，具体的请看：<a href="http://ticktick.blog.51cto.com/823160/1653304" target="_blank" rel="external">Repo的使用</a>  </p>
<p>安装代码两行：</p>
<pre><code>$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo
</code></pre><h2 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a>配置JDK</h2><p>Android 7.1.1需要Java8，到官方下载安装即可：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html" target="_blank" rel="external">传送门</a></p>
<p>Java环境变量配置：</p>
<pre><code>export JAVA_HOME=`/usr/libexec/java_home -v 1.8`
export PATH=$JAVA_HOME/bin:$PATH 
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
</code></pre><h2 id="安装curl"><a href="#安装curl" class="headerlink" title="安装curl"></a>安装curl</h2><p>Mac OS自带的curl不带有openssl，不满足Jack编译的条件，因此需要用brew手动下载并替换默认的curl，命令如下：</p>
<pre><code>$ brew install curl --with-openssl
$ export PATH=$(brew --prefix curl)/bin:$PATH
</code></pre><h2 id="下载配置Mac-OS-sdk"><a href="#下载配置Mac-OS-sdk" class="headerlink" title="下载配置Mac OS sdk"></a>下载配置Mac OS sdk</h2><p>由于Mac OS 10.12sdk弃用了syscall函数，所以我们需要旧版本的sdk：<a href="https://github.com/phracker/MacOSX-SDKs/releases" target="_blank" rel="external">下载地址</a></p>
<p>下载好之后解压（如果下载下来的文件格式是xz文件那就不能用系统默认的解压工具），将解压得到的文件夹放在<strong>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</strong>下，大功告成。</p>
<h2 id="创建大小写敏感的磁盘区域"><a href="#创建大小写敏感的磁盘区域" class="headerlink" title="创建大小写敏感的磁盘区域"></a>创建大小写敏感的磁盘区域</h2><p>由于Mac OS默认不区别大小写，为了防止之后下载的文件冲突，需要新建一块大小写敏感的磁盘区域：</p>
<pre><code>$ hdiutil create -type SPARSE -fs &apos;Case-sensitive Journaled HFS+&apos; -size 85g ~/android.dmg
</code></pre><p>大小尽量设置的大些，笔者的源码下载并且编译之后整个的大小是83g。创建完毕后即可在Finder中双击加载。</p>
<h2 id="下载镜像文件"><a href="#下载镜像文件" class="headerlink" title="下载镜像文件"></a>下载镜像文件</h2><p>由于众所周知的原因，google官方的景象并不能有很好的体验，所以要用<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="external">清华大学的aosp镜像</a>，这里采用其官方推荐的做法，先下载一个每月更新的<a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="external">初始化包</a>（为求速度和稳定性请用迅雷）。</p>
<p>下载完成后，将压缩包剪切到先前已经加载的磁盘区域当中，用终端cd到压缩包所在的目录，运行如下指令：</p>
<pre><code>$ tar xf aosp-latest.tar
$ cd aosp
$ repo sync
</code></pre><p>接下来便会等待一段时间，此时repo正将下载好的分支更新到最新，所以仍需下载。如果出现下载速度过慢，远程连接经常hang up，那就请为git设置代理，笔者采用的是ss代理，所以相应的设置如下：</p>
<pre><code>git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;
git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;
</code></pre><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>下载完后，用终端cd到aosp目录，做的第一件事就是加载封装好的命令集：</p>
<pre><code>$ source build/envsetup.sh
</code></pre><p>接着运行指令lunch，会给出很多选项，对应不同的设备，这里笔者只是想查看一下源码，并没有刷机的需求，所以我就选了aosp_arm-eng。</p>
<p>接下来运行：</p>
<pre><code>$ make -j4
</code></pre><p>注意j4是因为笔者的笔记本是二核心的，如果是4核心就是8，以此类推。</p>
<p>下面就是漫长的等待，大概3，4个小时左右吧。</p>
<h2 id="导入Android-Studio"><a href="#导入Android-Studio" class="headerlink" title="导入Android Studio"></a>导入Android Studio</h2><p>编译完成之后，运行：</p>
<pre><code>$ mmm development/tools/idegen/
$ development/tools/idegen/idegen.sh
</code></pre><p>如果出现找不到指令的错误，请重新加载指令集。</p>
<p>为保证AS是大小写敏感的，在导入AS之前，先编辑<strong>/Applications/Android\ Studio.app/Contents/bin</strong>下的<strong>idea.properties</strong>文件，在其最后加上如下代码：</p>
<pre><code>idea.case.sensitive.fs=true
</code></pre><p>这时候aosp目录之下会出现android.ipr文件，此文件便是AS所需。用AS打开该文件，又是一个漫长的等待过程，大概20分钟左右吧。</p>
<p>导入之后，为了防止我们在观察源码时跳转到不是我们需要的.class文件，还需要做额外的几件事情：</p>
<h3 id="配置JDK和SDK"><a href="#配置JDK和SDK" class="headerlink" title="配置JDK和SDK"></a>配置JDK和SDK</h3><p><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%889.38.12.png" alt=""><br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%889.40.01.png" alt=""></p>
<h3 id="删除jar依赖"><a href="#删除jar依赖" class="headerlink" title="删除jar依赖"></a>删除jar依赖</h3><p>在项目设置(command + ;)中点击Modules，删除所有的jar包依赖，再添加两个文件夹依赖，分别是aosp文件夹下的external和frameworks文件夹。</p>
<h3 id="注释掉android-iml文件的-lt-sourceFloder-gt-标签"><a href="#注释掉android-iml文件的-lt-sourceFloder-gt-标签" class="headerlink" title="注释掉android.iml文件的&lt;sourceFloder&gt;标签"></a>注释掉android.iml文件的&lt;sourceFloder&gt;标签</h3><p>上面两步之后，一般情况下可以愉快的看源码了，可是有时候还会出现跳转错误，这是因为导入的其他的文件夹里面的类与external和frameworks冲突所致，这时候就需要编辑aosp目录下的android.iml文件，将发生冲突的文件夹的位置记录下来，并在iml文件中将&lt;sourceFolder&gt;标签注释掉。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/15/Android-DataBinding（二）：源码解析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/15/Android-DataBinding（二）：源码解析/" itemprop="url">
                  Android DataBinding（二）：源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-15T15:27:19+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/15/Android-DataBinding（二）：源码解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/15/Android-DataBinding（二）：源码解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>看源码有两种方式可供选择，第一种是直接将整个AOSP下载下来，然后自行编译，这种方法的好处看源码不会遇到爆红，整个代码结构一目了然，缺点就是占用空间大，下载时间长，编译坑比较多……第二种方法是直接用sdk目录之下的。在这里笔者采用第一种方法，下载并编译AOSP请见：<a href="http://zsrr.coding.me/2017/02/16/Mac-OS-Sierra%E4%B8%8B%E7%BC%96%E8%AF%91Android-7-1-1/" target="_blank" rel="external">Mac OS Sierra下编译Android 7.1.1</a>。</p>
<p>用Android Studio导入安卓源码之后，在Android视图，java包下会看到这几个包：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%889.24.48.png" alt=""><br>这就是我们要分析的源码了。</p>
<p>如果要采用第二种方法，platform请升到最新，不然可能出现当前platform找不到databinding的源码的问题，具体步骤如下：    </p>
<ul>
<li>随便新建一个Android项目</li>
<li>找到sdk文件夹，依次进入sources，android-xx（最新的），android文件夹，将里面的databinding文件夹复制到刚才新建的安卓项目当中。</li>
<li>更改databinding文件夹中所有java文件的包名。</li>
</ul>
<p>另外，如果你是Windows用户，那么请用<a href="https://www.sourceinsight.com/download/" target="_blank" rel="external">Source Insight</a>查看安卓源码。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="DataBindingUtil"><a href="#DataBindingUtil" class="headerlink" title="DataBindingUtil"></a>DataBindingUtil</h2><p>这是数据绑定的入口类，一般用它来创建相应的Binding类，我们由此开始分析。</p>
<p>先看最常见的用法：</p>
<pre><code>public static &lt;T extends ViewDataBinding&gt; T inflate(LayoutInflater inflater, int layoutId, ViewGroup parent, boolean attachToParent);
public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId);
public static &lt;T extends ViewDataBinding&gt; T bind(View root);
</code></pre><p>第一个方法最终调用的是<strong>bind(DataBindingComponent bindingComponent, View root, int layoutId)</strong>方法（如果attachToParent设置为false的话），这个方法的定义为：</p>
<pre><code>static &lt;T extends ViewDataBinding&gt; T bind(DataBindingComponent bindingComponent, View root,
        int layoutId) {
    return (T) sMapper.getDataBinder(bindingComponent, root, layoutId);
}
</code></pre><p>直接交给了sMapper来处理，sMapper是一个类型为DataBinderMapper的静态成员，其getDataBinder方法会根据xml文件生成的ViewDataBinding子类动态改变，这是笔者的getDataBinder源码（源自另一个已经写好的安卓项目）：</p>
<pre><code>public android.databinding.ViewDataBinding getDataBinder(android.databinding.DataBindingComponent bindingComponent, android.view.View view, int layoutId) {
    switch(layoutId) {
            case com.stephen.learning.R.layout.item_view:
                return com.stephen.learning.databinding.ViewHolderBinding.bind(view, bindingComponent);
            case com.stephen.learning.R.layout.activity_data_binding:
                return com.stephen.learning.databinding.ImageViewBinding.bind(view, bindingComponent);
    }
    return null;
}
</code></pre><p>可以看到，DataBinderMapper类将行为委托给了实际产生的ViewDataBinding的子类上，其具体的bind方法的实现，我们稍后再谈。现在再看<strong>setContentView</strong>方法，此方法的实现：</p>
<pre><code>public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId) {
    return setContentView(activity, layoutId, sDefaultComponent);
}

public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId,
        DataBindingComponent bindingComponent) {
    activity.setContentView(layoutId);
    View decorView = activity.getWindow().getDecorView();
    ViewGroup contentView = (ViewGroup) decorView.findViewById(android.R.id.content);
    return bindToAddedViews(bindingComponent, contentView, 0, layoutId);
}
</code></pre><p>bindToAddedViews方法的实现：</p>
<pre><code>private static &lt;T extends ViewDataBinding&gt; T bindToAddedViews(DataBindingComponent component,
        ViewGroup parent, int startChildren, int layoutId) {
    final int endChildren = parent.getChildCount();
    final int childrenAdded = endChildren - startChildren;
    if (childrenAdded == 1) {
        final View childView = parent.getChildAt(endChildren - 1);
        return bind(component, childView, layoutId);
    } else {
        final View[] children = new View[childrenAdded];
        for (int i = 0; i &lt; childrenAdded; i++) {
            children[i] = parent.getChildAt(i + startChildren);
        }
        return bind(component, children, layoutId);
    }
}
</code></pre><p>由上述代码可以发现，setContentView先获得activity中DecorView中的FrameLayout，再将其作为参数传入<strong>bindToAddedViews</strong>方法，此方法先判断parent当中子视图的数目，一般情况下我们activity的xml文件只有一个RelativeLayout或者LinearLayout的根元素，所以子视图一般只有一个，于是又开始调用bind方法，重新回到上面的流程。</p>
<p>下面分析<strong>bind(View root)</strong>方法：</p>
<pre><code>public static &lt;T extends ViewDataBinding&gt; T bind(View root) {
    return bind(root, sDefaultComponent);
}

public static &lt;T extends ViewDataBinding&gt; T bind(View root,
        DataBindingComponent bindingComponent) {
    T binding = getBinding(root);
    if (binding != null) {
        return binding;
    }
    Object tagObj = root.getTag();
    if (!(tagObj instanceof String)) {
        throw new IllegalArgumentException(&quot;View is not a binding layout&quot;);
    } else {
        String tag = (String) tagObj;
        int layoutId = sMapper.getLayoutId(tag);
        if (layoutId == 0) {
            throw new IllegalArgumentException(&quot;View is not a binding layout&quot;);
        }
        return (T) sMapper.getDataBinder(bindingComponent, root, layoutId);
    }
}
</code></pre><p>bind方法先调用<strong>getBinding</strong>方法，<strong>getBinding</strong>方法直接调用了ViewDataBinding的静态<strong>getBinding</strong>方法，这个方法之后分析ViewDataBinding的时候再讲。如果得到的binding是空的，那就创建一个binding并且返回，创建过程是先得到view的tag，这个tag是个String类型。例如ListView的item的xml文件名为item<em> view，里面的根元素是layout标签，那么我们用LayoutInflater类inflate出来的view便有一个String类型的Tag，并且值为：”layout/item</em> view_ 0”。好，找到tag之后，便调用DataBinderMapper类的<strong>getLayoutId</strong>方法，这个方法也是根据xml文件的定义自动生成的，笔者的方法定义如下所示：</p>
<pre><code>int getLayoutId(String tag) {
    if (tag == null) {
        return 0;
    }
    final int code = tag.hashCode();
    switch(code) {
        case -1223782307: {
            if(tag.equals(&quot;layout/item_view_0&quot;)) {
                return com.stephen.learning.R.layout.item_view;
            }
            break;
        }
        case 1514339820: {
            if(tag.equals(&quot;layout/activity_data_binding_0&quot;)) {
                return com.stephen.learning.R.layout.activity_data_binding;
            }
            break;
        }
    }
    return 0;
}
</code></pre><p>嗯……这么拿hashCode做判断再拿tag做判断的写法比较智障啊……<br>拿到layoutId之后，最后调用sMapper的<strong>getDataBinder</strong>，结束。</p>
<h2 id="DataBinderMapper"><a href="#DataBinderMapper" class="headerlink" title="DataBinderMapper"></a>DataBinderMapper</h2><p>这个类随着我们对xml的定义改变而改变，它的职责其实在上文对DataBindingUtil类的分析中已经展现：  </p>
<ul>
<li>作为DataBindingUtil和ViewDataBinding类的中介类</li>
<li>根据tag得到对应的id</li>
</ul>
<p>此外，它的内部还维护一个InnerBrLookUp的静态类，此静态类又维护一个String类型的数组，用来将BR类的id转成对应的String，通常用作打log，这里不再细谈。</p>
<h2 id="BaseObservable"><a href="#BaseObservable" class="headerlink" title="BaseObservable"></a>BaseObservable</h2><p>把此类放在这个位置是为了之后介绍<strong>ViewDataBinding</strong>类。</p>
<p>此类的实现相当简单：</p>
<pre><code>public class BaseObservable implements Observable {
    private transient PropertyChangeRegistry mCallbacks;

    public BaseObservable() {
    }

    @Override
    public synchronized void addOnPropertyChangedCallback(OnPropertyChangedCallback callback) {
        if (mCallbacks == null) {
            mCallbacks = new PropertyChangeRegistry();
        }
        mCallbacks.add(callback);
    }

    @Override
    public synchronized void removeOnPropertyChangedCallback(OnPropertyChangedCallback callback) {
        if (mCallbacks != null) {
            mCallbacks.remove(callback);
        }
    }


    public synchronized void notifyChange() {
        if (mCallbacks != null) {
            mCallbacks.notifyCallbacks(this, 0, null);
        }
    }

    public void notifyPropertyChanged(int fieldId) {
        if (mCallbacks != null) {
            mCallbacks.notifyCallbacks(this, fieldId, null);
        }
    }
}
</code></pre><p>将所有的职责都托付给了内部成员<strong>mCallbacks</strong>身上。</p>
<h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p><strong>BaseObservable</strong>实现了<strong>Observable</strong>接口。先看一下官方文档对此接口的介绍：</p>
<blockquote>
<p>Observable classes provide a way in which data bound UI can be notified of changes.</p>
</blockquote>
<p>简而言之，这个接口就是为了保证UI元素和数据之间的双向绑定，其内部有两个方法：</p>
<pre><code>void addOnPropertyChangedCallback(OnPropertyChangedCallback callback);
void removeOnPropertyChangedCallback(OnPropertyChangedCallback callback);
</code></pre><p>OnPropertyChangedCallback是一个抽象类，其内部只有一个抽象方法:</p>
<pre><code>public abstract void onPropertyChanged(Observable sender, int propertyId);
</code></pre><p>sender就是持有此类的<strong>Observable</strong>类，propertyId是绑定的数据id。当我们用<strong>Bindable</strong>注解标注一个getter时，自动生成的<strong>BR</strong>类会生成此id。</p>
<h3 id="CallbackRegistry"><a href="#CallbackRegistry" class="headerlink" title="CallbackRegistry"></a>CallbackRegistry</h3><p>上面说到<strong>BaseObservable</strong>将职责托付给了<strong>mCallbacks</strong>，而mCallbacks是一个<strong>PropertyChangeRegistry</strong>类，这个类的超类<strong>CallbackRegistry</strong>。此类是管理callback注册，删除，通知的核心类，通过内部<strong>NotifierCallback</strong>类来通知callbacks，此类的代码虽然不多，但是对于我这种算法弱鸡来说看上去的感觉是这样的：<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1487508874434&amp;di=188c6fb1e6fe4e69bf1cab8c82844595&amp;imgtype=0&amp;src=http%3A%2F%2Fwanzao2.b0.upaiyun.com%2Fsystem%2Fpictures%2F31274020%2Foriginal%2F1449639129_500x500.png" alt=""></p>
<p>这个牛逼的算法就不由我这个弱鸡去分析了，它实现了通知Callback的可重入性，就是比方说有两个线程，一个线程执行到通知某个Callback时cpu切到了另一个线程，这个线程把刚才的要通知的Callback给删了，这种情况下切换到之前的线程进行通知是没有任何影响的。如果各位实在想知道这个算法是怎么一回事，请看这篇大牛的文章吧：<a href="https://gold.xitu.io/post/5840e2e3ac502e006cc0ef26" target="_blank" rel="external">回调通知管理器 CallbackRegistry 解析</a></p>
<h3 id="PropertyChangeRegistry"><a href="#PropertyChangeRegistry" class="headerlink" title="PropertyChangeRegistry"></a>PropertyChangeRegistry</h3><p>此类比较简单：</p>
<pre><code>public class PropertyChangeRegistry extends
    CallbackRegistry&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt; {

    private static final CallbackRegistry.NotifierCallback&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt; NOTIFIER_CALLBACK = new CallbackRegistry.NotifierCallback&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt;() {
        @Override
        public void onNotifyCallback(Observable.OnPropertyChangedCallback callback, Observable sender,
                int arg, Void notUsed) {
            callback.onPropertyChanged(sender, arg);
        }
    };

    public PropertyChangeRegistry() {
        super(NOTIFIER_CALLBACK);
    }

    public void notifyChange(Observable observable, int propertyId) {
        notifyCallbacks(observable, propertyId, null);
    }
}
</code></pre><p>Callback类型是<strong>Observable</strong>的内部类<strong>OnPropertyChangedCallback</strong>，Sender类型是<strong>Observable</strong>。NotifierCallback内部的实现仅仅是调用callback的<strong>onPropertyChanged</strong>方法，arg便是<strong>BR</strong>类里面的资源id。<strong>notifyChange</strong>方法是将外层传来的sender以及资源id传给<strong>notifyCallbacks</strong>方法，以此达到了最终调用每一个callback的<strong>onPropertyChanged</strong>的目的。</p>
<h2 id="ViewDataBinding"><a href="#ViewDataBinding" class="headerlink" title="ViewDataBinding"></a>ViewDataBinding</h2><p>系统会根据xml的描述生成此类的子类，我们先看一下自动生成的类的代码，一步一步加以分析。</p>
<p>xml文件：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;data class=&quot;BindingForTest&quot;&gt;
        &lt;variable
            name=&quot;testData&quot;
            type=&quot;com.stephen.learning.databinding.Model&quot;/&gt;
    &lt;/data&gt;

    &lt;LinearLayout
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        tools:context=&quot;com.stephen.learning.databinding.TestActivity&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/main_text_view&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot; /&gt;
        &lt;TextView
            android:id=&quot;@+id/second_text_view&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{testData.testData}&quot;/&gt;
        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{testData.testData}&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre><p>生成的ViewBinding子类：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-19%20%E4%B8%8B%E5%8D%888.36.08.png" alt=""><br>先看构造函数：</p>
<pre><code>public BindingForTest(android.databinding.DataBindingComponent bindingComponent, View root) {
    super(bindingComponent, root, 0);
    final Object[] bindings = mapBindings(bindingComponent, root, 4, sIncludes, sViewsWithIds);
    this.mainTextView = (android.widget.TextView) bindings[3];
    this.mboundView0 = (android.widget.LinearLayout) bindings[0];
    this.mboundView0.setTag(null);
    this.mboundView2 = (android.widget.Button) bindings[2];
    this.mboundView2.setTag(null);
    this.secondTextView = (android.widget.TextView) bindings[1];
    this.secondTextView.setTag(null);
    setRootTag(root);
    // listeners
    invalidateAll();
}
</code></pre><p>先调用超类的静态<strong>mapBindings</strong>方法得到一个<strong>View</strong>数组，再从数组中初始化View成员，View成员有三种：</p>
<ul>
<li>在xml中有id的定义。</li>
<li>在xml中存在数据的绑定。</li>
<li>是根View。</li>
</ul>
<p>满足以上三个条件任意一个便会生成相应的类成员，下面是笔者的类里面的类成员：</p>
<pre><code>//存在id，不存在数据绑定
public final android.widget.TextView mainTextView;
//根View
private final android.widget.LinearLayout mboundView0;
//存在数据绑定，不存在id
private final android.widget.Button mboundView2;
//既存在数据绑定，也存在id
public final android.widget.TextView secondTextView;
</code></pre><p>再来看一下类的静态初始化：</p>
<pre><code>static {
    sIncludes = null;
    sViewsWithIds = new android.util.SparseIntArray();
    sViewsWithIds.put(R.id.main_text_view, 3);
}
</code></pre><p><strong>sIncludes</strong>只有在xml中存在<strong>&lt;include&gt;</strong>标签且存在数据绑定的时候才不为空，在这里笔者暂时没有用到使用数据绑定的<strong>&lt;include&gt;</strong>的需求（觉得也不可能有），而且源码的实现相对简单，这里不太值得分析，有兴趣自己去看。<strong>sViewsWithIds</strong>是一个<strong>SparseIntArray</strong>，这个成员的作用是存放不存在数据绑定但存在id定义的View成员。键是id，值是对应在上面所提在View数组中的索引值。</p>
<p>下面来看<strong>mapBindings</strong>方法：</p>
<pre><code>protected static Object[] mapBindings(DataBindingComponent bindingComponent, View root,
        int numBindings, IncludedLayouts includes, SparseIntArray viewsWithIds) {
    Object[] bindings = new Object[numBindings];
    mapBindings(bindingComponent, root, bindings, includes, viewsWithIds, true);
    return bindings;
}

private static void mapBindings(DataBindingComponent bindingComponent, View view,
        Object[] bindings, IncludedLayouts includes, SparseIntArray viewsWithIds,
        boolean isRoot) {
    final int indexInIncludes;
    final ViewDataBinding existingBinding = getBinding(view);
    //已经绑定过，返回
    if (existingBinding != null) {
        return;
    }

    Object objTag = view.getTag();
    final String tag = (objTag instanceof String) ? (String) objTag : null;
    boolean isBound = false;

    //如果是根View
    if (isRoot &amp;&amp; tag != null &amp;&amp; tag.startsWith(&quot;layout&quot;)) {
        final int underscoreIndex = tag.lastIndexOf(&apos;_&apos;);
        if (underscoreIndex &gt; 0 &amp;&amp; isNumeric(tag, underscoreIndex + 1)) {
            final int index = parseTagInt(tag, underscoreIndex + 1);
            if (bindings[index] == null) {
                bindings[index] = view;
            }
            indexInIncludes = includes == null ? -1 : index;
            isBound = true;
        } else {
            indexInIncludes = -1;
        }
     //如果不是根View
    } else if (tag != null &amp;&amp; tag.startsWith(BINDING_TAG_PREFIX)) {
        int tagIndex = parseTagInt(tag, BINDING_NUMBER_START);
        if (bindings[tagIndex] == null) {
            bindings[tagIndex] = view;
        }
        isBound = true;
        indexInIncludes = includes == null ? -1 : tagIndex;
    } else {
        // Not a bound view
        indexInIncludes = -1;
    }
    //处理存在id但是不存在数据绑定的view成员
    if (!isBound) {
        final int id = view.getId();
        if (id &gt; 0) {
            int index;
            if (viewsWithIds != null &amp;&amp; (index = viewsWithIds.get(id, -1)) &gt;= 0 &amp;&amp;
                    bindings[index] == null) {
                bindings[index] = view;
            }
        }
    }

    if (view instanceof  ViewGroup) {
        final ViewGroup viewGroup = (ViewGroup) view;
        final int count = viewGroup.getChildCount();
        int minInclude = 0;
        for (int i = 0; i &lt; count; i++) {
            final View child = viewGroup.getChildAt(i);
            boolean isInclude = false;
            if (indexInIncludes &gt;= 0 &amp;&amp; child.getTag() instanceof String) {
               ...
            }
            //对每一个子View进行递归处理
            if (!isInclude) {
                mapBindings(bindingComponent, child, bindings, includes, viewsWithIds, false);
            }
        }
    }
}
</code></pre><p>此方法的思想相对简单，先判断是否绑定过，如果已经绑定过，则返回。接下来分成三种情况：</p>
<ul>
<li>根视图。</li>
<li>存在数据绑定的视图。</li>
<li>不存在数据绑定，但是在xml中有id定义。</li>
</ul>
<p>最后如果传入的是一个ViewGroup，则对它的子视图进行递归处理。下面我们来看几个细节：</p>
<p><strong>视图数组索引的判断</strong>  </p>
<p>上文中我们说过用<strong>&lt;layout&gt;</strong>做标记的xml文件在用<strong>LayoutInflater</strong>类inflate出来的根View会有一个<strong>tag</strong>，这个<strong>tag</strong>是一个<strong>String</strong>类型，且设置的规则如下：</p>
<ul>
<li>根视图设置为<strong>layout/[xml文件名]_[在View数组中的索引]</strong></li>
<li>不是根视图，但是存在数据的绑定，则设置为<strong>binding_[在View数组中的索引]</strong></li>
</ul>
<p>根据tag获得数组索引的代码如下：</p>
<pre><code>private static int parseTagInt(String str, int startIndex) {
    final int end = str.length();
    int val = 0;
    for (int i = startIndex; i &lt; end; i++) {
        val *= 10;
        char c = str.charAt(i);
        val += (c - &apos;0&apos;);
    }
    return val;
}
</code></pre><p>这样得出的数组索引便是最后一个”_”后面的数字值。</p>
<p>还有一种情况是不存在数据绑定，但是存在id定义的view成员。上面提到过如果存在这种情况，<strong>ViewDataBinding</strong>在静态初始化的时候会将对应的id和数组索引值放在一个<strong>SparseIntArray</strong>当中，这时候处理过程是这样的：</p>
<pre><code>if (!isBound) {
    final int id = view.getId();
    if (id &gt; 0) {
        int index;
        if (viewsWithIds != null &amp;&amp; (index = viewsWithIds.get(id, -1)) &gt;= 0 &amp;&amp;
                bindings[index] == null) {
            bindings[index] = view;
        }
    }
</code></pre><p>好，现在继续往下看<strong>invalidateAll</strong>方法：</p>
<pre><code>public void invalidateAll() {
    synchronized(this) {
            mDirtyFlags = 0x2L;
    }
    requestRebind();
}
</code></pre><p><strong>requestRebind</strong>:</p>
<pre><code>protected void requestRebind() {
    synchronized (this) {
        if (mPendingRebind) {
            return;
        }
        mPendingRebind = true;
    }
    if (USE_CHOREOGRAPHER) {
        mChoreographer.postFrameCallback(mFrameCallback);
    } else {
        mUIThreadHandler.post(mRebindRunnable);
    }

}
</code></pre><p>其中<strong>USE_CHOREOGRAPHER</strong>是判断当前的SDK是不是16以上版本来决定是否能用<strong>Choreographer</strong>，如果能则直接设置一个<strong>FrameCallback</strong>，不能则在主线程运行一个<strong>Runnable</strong>，我们来看<strong>mFrameCallback</strong>的定义：</p>
<pre><code>mFrameCallback = new Choreographer.FrameCallback() {
            @Override
            public void doFrame(long frameTimeNanos) {
                mRebindRunnable.run();
            }
        };
</code></pre><p><strong>mRebindRunnable</strong>:</p>
<pre><code>private final Runnable mRebindRunnable = new Runnable() {
    @Override
    public void run() {
        synchronized (this) {
            mPendingRebind = false;
        }
        if (VERSION.SDK_INT &gt;= VERSION_CODES.KITKAT) {
            // Nested so that we don&apos;t get a lint warning in IntelliJ
            if (!mRoot.isAttachedToWindow()) {
                // Don&apos;t execute the pending bindings until the View
                // is attached again.
                mRoot.removeOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);
                mRoot.addOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);
                return;
            }
        }
        executePendingBindings();
    }
};
</code></pre><p><strong>ROOT_ REATTACHED_LISTENER</strong>是一个<strong>OnAttachStateChangeListener</strong>，其定义如下：</p>
<pre><code>ROOT_REATTACHED_LISTENER = new OnAttachStateChangeListener() {
            @TargetApi(VERSION_CODES.KITKAT)
            @Override
            public void onViewAttachedToWindow(View v) {
                // execute the pending bindings.
                final ViewDataBinding binding = getBinding(v);
                binding.mRebindRunnable.run();
                v.removeOnAttachStateChangeListener(this);
            }

            @Override
            public void onViewDetachedFromWindow(View v) {
            }
        };
</code></pre><p>很简单，当根视图还没有attach到window上的时候，<strong>mRebindRunnable</strong>直接设置一个<strong>OnAttachStateChangeListener</strong>并返回，当attach到window上的时候重新运行<strong>mRebindRunnable</strong>，此时将运行<strong>executePendingBindings</strong>，定义如下：</p>
<pre><code>public void executePendingBindings() {
    if (mIsExecutingPendingBindings) {
        requestRebind();
        return;
    }
    if (!hasPendingBindings()) {
        return;
    }
    mIsExecutingPendingBindings = true;
    mRebindHalted = false;
    if (mRebindCallbacks != null) {
        mRebindCallbacks.notifyCallbacks(this, REBIND, null);

        // The onRebindListeners will change mPendingHalted
        if (mRebindHalted) {
            mRebindCallbacks.notifyCallbacks(this, HALTED, null);
        }
    }
    if (!mRebindHalted) {
        executeBindings();
        if (mRebindCallbacks != null) {
            mRebindCallbacks.notifyCallbacks(this, REBOUND, null);
        }
    }
    mIsExecutingPendingBindings = false;
}
</code></pre><p>其中<strong>hasPendingBindings</strong>方法是一个抽象方法，一般情况下子类通过其<strong>mDirtyFlags</strong>判断是否有未处理的绑定情况，返回相应的布尔值：</p>
<pre><code>public boolean hasPendingBindings() {
    synchronized(this) {
        if (mDirtyFlags != 0) {
            return true;
        }
    }
    return false;
}
</code></pre><p>接下来便要通知相应的mRebindCallbacks，我们来看它的定义：</p>
<pre><code>private CallbackRegistry&lt;OnRebindCallback, ViewDataBinding, Void&gt; mRebindCallbacks;

public void addOnRebindCallback(OnRebindCallback listener) {
    if (mRebindCallbacks == null) {
        mRebindCallbacks = new CallbackRegistry&lt;OnRebindCallback, ViewDataBinding, Void&gt;(REBIND_NOTIFIER);
    }
    mRebindCallbacks.add(listener);
}
</code></pre><p>它是一个Callback类型是<strong>OnRebindCallback</strong>，Sender类型是<strong>ViewDataBinding</strong>的<strong>CallbackRegistry</strong>类型，下面来看<strong>OnRebindCallback</strong>的定义，它是一个抽象类，里面有三个方法：</p>
<pre><code>public abstract class OnRebindCallback&lt;T extends ViewDataBinding&gt; {
    public boolean onPreBind(T binding) {
        return true;
    }

    public void onCanceled(T binding) {
    }

    public void onBound(T binding) {
    }
}
</code></pre><p>泛型的参数T就是上面的Sender，第一个方法<strong>onPreBind</strong>的返回值决定着rebind是否会继续进行。接着再来看<strong>REBIND_NOTIFIER</strong>:</p>
<pre><code>private static final CallbackRegistry.NotifierCallback&lt;OnRebindCallback, ViewDataBinding, Void&gt;
    REBIND_NOTIFIER = new NotifierCallback&lt;OnRebindCallback, ViewDataBinding, Void&gt;() {
    @Override
    public void onNotifyCallback(OnRebindCallback callback, ViewDataBinding sender, int mode,
            Void arg2) {
        switch (mode) {
            case REBIND:
                if (!callback.onPreBind(sender)) {
                    sender.mRebindHalted = true;
                }
                break;
            case HALTED:
                callback.onCanceled(sender);
                break;
            case REBOUND:
                callback.onBound(sender);
                break;
        }
    }
};
</code></pre><p>现在再来看<strong>executePendingBindings</strong>方法，先是向<strong>mRebindCallbacks</strong>传入<strong>REBIND</strong>参数，进而调用<strong>OnRebindCallback</strong>的<strong>onPreBind</strong>方法，根据其返回的布尔值来决定<strong>mRebindHalted</strong>的值（是否停止）。接下来判断<strong>mRebindHalted</strong>的值，如果是真值的话，则通过向<strong>mRebindCallbacks</strong>传入<strong>HALTED</strong>参数进而调用<strong>OnRebindCallback</strong>的<strong>onCanceled</strong>方法；如果是假值，则先调用<strong>executeBindings</strong>方法，此方法是抽象方法，再通过向<strong>mRebindCallbacks</strong>传入<strong>REBOUND</strong>参数，进而调用<strong>OnRebindCallback</strong>的<strong>onRebound</strong>方法。</p>
<p>下面来看<strong>executeBindings</strong>方法的具体实现：</p>
<pre><code>@Override
protected void executeBindings() {
    long dirtyFlags = 0;
    synchronized(this) {
        //读取mDirtyFlags
        dirtyFlags = mDirtyFlags;
        //重置mDirtyFlags
        mDirtyFlags = 0;
    }
    java.lang.String testDataTestData = null;
    //读取testData
    com.stephen.learning.databinding.Model testData = mTestData;

    if ((dirtyFlags &amp; 0x3L) != 0) {



            if (testData != null) {
                // read testData.testData
                testDataTestData = testData.testData;
            }
    }
    // batch finished
    if ((dirtyFlags &amp; 0x3L) != 0) {
        // api target 1

        android.databinding.adapters.TextViewBindingAdapter.setText(this.mboundView2, testDataTestData);
        android.databinding.adapters.TextViewBindingAdapter.setText(this.secondTextView, testDataTestData);
    }
}
</code></pre><p>方法的最后通过<strong>TextViewBindingAdapter</strong>来实际设置<strong>TextView</strong>的值（<strong>Button</strong>继承于<strong>TextView</strong>），除了<strong>TextViewBindingAdapter</strong>之外，官方还提供了四十多种Adapter用来使数据绑定更加便捷，在这里我就不一一分析了，只说一下大体的形式。一般来说一个Adapter由两部分组成：</p>
<ul>
<li>顶部<strong>BindingMethods</strong>注解，用此注解来说明当发生数据绑定时调用哪个类的哪个方法。</li>
<li>一系列用<strong>BindingAdapter</strong>注释的静态方法，用来供<strong>ViewDataBinding</strong>的子类调用。</li>
</ul>
<p>值得注意的是，xml中的数据绑定并不都是通过Adapter来实现的，下面举一个例子：</p>
<p>将xml文件更改成：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;

    ...

    &lt;LinearLayout
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        tools:context=&quot;com.stephen.learning.databinding.TestActivity&quot;
        android:orientation=&quot;vertical&quot;&gt;

        ...

        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{testData.testData}&quot;
            android:onClick=&quot;@{(v) -&gt; testData.onButtonClick()}&quot;/&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre><p>这个时候rebuild project，<strong>BindingForTest</strong>类变成了这样：</p>
<pre><code>public class BindingForTest extends android.databinding.ViewDataBinding implements android.databinding.generated.callback.OnClickListener.Listener {

    ...

    public BindingForTest(android.databinding.DataBindingComponent bindingComponent, View root) {
        ...
        // listeners
        mCallback1 = new android.databinding.generated.callback.OnClickListener(this, 1);
        invalidateAll();
    }

    @Override
    protected void executeBindings() {
        ...
        if ((dirtyFlags &amp; 0x2L) != 0) {
            // api target 1

            this.mboundView2.setOnClickListener(mCallback1);
        }
    }
    // Listener Stub Implementations
    // callback impls
    public final void _internalCallbackOnClick(int sourceId , android.view.View callbackArg_0) {
        // localize variables for thread safety
        // testData != null
        boolean testDataObjectnull = false;
        // testData
        com.stephen.learning.databinding.Model testData = mTestData;



        testDataObjectnull = (testData) != (null);
        if (testDataObjectnull) {


            testData.onButtonClick();
        }
    }
}
</code></pre><p>在构造函数中初始化了databinding包中的<strong>OnClickListener</strong>，并且实现了其中的<strong>Listener</strong>接口，<strong>OnClickListener</strong>类的定义如下：</p>
<pre><code>public final class OnClickListener implements android.view.View.OnClickListener {
    final Listener mListener;
    final int mSourceId;
    public OnClickListener(Listener listener, int sourceId) {
        mListener = listener;
        mSourceId = sourceId;
    }
    @Override
    public void onClick(android.view.View callbackArg_0) {
        mListener._internalCallbackOnClick(mSourceId , callbackArg_0);
    }
    public interface Listener {
        void _internalCallbackOnClick(int sourceId , android.view.View callbackArg_0);
    }
}
</code></pre><p>它实现了<strong>View</strong>当中的<strong>OnClickListener</strong>接口，其<strong>onClick</strong>方法则调用<strong>mListener</strong>当中的<strong>_internalCallbackOnClick</strong>方法（这个命名怎么这么像native方法）。<strong>BindingForTest</strong>的对此方法的定义如下：</p>
<pre><code>public final void _internalCallbackOnClick(int sourceId , android.view.View callbackArg_0) {
        // localize variables for thread safety
        // testData != null
        boolean testDataObjectnull = false;
        // testData
        com.stephen.learning.databinding.Model testData = mTestData;
        testDataObjectnull = (testData) != (null);
        if (testDataObjectnull) {
            testData.onButtonClick();
        }
    }
</code></pre><p>这边开始调用testData的<strong>onButtonClick</strong>，与xml中的定义对应起来了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/14/Android-DataBinding（一）：基本使用/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/14/Android-DataBinding（一）：基本使用/" itemprop="url">
                  Android DataBinding（一）：基本使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-14T21:42:57+08:00">
                2017-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/14/Android-DataBinding（一）：基本使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/14/Android-DataBinding（一）：基本使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MVVM设计模式"><a href="#MVVM设计模式" class="headerlink" title="MVVM设计模式"></a>MVVM设计模式</h2><p>这是一种由MVP发展而来，起源于WPF开发的一种架构模式。全称为Model-View-ViewModel，其中ViewModel便是MVP对应的Presenter。其最大的特征是ViewModel实现了View和Model的双向绑定，只需要为每一个View定制一个Model，在xml中去引用Model类，强大的IDE便会自动生成ViewModel类。强大，简单，可测试，低耦合。  </p>
<h2 id="DataBinding的使用"><a href="#DataBinding的使用" class="headerlink" title="DataBinding的使用"></a>DataBinding的使用</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>首先，在gradle中开启dataBinding选项：</p>
<pre><code>android {
    ...
    dataBinding {
        enabled true
    }
}
</code></pre><h3 id="基本数据绑定"><a href="#基本数据绑定" class="headerlink" title="基本数据绑定"></a>基本数据绑定</h3><p><strong>简单数据绑定</strong><br>先定义一个简单的Model类User：</p>
<pre><code>public class User {
    private final String name;
    private final String age;

    public User(String name, String age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
           return name;
    }

    public String getAge() {
        return age;
    }
}
</code></pre><p>界面xml文件：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

&lt;data&gt;
    &lt;import type=&quot;java.lang.String&quot;/&gt;
    &lt;variable
        name=&quot;user&quot;
        type=&quot;com.stephen.learning.databinding.User&quot; /&gt;
&lt;/data&gt;

&lt;RelativeLayout
    android:id=&quot;@+id/activity_data_binding&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/name_text_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;@{user.name}&quot;/&gt;
    &lt;TextView
        android:id=&quot;@+id/age_text_view&quot;
        android:layout_below=&quot;@id/name_text_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;16dp&quot;
        android:text=&quot;@{String.valueOf(user.age)}&quot;/&gt;
&lt;/RelativeLayout&gt;
&lt;/layout&gt;
</code></pre><ul>
<li><strong>&lt;layout&gt;</strong>标签：使用数据绑定时的根标签。</li>
<li><strong>&lt;data&gt;</strong>标签：数据标签，这里用来定义绑定的变量及其类型。如果需要一个类中的常量活着静态方法，可以导入类型。</li>
<li><strong>&lt;import&gt;</strong>标签：导入类型。</li>
<li><strong>&lt;variable&gt;</strong>标签：定义变量。</li>
<li><strong>android:text=”@{user.name}”</strong>：将数据绑定到view，注意引用user的name，运行时便会调用user.getName()方法，注意命名保持一致。 </li>
</ul>
<p>其中<strong>@{}</strong>会有更加丰富的语法，后文再讲。</p>
<p>Activity调用：</p>
<pre><code>public class DataBindingActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityDataBindingBinding binding = DataBindingUtil.setContentView(this, 
                R.layout.activity_data_binding);
        binding.setUser(new User(&quot;Stephen&quot;, 19));
    }
}
</code></pre><p>注意此时IDE生成的binding类默认是根据xml文件来命名的，笔者的xml文件时activity_data_binding，那么生成的类名便是ActivityDataBindingBinding，当然如果嫌命名太丑的话可以在<strong>data</strong>标签当中修改:</p>
<pre><code>&lt;data class=&quot;BindingForActivity&quot;&gt;
    &lt;import type=&quot;java.lang.String&quot;/&gt;
    &lt;variable
        name=&quot;user&quot;
        type=&quot;com.stephen.learning.databinding.User&quot; /&gt;
&lt;/data&gt;
</code></pre><p>对应生成的类名便是BindingForActivity。<br>注意生成Binding类的方法：</p>
<pre><code>DataBindingUtil.setContentView(this, R.layout.activity_data_binding);
</code></pre><p>这是在Activity当中的一般用法，如果是要绑定ListView, RecyclerView的ItemView的话，可以这么调用：  </p>
<pre><code>ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false);
</code></pre><p>最后一步便是通过生成的binding类设置在xml文件中定义的变量了，在variable中定义的name时user，那么函数的名字便是setUser，注意命名。  </p>
<p><strong>Observable数据绑定</strong><br>上面的简单数据绑定存在的问题是：当绑定之后数据发生变化时，对应的View不会更改，也就是说，没有真正的实现双向绑定。如果要实现双向绑定，就得将Model类继承BaseObservable类，并且<em>assigning a Bindable annotation to the getter and notifying in the setter.</em> 此时User类改写为：  </p>
<pre><code>public class User extends BaseObservable {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Bindable
    public String getName() {
        return name;
    }

    @Bindable
    public int getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
        notifyPropertyChanged(BR.name);
    }

    public void setAge(int age) {
        this.age = age;
        notifyPropertyChanged(BR.age);
    }
}
</code></pre><p>注意，如果出现BR类找不到，BR.后面的属性找不到，<strong>那就删除所有import有关数据绑定的类的语句，并在xml中删除（加块状注释）data标签，并clean project！</strong>  </p>
<p>Activity:</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    user = new User(&quot;Stephen&quot;, 19);
    BindingForActivity bindingForActivity = DataBindingUtil.setContentView(this, R.layout.activity_data_binding);
    bindingForActivity.setUser(user);

    findViewById(R.id.change_button).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            user.setAge(20);
            user.setName(&quot;Stephanie&quot;);
        }
    });
}
</code></pre><h3 id="处理交互事件"><a href="#处理交互事件" class="headerlink" title="处理交互事件"></a>处理交互事件</h3><p>数据绑定同样适合View的交互事件的处理，某个动作要处理的逻辑也可以放在引用的类当中，方法如下：  </p>
<p>xml文件：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

&lt;data&gt;
    ...
    &lt;variable
        name=&quot;handler&quot;
        type=&quot;com.stephen.learning.databinding.DataBindingActivity&quot;
&lt;/data&gt;

&lt;RelativeLayout
    android:id=&quot;@+id/activity_data_binding&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    ...
    &lt;Button
        android:id=&quot;@+id/change_button&quot;
        android:layout_below=&quot;@id/age_text_view&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;16dp&quot;
        android:onClick=&quot;@{(view) -&gt; handler.onButtonClick(view)}&quot;
&lt;/RelativeLayout&gt;
&lt;/layout&gt;
</code></pre><p>Activity:  </p>
<pre><code>public class DataBindingActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        bindingForActivity.setHandler(this);
    }

    public void onButtonClick(View v) {
        Log.e(&quot;DataBinding&quot;, String.valueOf(v.getId()));
        Toast.makeText(this, &quot;onClick!&quot;, Toast.LENGTH_SHORT).show();
    }
}
</code></pre><p>android:onClick后面是一个lambda表达式，参数是一个view，便是其自身，后面是点击之后将要做的事，这里调用了Activity中定义好的函数。  </p>
<p>除了onClick之外，还有onLongClick，onSearchClick(SearchView)等等，用法相同，这里不再细谈。</p>
<h3 id="神奇的花括号"><a href="#神奇的花括号" class="headerlink" title="神奇的花括号"></a>神奇的花括号</h3><p>xml中的{}里面支持各种各样的操作，支持的操作符有这些（来自官方文档）：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-15%20%E4%B8%8A%E5%8D%8812.54.14.png" alt=""><br>用法很多，比如根据model选择view相应的状态：</p>
<pre><code>android:visibility=&quot;@{age &lt; 13 ? View.GONE : View.VISIBLE}&quot;
android:padding=&quot;@{large? @dimen/largePadding : @dimen/smallPadding}&quot;
android:background=&quot;@{isError ? @drawable/error : @color/white}&quot;
</code></pre><p>调用相应的函数：</p>
<pre><code>&lt;data&gt;
    &lt;import type=&quot;com.example.MyStringUtils&quot;/&gt;
    &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;
&lt;/data&gt;
…
&lt;TextView
       android:text=&quot;@{MyStringUtils.capitalize(user.lastName)}&quot;
       android:layout_width=&quot;wrap_content&quot;
       android:layout_height=&quot;wrap_content&quot;/&gt;  
</code></pre><p> 获取数组中的特定元素：</p>
<pre><code> &lt;data&gt;
    &lt;import type=&quot;android.util.SparseArray&quot;/&gt;
    &lt;import type=&quot;java.util.Map&quot;/&gt;
    &lt;import type=&quot;java.util.List&quot;/&gt;
    &lt;variable name=&quot;list&quot; type=&quot;List&amp;lt;String&amp;gt;&quot;/&gt;
    &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&amp;lt;String&amp;gt;&quot;/&gt;
    &lt;variable name=&quot;map&quot; type=&quot;Map&amp;lt;String, String&amp;gt;&quot;/&gt;
    &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;
    &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;
&lt;/data&gt;
…
android:text=&quot;@{list[index]}&quot;
…
android:text=&quot;@{sparse[index]}&quot;
…
android:text=&quot;@{map[key]}&quot;
</code></pre><h3 id="动态变量的绑定"><a href="#动态变量的绑定" class="headerlink" title="动态变量的绑定"></a>动态变量的绑定</h3><p>有很多时候我们并不能提前知道所要的数据是什么，比如RecyclerView的adapter中的数据有可能是经过网络请求得来的，这里展示一下用法：<br>item_view.xml:</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
&lt;data class=&quot;ViewHolderBinding&quot;&gt;
    &lt;variable
        name=&quot;dataStr&quot;
        type=&quot;String&quot;/&gt;
&lt;/data&gt;

&lt;LinearLayout
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;
    &lt;TextView
        android:id=&quot;@+id/test_text_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;@{dataStr}&quot;/&gt;
&lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre><p>RecyclerView.Adapter:</p>
<pre><code>public class Adapter extends RecyclerView.Adapter&lt;Adapter.ViewHolder&gt; {

    private List&lt;String&gt; mData;
    private LayoutInflater inflater;

    public Adapter(List&lt;String&gt; mData, Context context) {
        this.mData = mData;
        inflater = LayoutInflater.from(context);
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        return new ViewHolder(inflater.inflate(R.layout.item_view, parent, false));
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        holder.binding.setDataStr(mData.get(position));
    }

    @Override
    public int getItemCount() {
        return mData.size();
    }

    static class ViewHolder extends RecyclerView.ViewHolder {
        ViewHolderBinding binding;

        public ViewHolder(View itemView) {
           super(itemView);
            binding = DataBindingUtil.bind(itemView);
        }
    }
}
</code></pre><p>非常简单，不再细谈。</p>
<h3 id="自定义Setter"><a href="#自定义Setter" class="headerlink" title="自定义Setter"></a>自定义Setter</h3><p>有时候可以让我们的xml变得更加灵活，例如想要在xml里面设置一张图片的imageUrl就可以显示图片，实现的方式便是自定义Setter，实现过程如下：<br>xml文件：</p>
<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;

&lt;data class=&quot;ImageViewBinding&quot;&gt;
    &lt;import type=&quot;com.stephen.learning.databinding.DataBindingActivity&quot;/&gt;
&lt;/data&gt;

&lt;RelativeLayout
    android:id=&quot;@+id/activity_data_binding&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;&gt;

    &lt;ImageView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:imageUrl=&apos;@{&quot;http://imgsrc.baidu.com/baike/pic/item/7aec54e736d12f2ee289bffe4cc2d5628435689b.jpg&quot;}&apos;/&gt;
&lt;/RelativeLayout&gt;
&lt;/layout&gt;
</code></pre><p>然后在Activity里面定义相应的方法，用BindAdapter标注：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    DataBindingUtil.setContentView(this, R.layout.activity_data_binding);
}

@BindingAdapter({&quot;imageUrl&quot;})
public static void loadImage(ImageView imageView, String imageUrl) {
    Picasso.with(imageView.getContext()).load(imageUrl).into(imageView);
}
</code></pre><p> 要注意的两点一是在xml文件中要import static方法所在的类，第二点是方法要用BindAdaper备注，必须是一个public static方法，参数的顺序第一个必须是对应的View，往后的按照注解的参数来即可。</p>
<p>  <strong>是不是感觉开启了新世界的大门呢？</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/lion.jpg"
               alt="Stephen Zhang" />
          <p class="site-author-name" itemprop="name">Stephen Zhang</p>
          <p class="site-description motion-element" itemprop="description">Stephen Zhang's notes.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Zhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zsrcodingme"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
