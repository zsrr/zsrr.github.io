<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Stephen Zhang&apos;s notes.">
<meta property="og:type" content="website">
<meta property="og:title" content="Stephen's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Stephen's blog">
<meta property="og:description" content="Stephen Zhang&apos;s notes.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stephen's blog">
<meta name="twitter:description" content="Stephen Zhang&apos;s notes.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Stephen's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Stephen's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/10/MySQL锁机制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/10/MySQL锁机制/" itemprop="url">
                  MySQL锁机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-10T17:55:11+08:00">
                2017-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/10/MySQL锁机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/10/MySQL锁机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇将介绍MySQL锁机制的特点，主要拿MyISAM，InnoDB引擎进行分析。</p>
<h1 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h1><p>MyISAM引擎只支持表锁，这种锁的特点是加锁快，开销小，锁发生冲突的概率比较高，并行度较低。</p>
<h2 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h2><p>表级锁有两种模式：共享读锁和独占写锁，类似Java中的ReadWriteLock。多个线程可以共享一把读锁，但是会堵塞写线程的请求。当写锁被一个线程占有时，其他线程的读和写请求都会被堵塞。</p>
<h2 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h2><h3 id="自动加表锁"><a href="#自动加表锁" class="headerlink" title="自动加表锁"></a>自动加表锁</h3><p>MyISAM存储引擎在执行SELECT, UPDATE, INSERT, DELETE之前，会自动获取相应的所有的表锁，执行完毕之后，自动释放所有的表锁，这个过程不需要显式指定，用起来比较方便。</p>
<h3 id="手动加锁"><a href="#手动加锁" class="headerlink" title="手动加锁"></a>手动加锁</h3><p>手动加锁一般是为了模拟事务操作，要注意以下几点。</p>
<ol>
<li>在执行Lock Tables之后，只能访问加锁的表，自动更新也是如此。</li>
<li>获取读锁之后不能进行更新和插入操作。</li>
<li>同一个表在SQL中出现多少次，就需要对相同的别名锁定多少次。</li>
</ol>
<h2 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h2><p>MyISAM允许读写操作并发进行，存在系统变量concurrent_insert，专门控制并发插入的行为，其值有0，1，2。</p>
<ul>
<li>当设置为0时，不允许并发插入。</li>
<li>当设置为1时，如果表的中间没有被删除，那就允许其他用户在表的末尾并发插入。</li>
<li>当设置为2时，无论表是否存在空洞，都可以在表的末尾进行插入。</li>
</ul>
<h2 id="锁调度"><a href="#锁调度" class="headerlink" title="锁调度"></a>锁调度</h2><p>MyISAM默认给予写操作更高的优先级，这意味着如果一个读线程和一个写线程同时分别获得读锁和写锁，那写线程将会优先进行。即便读请求先到锁的等待队列，之后到达的写请求也会“插队”。要想降低写线程的优先级，可以采取以下办法：</p>
<ul>
<li>制定启动参数low-priority-updates，使存储引擎给写线程以更低的优先级。</li>
<li>设置参数LOW_PRIORITY_UPDATES = 1。</li>
<li>通过制定INSERT, UPDATE, DELETE语句的LOW_PRIORITY属性，降低语句的优先级。</li>
</ul>
<h1 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h1><p>InnoDB引擎支持事务，因此请先查看<a href="http://zsrr.coding.me/2017/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/" target="_blank" rel="external">数据库事务</a>。</p>
<p>InnoDB的锁类型这里不再赘述，有关内容请查看：<a href="http://www.zrray.com/art/247" target="_blank" rel="external">InnoDB锁模式</a></p>
<p>在这里主要记录以下几点：</p>
<h2 id="共享锁-S"><a href="#共享锁-S" class="headerlink" title="共享锁(S)"></a>共享锁(S)</h2><p>通过<strong>SELECT * FROM table_name WHERE … LOCK IN SHARE MODE</strong>获得共享锁，主要是确保一个事务在读取这些记录的时候，另一个事务对这些数据集的修改需等到前一个事务提交或回滚后进行。</p>
<h2 id="排他锁-X"><a href="#排他锁-X" class="headerlink" title="排他锁(X)"></a>排他锁(X)</h2><p>通过<strong>SELECT * FROM table_name WHERE … FOR UPDATE</strong>来获取。一个事务对一个数据集进行加锁之后，另一个事务对这个数据集的更新，删除，以及试图获取其共享锁的操作都会被阻塞，但是普通的SELECT操作不会被阻塞（返回的只是数据集的快照）。</p>
<h2 id="InnoDB行锁的实现方式"><a href="#InnoDB行锁的实现方式" class="headerlink" title="InnoDB行锁的实现方式"></a>InnoDB行锁的实现方式</h2><p>主要有三种实现方式：</p>
<ul>
<li><strong>Record Lock</strong> 对索引项进行加锁。</li>
<li><strong>Gap Lock</strong> 对索引项的“间隙”，第一条记录前的“间隙”或者最后一条记录后的“间隙”进行加锁。</li>
<li><strong>Next-key Lock</strong> 前两种的组合。</li>
</ul>
<p>InnoDB这种行锁实现方式意味着，如果不通过索引检索数据，那么InnoDB将对所有记录进行加锁，实际上的效果和表锁一样。</p>
<h2 id="行锁的注意事项"><a href="#行锁的注意事项" class="headerlink" title="行锁的注意事项"></a>行锁的注意事项</h2><h3 id="不通过索引检索数据，InnoDB会锁定表中的所有记录"><a href="#不通过索引检索数据，InnoDB会锁定表中的所有记录" class="headerlink" title="不通过索引检索数据，InnoDB会锁定表中的所有记录"></a>不通过索引检索数据，InnoDB会锁定表中的所有记录</h3><h3 id="InnoDB行锁针对索引加锁，不是根据记录加的锁"><a href="#InnoDB行锁针对索引加锁，不是根据记录加的锁" class="headerlink" title="InnoDB行锁针对索引加锁，不是根据记录加的锁"></a>InnoDB行锁针对索引加锁，不是根据记录加的锁</h3><p>访问不同行的记录，但是使用的是相同的索引键，会发生锁竞争，如下例所示：</p>
<pre><code>create table tab_with_index( id int not null, name varchar(30));
create index index_id on tab_with_index(id);

insert into tab_with_index values(1, &apos;1&apos;), (1, &apos;2&apos;);

...

# session1
select * from tab_with_index where id = 1 and name = &apos;1&apos; for update;

...

# session2
select * from tab_with_index where id = 1 and name = &apos;2&apos; for update;
# 等待
</code></pre><p>在上例中，由于id为1（id为索引）的记录在事务1中被加锁，因此尽管事务2访问的是不同行，也会被阻塞。</p>
<h3 id="不同的事务可以根据不同的索引获得不同的锁"><a href="#不同的事务可以根据不同的索引获得不同的锁" class="headerlink" title="不同的事务可以根据不同的索引获得不同的锁"></a>不同的事务可以根据不同的索引获得不同的锁</h3><p>如下例所示：</p>
<pre><code>create index name on tab_with_index(name);

insert into tab_with_index values(2, &apos;4&apos;);

# session1
select * from tab_with_index where id = 1 for update;

# session2
select * from tab_with_index where name = &apos;4&apos; for update;
# 立即返回数据，不会被阻塞。

select * from tab_with_index where name = &apos;2&apos; for update;
# 被阻塞，事务1对此数据集加了排他锁。
</code></pre><h3 id="Next-key-“间隙”加锁"><a href="#Next-key-“间隙”加锁" class="headerlink" title="Next-key “间隙”加锁"></a>Next-key “间隙”加锁</h3><p>“间隙”(Gap)的定义为：键值在条件范围内但是并不存在的记录，用在对键值进行范围条件查找时。</p>
<p>举个例子，假如test表中只有100条记录，其id值为1，2，3…100。这时在一个事务中执行如下语句：</p>
<pre><code>select * from test where id &gt;= 100 for update;
</code></pre><p>这时InnoDB不仅对id为100的实际存在的记录进行加锁，而且对id大于100但是实际上不存在的记录进行加锁。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/09/SQL优化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/09/SQL优化/" itemprop="url">
                  SQL优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-09T14:41:57+08:00">
                2017-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/09/SQL优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/09/SQL优化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇详细记录SQL优化的一般步骤，以MySQL为例。</p>
<h1 id="通过EXPLAIN语句分析SQL"><a href="#通过EXPLAIN语句分析SQL" class="headerlink" title="通过EXPLAIN语句分析SQL"></a>通过EXPLAIN语句分析SQL</h1><p>EXPLAIN通常用来分析select子句，返回的数据格式为：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>select标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>select类型</td>
</tr>
<tr>
<td>type</td>
<td>访问类型</td>
</tr>
<tr>
<td>possible_keys</td>
<td>查询设计到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引</td>
</tr>
<tr>
<td>key_length</td>
<td>使用的索引的长度</td>
</tr>
<tr>
<td>ref</td>
<td>哪些列或常量用于匹配索引的值</td>
</tr>
<tr>
<td>extra</td>
<td>关于查询的详细信息</td>
</tr>
</tbody>
</table>
<h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><p>此列记录了select的类型，主要有以下几种：</p>
<ul>
<li><strong>SIMPLE</strong> 简单查询，不使用<strong>UNION</strong>和子查询。</li>
<li><strong>PRIMARY</strong> 若查询中包括子查询，则此项说明是最外边的查询。</li>
<li><strong>UNION</strong> UNION中第二个SELECT语句。</li>
<li><strong>SUBQUERY</strong> 子查询中第一个SELECT。</li>
<li><strong>DERIVED</strong> FROM子句中的子查询。</li>
</ul>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>访问类型，性能从好到坏排序可以分成以下几个部分：</p>
<ul>
<li><strong>system</strong> 表中只有一行。</li>
<li><strong>const</strong> 单表中至多有一个数据项可以匹配，用在PRIMARY KEY和UNIQUE INDEX和常量进行”=”比较的情况。</li>
<li><strong>eq_ref</strong> 在多表连接当中，使用PRIMARY KEY或者UNIQUE INDEX进行比较。</li>
<li><strong>ref</strong> 与eq_ref类似，但是不使用PRIMARY KEY和UNIQUE INDEX。</li>
<li><strong>range</strong> 根据索引进行范围内搜索。</li>
<li><strong>index</strong> 遍历索引就能获得相应的数据，通常比遍历整个表要快，但是也不一定，当数据量较小的时候MySQL可能仍会选择遍历整个表。</li>
<li><strong>all</strong> 遍历整个表，通常比较慢，当数据量较大的时候需要优化。</li>
</ul>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>ref是记录了哪些列或者常量被用来和索引进行比较，如果值为func的话，那就是从某个函数返回的值进行比较。</p>
<h1 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h1><p>可以通过<strong>show profile</strong>语句来查看一个query语句消耗了多长时间。要想查询特定的查询语句，需要先执行<strong>show profiles</strong>（先将profiling变量设置为1），执行的结果如图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-09%20%E4%B8%8B%E5%8D%8810.49.40.png" alt=""><br>上图列出了之前查询语句的id，耗时和语句详情，要想查看一个具体的查询语句的耗时情况，执行show profile for query [<em>query_id</em>]:</p>
<pre><code>show profile for query 7;
</code></pre><p>执行结果如图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-09%20%E4%B8%8B%E5%8D%8811.01.04.png" alt=""></p>
<p><strong>注：</strong>上图中sending data过程是MySQL从表中读取数据并把结果返回给客户的过程，往往是整个过程最耗时的操作。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="使用索引的情况"><a href="#使用索引的情况" class="headerlink" title="使用索引的情况"></a>使用索引的情况</h2><h3 id="匹配全值"><a href="#匹配全值" class="headerlink" title="匹配全值"></a>匹配全值</h3><p>即对where子句中所有的索引列指定一个具体值。</p>
<h3 id="匹配值的范围查询"><a href="#匹配值的范围查询" class="headerlink" title="匹配值的范围查询"></a>匹配值的范围查询</h3><p>对索引的值能够进行范围查找（Hash索引不支持）。</p>
<h3 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h3><p>仅仅使用复合索引的最左边列进行查找，如有col1 + col2 + col3的复合索引，可以针对col1, col1 + col2, col1 + col2 + col3, col1 + col3进行查找，但是不能对col2, col3, col2 + col3进行查找，这是B-Tree索引使用时的首要准则。</p>
<h3 id="仅仅对索引进行查询"><a href="#仅仅对索引进行查询" class="headerlink" title="仅仅对索引进行查询"></a>仅仅对索引进行查询</h3><p>当要查询的列都是索引的时候，MySQL会在索引中直接查找，因为索引的大小通常比原表小得多，所以查询的速度要比原表要快，此时Extra信息中会提示：Using index。</p>
<h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>仅仅匹配索引第一列的部分，前缀索引不适合<strong>order by group by</strong>子句</p>
<h3 id="ICP特性"><a href="#ICP特性" class="headerlink" title="ICP特性"></a>ICP特性</h3><p>MySQL 5.6引入了Index Condition Pushdown特性，将操作过滤（下放）到存储引擎。</p>
<p>如有一复合索引col1 + col2，查询条件为：col1 = … and col2 &gt; …，那么在MySQL 5.6之前的版本，数据库先根据复合索引的首字段col1来过滤出满足第一个条件的记录，然后回表查找记录（此时为Using where），最后根据第二个条件过滤之前查找的记录。MySQL 5.6之后，则把col2的过滤下放到底层存储引擎层来完成，这样能减少不必要的io操作，提高性能。</p>
<h2 id="存在索引但是不能使用索引的情况"><a href="#存在索引但是不能使用索引的情况" class="headerlink" title="存在索引但是不能使用索引的情况"></a>存在索引但是不能使用索引的情况</h2><h3 id="以-开头的like查询不能够使用B-Tree索引"><a href="#以-开头的like查询不能够使用B-Tree索引" class="headerlink" title="以%开头的like查询不能够使用B-Tree索引"></a>以%开头的like查询不能够使用B-Tree索引</h3><p>由于B-Tree索引的结构，以%开头的like查询不能够使用B-Tree索引，一般采用<a href="http://www.cnblogs.com/tommy-huang/p/4483684.html" target="_blank" rel="external">全文索引</a>来解决此类问题。</p>
<h3 id="数据出现隐式转换的时候不能使用索引"><a href="#数据出现隐式转换的时候不能使用索引" class="headerlink" title="数据出现隐式转换的时候不能使用索引"></a>数据出现隐式转换的时候不能使用索引</h3><p>例如：</p>
<pre><code>select * from actor where name = 1;
</code></pre><p>name为varchar类型，但是给予的比较常量是一个int类型，这时候即便name是一个索引，查询仍不能使用此索引。</p>
<h3 id="复合索引不满足最左原则的情况下不能够被使用"><a href="#复合索引不满足最左原则的情况下不能够被使用" class="headerlink" title="复合索引不满足最左原则的情况下不能够被使用"></a>复合索引不满足最左原则的情况下不能够被使用</h3><h3 id="如果查找索引比查找表更慢，那么索引不会被使用"><a href="#如果查找索引比查找表更慢，那么索引不会被使用" class="headerlink" title="如果查找索引比查找表更慢，那么索引不会被使用"></a>如果查找索引比查找表更慢，那么索引不会被使用</h3><p>在数据量较小或者索引比表大的情况下（极少出现），扫描索引会比直接扫描表更慢，这时索引不会被使用。</p>
<h3 id="用or分隔开的条件，前面有索引而后面没有，索引不被使用"><a href="#用or分隔开的条件，前面有索引而后面没有，索引不被使用" class="headerlink" title="用or分隔开的条件，前面有索引而后面没有，索引不被使用"></a>用or分隔开的条件，前面有索引而后面没有，索引不被使用</h3><h1 id="常用的优化方法"><a href="#常用的优化方法" class="headerlink" title="常用的优化方法"></a>常用的优化方法</h1><h2 id="定期优化表"><a href="#定期优化表" class="headerlink" title="定期优化表"></a>定期优化表</h2><p>如果表中绝大部分数据已经被删除，并且包含可变长度的列，那么可以通过OPTIMIZE TABLE [TABLE_NAME]进行优化，这个命令可以将表中空间碎片进行整合，消除由于删除更新而带来的空间浪费。</p>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="大量导入数据"><a href="#大量导入数据" class="headerlink" title="大量导入数据"></a>大量导入数据</h3><p>对于MyISAM的表来说，可以通过以下方式快速导入数据：</p>
<pre><code>ALTER TABLE tab_name DISABLE KEYS;
#load data
ALTER TABLE tab_name ENABLE KEYS;
</code></pre><p>再导入数据前先关闭非唯一索引的更新，导入完成后再打开。</p>
<p>对于InnoDB表来说，导入的数据按照主键进行排序，可以有效地提高数据导入的效率。</p>
<p>在导入数据之前，关闭唯一性检验（SET UNIQUE_CHECK = 0），导入完成后打开，可以提高数据导入的效率。</p>
<h3 id="优化INSERT语句"><a href="#优化INSERT语句" class="headerlink" title="优化INSERT语句"></a>优化INSERT语句</h3><p>当插入很多行是，应尽量使用多个值表的INSERT语句，比单个INSERT语句执行快得多。</p>
<p>当导入大量数据时，从文本中导入数据比INSERT语句快得多。</p>
<h3 id="优化ORDER-BY子句"><a href="#优化ORDER-BY子句" class="headerlink" title="优化ORDER BY子句"></a>优化ORDER BY子句</h3><h4 id="MySQL排序方式"><a href="#MySQL排序方式" class="headerlink" title="MySQL排序方式"></a>MySQL排序方式</h4><h5 id="索引顺序扫描"><a href="#索引顺序扫描" class="headerlink" title="索引顺序扫描"></a>索引顺序扫描</h5><p>通过有序索引顺序扫描直接返回有效的数据，操作效率高。</p>
<h5 id="Filesort排序"><a href="#Filesort排序" class="headerlink" title="Filesort排序"></a>Filesort排序</h5><p>对返回数据进行排序，所有不是通过索引直接返回排序结果的排序都是Filesort排序，此时Extra信息中存在Using filesort。</p>
<p>所以，应尽量保证索引顺序和ORDER BY后面的顺序相同，避免Filesort排序，有关Filesort的详细信息及底层算法，参见：<a href="http://www.cnblogs.com/cchust/p/5304594.html" target="_blank" rel="external">MySQL排序原理与案例分析</a></p>
<p>总结： </p>
<p>下列情况可以使用索引：</p>
<pre><code>SELECT * FROM TABLE_NAME ORDER BY KET_PART_1, KEY_PART2...;
SELECT * FROM TABLE_NAME WHERE KEY_PART_1 = XXX ORDER BY KEY_PART_2;
SELECT * FROM TABLE_NAME WHERE KEY = XXX ORDER BY KEY;
SELECT * FROM TABLE_NAME WHERE KEY_PART_1 = XXX ORDER BY KEY_PART_1 DESC, KEY_PART_2 DESC;
</code></pre><p>以下情况不可以：</p>
<pre><code>SELECT * FROM TABLE_NAME ORDER BY KEY_PART_1 DESC, KEY_PART_2 ASC;
SELECT * FROM TABLE_NAME WHERE KEY1 = XXX ORDER BY KEY2;
SELECT * FROM TABLE_NAME ORDER BY KEY1, KEY2;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/数据库事务/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/15/数据库事务/" itemprop="url">
                  数据库事务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-15T19:14:29+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/15/数据库事务/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/15/数据库事务/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库事务的基本概念"><a href="#数据库事务的基本概念" class="headerlink" title="数据库事务的基本概念"></a>数据库事务的基本概念</h1><p>一个数据库事务包含了一系列对数据库的读／写操作。事务的回滚提供了从失败状态中恢复到正常状态的方法，同时隔离方法为并发访问数据库提供了可能。</p>
<h1 id="ACID性质"><a href="#ACID性质" class="headerlink" title="ACID性质"></a>ACID性质</h1><ul>
<li>原子性(Atomicity)：事务作为一个整体被提交，要么全部执行，要么全部不执行。</li>
<li>一致性(Consistency)：事务的提交确保数据库从一个一致状态转移到另外一个一致状态，一致状态是指数据库中的数据应该满足完整性约束。</li>
<li>隔离性(Isolation)：在事务隔离的状态下，一个事务的执行不影响其他事务的执行。</li>
<li>持久性(Durability)：事务中包含的更改在数据库中永久保存。</li>
</ul>
<h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><p>光靠几个概念是不能掌握数据库事务的，在这里通过MySQL来探查数据库事务。</p>
<p><strong>注：MySQL中只有开启了Innodb引擎的数据库或者表才支持事务操作</strong></p>
<p>在终端开启MySQL，执行下列测试:</p>
<pre><code>mysql&gt; use transaction;
Database changed

mysql&gt; create table transaction_test(
    -&gt;   id int
    -&gt; ) engine = innodb;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into transaction_test values(5);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into transaction_test values(10);
Query OK, 1 row affected (0.00 sec)

mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from transaction_test;
+------+
| id   |
+------+
|    5 |
|   10 |
+------+
2 rows in set (0.00 sec)

mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into transaction_test values(11);
Query OK, 1 row affected (0.00 sec)

mysql&gt; rollback;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into transaction_test values(12);
Query OK, 1 row affected (0.01 sec)

mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from transaction_test;
+------+
| id   |
+------+
|    5 |
|   10 |
|   12 |
+------+
3 rows in set (0.00 sec)
</code></pre><h1 id="事务隔离等级"><a href="#事务隔离等级" class="headerlink" title="事务隔离等级"></a>事务隔离等级</h1><p>事务隔离定义了一个事务操作的结果何时对另一个事务可见。事务的隔离等级是为了防止以下几种不正常的读现象发生：</p>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>当一个事务允许读到另一个事务更改但未提交的数据时，会发生脏读。</p>
<p>假如有以下名为persons的表格：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>zsr</td>
<td>19</td>
</tr>
<tr>
<td>cjr</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>有两个事务：</p>
<p>事务一：</p>
<pre><code>select age from persons where name = &apos;zsr&apos;; #2
</code></pre><p>事务二：</p>
<pre><code>update persons set age = 20 where name = &apos;zsr&apos;; #1

rollback; #3
</code></pre><p>注释后面的数字代表执行的顺序，事务二更新语句执行之后事务一读到的年龄是20，此时事务二进行回滚，那么事务一读到的便是一个脏数据。</p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>和脏读类似，其定义是一个事务重复读取同一行但是获得了不同的数据。</p>
<p>接着上一个表格，有两个事务：</p>
<p>事务一：</p>
<pre><code>select age from persons where name = &apos;zsr&apos;; #1

select age from persons where name = &apos;zsr&apos;; #4
</code></pre><p>事务二：</p>
<pre><code>update persons set age = 20 where name = &apos;zsr&apos;; #2

commit; #3
</code></pre><p>语句后面的数字代表执行顺序，事务一读取同一行获得了不同的数据。</p>
<h2 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h2><p>当一个事务对某个表格插入／删除行时，此行位于另一个事务查询的范围，这时另一个事务执行两次相同的查询产生两个不同的结果集，问题的产生是以表为单位的。</p>
<p>接着上面的表格，有两个事务：</p>
<p>事务一：</p>
<pre><code>select * from persons where age between 19 and 21; #1

select * from persons where age between 19 and 21; #4
</code></pre><p>事务二：</p>
<pre><code>insert into persons values (&apos;zxq&apos;, 20); #2
commit; #3
</code></pre><p>除了不正常的读现象之外，还有丢失更新的异常。丢失更新是指多个事务基于同一行的数据进行更改，最后一个事务提交的更新会覆盖另一个事务已经提交的更新。</p>
<h2 id="隔离等级"><a href="#隔离等级" class="headerlink" title="隔离等级"></a>隔离等级</h2><p>数据库为事务提供了四个隔离等级，如下所示：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻象读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITED</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>READ COMMITED</td>
<td>不允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>REPEATEDLY READ</td>
<td>不允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
</tbody>
</table>
<p>隔离等级和并发性是相对的，一般来说，隔离等级越高并发性越低。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/24/Android-Proguard/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/Android-Proguard/" itemprop="url">
                  Android ProGuard
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-24T11:06:25+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/24/Android-Proguard/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/24/Android-Proguard/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先附上一个github地址： <a href="https://github.com/krschultz/android-proguard-snippets" target="_blank" rel="external">android-proguard-snippets</a>，里面记录了各种库的ProGuard规则。</p>
<h1 id="ProGuard简介"><a href="#ProGuard简介" class="headerlink" title="ProGuard简介"></a>ProGuard简介</h1><p>ProGuard是用来压缩，最优化，混淆，预检验Java代码的工具，能够防止class文件被反编译以及减小最终生成的程序的大小，其工作流程图如下图所示(图片来自官方文档):</p>
<p><img src="https://www.guardsquare.com/files/media/guardsquare2016/Website/ProGuard/ProGuard_build_process.png" alt=""></p>
<p>ProGuard要求制定Library jars，以此来重新组织class文件的依赖关系，Library jars通常是保持不变的。</p>
<p>代码的某些地方不能被混淆，如main方法，这些地方称为入口点(Entry Points)。反射时用到的类、方法、属性名也不能被混淆。</p>
<h1 id="ProGuard的使用"><a href="#ProGuard的使用" class="headerlink" title="ProGuard的使用"></a>ProGuard的使用</h1><p>先附上下载地址：<a href="http://ok34fi9ya.bkt.clouddn.com/proguard5.3.3.zip" target="_blank" rel="external">ProGuard 5.3.3下载地址</a></p>
<p>下载完成之后切换到bin目录，在终端执行：</p>
<pre><code>sh proguard.sh [options]
</code></pre><p>也可以运行proguardgui.sh来开启图形界面。</p>
<h2 id="ProGuard-Options"><a href="#ProGuard-Options" class="headerlink" title="ProGuard Options"></a>ProGuard Options</h2><p>options通常写在一个单独的configuration file里面，并且可以递归地读取配置文件，下面来介绍几个最常见的Options。</p>
<h3 id="Input-Output-Options"><a href="#Input-Output-Options" class="headerlink" title="Input/Output Options"></a>Input/Output Options</h3><h4 id="inlcude-filename"><a href="#inlcude-filename" class="headerlink" title="-inlcude filename"></a>-inlcude <em>filename</em></h4><p>读取配置文件，可以在配置文件中声明表示递归地读取。</p>
<h4 id="basedirectory-directoryname"><a href="#basedirectory-directoryname" class="headerlink" title="-basedirectory directoryname"></a>-basedirectory <em>directoryname</em></h4><p>声明配置文件的相对位置。</p>
<h4 id="injars-class-path"><a href="#injars-class-path" class="headerlink" title="-injars class_path"></a>-injars <em>class_path</em></h4><p>指定需要处理的jar文件。jar中的class文件将被处理，并将处理之后的class文件写到output jars。默认情况下非class文件将只进行复制处理。</p>
<h4 id="outjars-class-path"><a href="#outjars-class-path" class="headerlink" title="-outjars class_path"></a>-outjars <em>class_path</em></h4><p>指定output jars的名字，应该避免output jars重写掉input files。</p>
<h4 id="libraryjars-class-path"><a href="#libraryjars-class-path" class="headerlink" title="-libraryjars class_path"></a>-libraryjars <em>class_path</em></h4><p>指定应用的库文件，这些文件不会再output jars里面出现。被应用中的类继承的class需要被指定，用到的class不用被指定，但是指定它们有助于最优化代码。</p>
<h4 id="skipnonpubliclibraryclasses"><a href="#skipnonpubliclibraryclasses" class="headerlink" title="-skipnonpubliclibraryclasses"></a>-skipnonpubliclibraryclasses</h4><p>用来指定处理Library jars的时候跳过非公有类，以此来节省ProGuard运行时所占的时间和空间，但是不能总是指定这个选项，例如当某些类库中的非公有类被公有类继承的时候。</p>
<h4 id="dontskipnonpubliclibraryclasses"><a href="#dontskipnonpubliclibraryclasses" class="headerlink" title="-dontskipnonpubliclibraryclasses"></a>-dontskipnonpubliclibraryclasses</h4><p>上一个选项的反义词，从版本4.5开始这是默认选项。</p>
<h4 id="dontskipnonpubliclibraryclassmembers"><a href="#dontskipnonpubliclibraryclassmembers" class="headerlink" title="-dontskipnonpubliclibraryclassmembers"></a>-dontskipnonpubliclibraryclassmembers</h4><p>指定不要忽略包级私有类的成员（属性和方法）。由于这些类不经常被应用程序所引用，因此忽略它们是ProGuard的默认选项，但是在某些情况下不能忽略，例如应用程序的类与它们处在同一个包中，这时候被引用的包级私有类不能被忽略。</p>
<h4 id="keepdirectories-directory-filter"><a href="#keepdirectories-directory-filter" class="headerlink" title="-keepdirectories [directory_filter]"></a>-keepdirectories [<em>directory_filter</em>]</h4><p>指定需要在Output jars里面保留的文件夹名。如果directory_filter为空，那么所有的文件夹都将被保存。</p>
<h4 id="target-version"><a href="#target-version" class="headerlink" title="-target version"></a>-target <em>version</em></h4><p>指定class文件的级别。</p>
<h4 id="forceprocessing"><a href="#forceprocessing" class="headerlink" title="-forceprocessing"></a>-forceprocessing</h4><p>对class文件进行强制处理，即便输出看起来是过时的。</p>
<h3 id="Keep-Options"><a href="#Keep-Options" class="headerlink" title="Keep Options"></a>Keep Options</h3><h4 id="keep-modifier-…-class-specification"><a href="#keep-modifier-…-class-specification" class="headerlink" title="-keep [,modifier,…] class_specification"></a>-keep [,<em>modifier</em>,…] <em>class_specification</em></h4><p>指定类和类的成员当作入口点，例如一个Java应用程序的入口类以及main方法，对于类库来说，所有的public元素都应该当作入口点。此指令会保护类和其成员不被混淆和删除。</p>
<h4 id="keepclassmembers-modifier-…-class-specification"><a href="#keepclassmembers-modifier-…-class-specification" class="headerlink" title="-keepclassmembers [,modifier,…] class_specification"></a>-keepclassmembers [,<em>modifier</em>,…] <em>class_specification</em></h4><p>指定保护类的成员，例如，实现了Serializable接口的用于序列化的类成员应该被保护。此指令会保证类成员不会被混淆和删除。</p>
<h4 id="keepclasseswithmembers-modifier-…-class-specification"><a href="#keepclasseswithmembers-modifier-…-class-specification" class="headerlink" title="-keepclasseswithmembers [,modifier,…] class_specification"></a>-keepclasseswithmembers [,<em>modifier</em>,…] <em>class_specification</em></h4><p>指定保护拥有指定类成员的类及指定类成员。如在一个Java程序中，要保护拥有main方法的类，可以用这个指令，而不用一一列举。</p>
<h4 id="keepnames-class-specification"><a href="#keepnames-class-specification" class="headerlink" title="-keepnames class_specification"></a>-keepnames <em>class_specification</em></h4><p>指定类的名称不会被混淆，前提是在压缩代码的时候此类仍然存在，仅在混淆阶段起作用。</p>
<h4 id="keepclassmembernames-class-specification"><a href="#keepclassmembernames-class-specification" class="headerlink" title="-keepclassmembernames class_specification"></a>-keepclassmembernames <em>class_specification</em></h4><p>指定类成员的名字不会被混淆。仅在混淆阶段起作用，前提是Shrink过后类成员仍然存在。</p>
<h4 id="keepclasseswithmembernames-class-specification"><a href="#keepclasseswithmembernames-class-specification" class="headerlink" title="-keepclasseswithmembernames class_specification"></a>-keepclasseswithmembernames <em>class_specification</em></h4><p>指定拥有指定类成员的类及指定类成员的名字不会被混淆，如要保护一个拥有本地方法的类名和其本地方法的名字不被混淆。仅在混淆阶段起作用。</p>
<p>关于以上几个 -keep选项，详见下表：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%884.21.32.png" alt="来自官方文档"></p>
<h3 id="Shirinking-Options（非重点）"><a href="#Shirinking-Options（非重点）" class="headerlink" title="Shirinking Options（非重点）"></a>Shirinking Options（非重点）</h3><h4 id="dontshrink"><a href="#dontshrink" class="headerlink" title="-dontshrink"></a>-dontshrink</h4><p>指定不压缩代码，默认情况下，除了被上述多样的 -keep选项保护起来的类和类成员，以及它们直接或者间接依赖的类不被压缩外，其余的都不会被保留。</p>
<h3 id="Optimization-options（非重点）"><a href="#Optimization-options（非重点）" class="headerlink" title="Optimization options（非重点）"></a>Optimization options（非重点）</h3><h4 id="dontoptimize"><a href="#dontoptimize" class="headerlink" title="-dontoptimize"></a>-dontoptimize</h4><p>指定不进行最优化，默认开启。</p>
<h4 id="optimizationpasses-n"><a href="#optimizationpasses-n" class="headerlink" title="-optimizationpasses n"></a>-optimizationpasses n</h4><p>指定ProGuard进行对代码进行最优化的次数。</p>
<h4 id="optimizations"><a href="#optimizations" class="headerlink" title="-optimizations"></a>-optimizations</h4><p>指定优化时所采取的算法，属于高级选项，关于optimizations filter，请查看：<a href="https://www.guardsquare.com/en/proguard/manual/optimizations" target="_blank" rel="external">optimizations</a></p>
<h4 id="assumenosideeffects-class-specification"><a href="#assumenosideeffects-class-specification" class="headerlink" title="-assumenosideeffects class_specification"></a>-assumenosideeffects <em>class_specification</em></h4><p>指定无关紧要的方法，ProGuard会在优化阶段去除对此方法所有的调用，例如可以去除打log的方法调用，注意此举是危险的，除非我们能够确定一个方法在整个应用程序中是绝对没有用处的，否则不要轻易指定。</p>
<h4 id="mergeinterfacesaggressively"><a href="#mergeinterfacesaggressively" class="headerlink" title="-mergeinterfacesaggressively"></a>-mergeinterfacesaggressively</h4><p>合并接口，能够减少最终输出类的数目，缩小体积。不过在某些Java虚拟机上会带来性能的损失。</p>
<p><strong>注：</strong>Android Studio默认的配置文件最优化是不开启的，因为Android Java虚拟机对于优化和预检验的代码不友好。</p>
<h3 id="Obfuscation-options"><a href="#Obfuscation-options" class="headerlink" title="Obfuscation options"></a>Obfuscation options</h3><h4 id="dontobfuscate"><a href="#dontobfuscate" class="headerlink" title="-dontobfuscate"></a>-dontobfuscate</h4><p>指定关闭混淆，混淆默认是开启的，除了被 -keep选项保护起来的类和类成员，其余的类和类成员都被赋予了随机的名字。</p>
<h4 id="applymapping-filename"><a href="#applymapping-filename" class="headerlink" title="-applymapping filename"></a>-applymapping <em>filename</em></h4><p>重新利用指定file中的映射集，在此文件中列出的类和类成员被赋予映射集文件中指定的名字，没有在其中列举的但出现在输入中的类和类成员被赋予新的名字。</p>
<h4 id="overloadaggressively"><a href="#overloadaggressively" class="headerlink" title="-overloadaggressively"></a>-overloadaggressively</h4><p>允许重载，很多类属性和方法会得到相同的名称，只要方法的参数名不同或者返回值不同（遵守Java的约定），这会使得输出的体积更小，不过很多虚拟机并不支持此选项，小心使用。</p>
<h4 id="useuniqueclassmembernames"><a href="#useuniqueclassmembernames" class="headerlink" title="-useuniqueclassmembernames"></a>-useuniqueclassmembernames</h4><p>为名字相同的类成员指派相同的混淆名</p>
<h4 id="dontusemixedcaseclassnames"><a href="#dontusemixedcaseclassnames" class="headerlink" title="-dontusemixedcaseclassnames"></a>-dontusemixedcaseclassnames</h4><p>指定不用大小写混合的混淆名，这在大小写不敏感的操作系统（如Mac OS）上尤其有用。</p>
<h4 id="keeppackagenames-package-filter"><a href="#keeppackagenames-package-filter" class="headerlink" title="-keeppackagenames [package_filter]"></a>-keeppackagenames [<em>package_filter</em>]</h4><p>指定的包名不会被混淆。</p>
<h4 id="keepattributes-attribute-filter"><a href="#keepattributes-attribute-filter" class="headerlink" title="-keepattributes [attribute_filter]"></a>-keepattributes [<em>attribute_filter</em>]</h4><p>指定不会被混淆的属性，具体支持的属性，请查看：<a href="https://www.guardsquare.com/en/proguard/manual/attributes" target="_blank" rel="external">属性列表</a> </p>
<p>例如，为了便于调试，需要保存异常信息，则需要以下选项：</p>
<pre><code>-keepattributes SourceFile,LineNumberTable
</code></pre><h4 id="keepparameternames"><a href="#keepparameternames" class="headerlink" title="-keepparameternames"></a>-keepparameternames</h4><p>保证方法的参数名不被混淆。</p>
<h3 id="Preverification-options"><a href="#Preverification-options" class="headerlink" title="Preverification options"></a>Preverification options</h3><p>Android Java虚拟机对其支持的不友好，默认关闭，在此不再列举该选项。</p>
<p><strong>以上内容大部分为常用的，ProGuard的用法实在是太多了，没有必要在这里一一列举，混淆和保存选项是重要内容，其余请查看官方文档。</strong></p>
<h3 id="class-specification"><a href="#class-specification" class="headerlink" title="class_specification"></a>class_specification</h3><p>用来指定类和其成员的语句，用在 -keep选项和 -assumenosideeffects选项当中，模板设计的风格非常像Java，还有很多通配符，具体的格式如下：</p>
<pre><code>[@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname
[extends|implements [@annotationtype] classname]
[{
    [@annotationtype] [[!]public|private|protected|static|volatile|transient ...] &lt;fields&gt; |
                                                                      (fieldtype fieldname);
    [@annotationtype] [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...] &lt;methods&gt; |
                                                                                           &lt;init&gt;(argumenttype,...) |
                                                                                           classname(argumenttype,...) |
                                                                                           (returntype methodname(argumenttype,...));
    [@annotationtype] [[!]public|private|protected|static ... ] *;
    ...
}]
</code></pre><p>方括号[]代表内部的内容是可选的。</p>
<p>…代表前面几个是可以进行多个选择的。</p>
<p>classame必须写全称，例如java.lang.String。对于内部类来讲，类名前面和外部类后面要有”$”分隔。例如：<code>java.lang.Thread$State</code>。classname里面可以有如下的通配符：</p>
<ul>
<li>?：匹配任意一个字符。</li>
<li>*：匹配任何不带.的语句，不能够匹配带有.号的包名。</li>
<li>**：可以匹配带有.的语句，专门用来匹配带有.的包名。</li>
</ul>
<p>@annotationtype代表限制被注解类型注释的类，annotationtype和上述classname的规则是一样的。</p>
<p>属性和方法名大部分和Java中是一样的，除了方法中参数列表只包含参数类型不包含参数名称，属性和方法名还可以包含以下通配符：</p>
<ul>
<li>&lt;init&gt; 匹配所有的构造函数。</li>
<li>&lt;fields&gt; 匹配所有的属性。</li>
<li>&lt;methods&gt; 匹配所有的方法。</li>
<li><ul>
<li>匹配所有的方法和属性。</li>
</ul>
</li>
</ul>
<p>类型描述符可以包含以下通配符：</p>
<ul>
<li>% 匹配任何值类型，如boolean, int等等。</li>
<li>？ 匹配引用类型中的单个字符。</li>
<li><ul>
<li>匹配不带.的引用类型。</li>
</ul>
</li>
<li>** 匹配带有包名的引用类型，但不匹配数组类型。</li>
<li><em>*</em> 匹配任何类型，包括值类型和引用类型，以及数组类型。</li>
<li>… 匹配任意数量的任意类型。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/14/Java-ORM解决方案/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/14/Java-ORM解决方案/" itemprop="url">
                  Java ORM解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-14T15:31:14+08:00">
                2017-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/14/Java-ORM解决方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/14/Java-ORM解决方案/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>此篇部分内容，图片来自<a href="http://ok34fi9ya.bkt.clouddn.com/jpa_tutorial.pdf" target="_blank" rel="external">JPA Tutorial</a></p>
<h1 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h1><p>对象关系映射(Object Relational Mapping)，用面向对象的语言实现了数据的转换，存储等操作。</p>
<h1 id="Java-ORM解决方案"><a href="#Java-ORM解决方案" class="headerlink" title="Java ORM解决方案"></a>Java ORM解决方案</h1><h2 id="Java-Persistence-Api"><a href="#Java-Persistence-Api" class="headerlink" title="Java Persistence Api"></a>Java Persistence Api</h2><p>Java持久化API（以下简称JPA），是从EJB发展而来的Java ORM框架。</p>
<h3 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h3><p>其主要结构如下图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.11.50.png" alt=""><br>主要组成部分有下面几个：</p>
<ul>
<li><strong>POJO class</strong>此种类定义了像id, name等等基本属性，相当于关系数据库的表。</li>
<li><strong>Service class</strong>此种类实现了与数据库进行操作，包括获取对象，删除对象，更新对象等操作。</li>
<li><strong>JPA Provider</strong>由各大厂商提供的对JPA的具体实现，如Eclipselink, Toplink, Hibernate等等。</li>
<li><strong>Mapping file</strong>用来定义POJO class和关系数据库的映射关系。</li>
</ul>
<p>除了Mapping file，JPA还提供了各种形式的注解来定义POJO class和关系数据库之间的映射关系，主要的几个注解如下：</p>
<ul>
<li><strong>@Entity</strong>用来声明一个将要和关系数据库发生映射的POJO class。</li>
<li><strong>@Table</strong>用来声明此类对应的表名, schema和catalog。</li>
<li><strong>@Basic</strong>通常用来声明属性的加载方式。</li>
<li><strong>@Id</strong>用来声明POJO class对应的表的主键。</li>
<li><strong>@GeneratedValue</strong>用来指定主键的生成策略。</li>
<li><strong>@Column</strong>用来声明属性对应的列。</li>
</ul>
<p>此外，POJO class应该具备Java Bean的标准形式。</p>
<h3 id="用IntelliJ-IDEA建立JPA项目"><a href="#用IntelliJ-IDEA建立JPA项目" class="headerlink" title="用IntelliJ IDEA建立JPA项目"></a>用IntelliJ IDEA建立JPA项目</h3><p>笔者采用的环境是IDEA 2017.1.1，Hibernate 5.2.9，JPA 2.1。注意Hibernate的版本要和JPA的版本对应，不然会出错。</p>
<h4 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h4><p><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.37.05.png" alt=""><br>勾选JavaEE Persistence项目，下面指定JPA的版本为2.1，Provider为Hibernate，建好项目后整个项目的结构如图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.42.46.png" alt=""></p>
<h4 id="加入Hibernate以及数据库驱动依赖"><a href="#加入Hibernate以及数据库驱动依赖" class="headerlink" title="加入Hibernate以及数据库驱动依赖"></a>加入Hibernate以及数据库驱动依赖</h4><p>笔者采用的是h2数据库，将相应的依赖包放在lib目录下，对用的jar依赖包的下载地址：<a href="http://ok34fi9ya.bkt.clouddn.com/jpa-with-hibernate.zip" target="_blank" rel="external">h2以及Hibernate依赖包</a></p>
<p>将jar包放在lib文件夹之后，打开Project Struture，找到项目对应的Module，为其添加dependicies:<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%887.59.23.png" alt=""></p>
<h4 id="配置persistence-xml文件"><a href="#配置persistence-xml文件" class="headerlink" title="配置persistence.xml文件"></a>配置persistence.xml文件</h4><p>此文件定义了数据源，映射类等基本信息，且一定要在项目类路径下的META-INF文件夹下，笔者采用的是h2数据库，配置如下：</p>
<pre><code>&lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; version=&quot;2.1&quot;&gt;

    &lt;persistence-unit name=&quot;HibernatePersistenceUnit&quot;&gt;
        &lt;!--定义Provider--&gt;
        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
        &lt;properties&gt;
            &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:h2:~/test/test&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;org.h2.Driver&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;sa&quot;/&gt;
            &lt;!--&lt;property name=&quot;hibernate.connection.password&quot; value=&quot;&quot;/&gt;--&gt;
            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot;/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</code></pre><p>注意，笔者采用的是h2嵌入式数据库，因此不用提供用户的密码，还要注意里面的hbm2ddl.auto属性，此属性的值在这里是create，意味着应用程序每次启动都会创建一个新的表格，而上一次启动创建的表格将不复存在，关于此属性更多的内容，请见：<a href="http://blog.csdn.net/kjfcpua/article/details/4272415" target="_blank" rel="external">hibernate.hbm2ddl.auto属性配置</a></p>
<p>至此，项目的基本配置完毕。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>此小节通过小小的例子来阐述JPA的基本使用。</p>
<p>Employee.java:</p>
<pre><code>@Entity
@Table(name = &quot;Employee&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Employee {
    @Id
    private int eid;
    private String ename;
    private double salary;
    private String deg;

    public Employee(String ename, double salary, String deg) {
        this.ename = ename;
        this.salary = salary;
        this.deg = deg;
    }

    public Employee() {

    }

    public int getEid() {
        return eid;
    }

    public void setEid(int eid) {
        this.eid = eid;
    }

    public String getEname() {
        return ename;
    }

    public void setEname(String ename) {
        this.ename = ename;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public String getDeg() {
        return deg;
    }

    public void setDeg(String deg) {
        this.deg = deg;
    }

    @Override
    public String toString() {
        return &quot;Employee{&quot; +
                &quot;eid=&quot; + eid +
                &quot;, ename=&apos;&quot; + ename + &apos;\&apos;&apos; +
                &quot;, salary=&quot; + salary +
                &quot;, deg=&apos;&quot; + deg + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);

    private static void createAnEmployee(Employee employee) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        manager.persist(employee);
        transaction.commit();
        manager.close();
    }

    private static Employee findEmployee(int eid) {
        EntityManager manager = factory.createEntityManager();
        try {
            return manager.find(Employee.class, eid);
        } finally {
            manager.close();
        }
    }

    private static void deleteEmployee(int eid) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        Employee employee = manager.find(Employee.class, eid);
        manager.remove(employee);
        transaction.commit();
        manager.close();
    }

    private static void updateEmployeeSalary(int eid, double salary) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        Employee employee = manager.find(Employee.class, eid);
        System.out.println(employee);
        employee.setSalary(salary);
        transaction.commit();
        manager.close();
    }


    public static void main(String[] args) {
        Employee employee = new Employee();

        employee.setEid(100);
        employee.setEname(&quot;zsr&quot;);
        employee.setSalary(3000);
        employee.setDeg(&quot;Student&quot;);

        createAnEmployee(employee);
        System.out.println(findEmployee(100));
        updateEmployeeSalary(100, 5000);
        System.out.println(findEmployee(100));
        deleteEmployee(100);
        factory.close();
    }
}
</code></pre><p>结果如下：</p>
<pre><code>Employee{eid=100, ename=&apos;zsr&apos;, salary=3000.0, deg=&apos;Student&apos;}
Employee{eid=100, ename=&apos;zsr&apos;, salary=3000.0, deg=&apos;Student&apos;}
Employee{eid=100, ename=&apos;zsr&apos;, salary=5000.0, deg=&apos;Student&apos;}
</code></pre><p>需要注意的是：如果要手动指定主键，就不要用<strong>@GeneratedValue</strong>去注释主键，否则会出现detached entity passed to persist异常。</p>
<p>以上主要用到的类有下面几个：</p>
<ul>
<li><strong>EntityManagerFactory</strong>  EntityManager的工厂类，与EntityManager是一对多的关系。</li>
<li><strong>EntityManager</strong> 用来执行对象持久化的类，是<strong>Query</strong>类的工厂类。</li>
<li><strong>EntityTransaction</strong> 与EntityManager是一对一的关系，作用在EntityManager上更新表的操作存储在其中，最后用其commit()方法才正式生效。</li>
<li><strong>Persistence</strong> 提供静态方法用来生成EntityManagerFactory对象。</li>
</ul>
<p>关系如下图所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%889.35.54.png" alt=""></p>
<h3 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h3><p>JPQL是在SQL语句基础之上建立起来的标准语句，能够执行对表中对象的<strong>SELECT, UPDATE, DELETE</strong>。</p>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>main方法改成如下代码：</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
public static void main(String[] args) {
    Employee employee1 = new Employee(100, &quot;Gopal&quot;, 40000, &quot;Technical Manager&quot;);
    Employee employee2 = new Employee(101, &quot;Manisha&quot;, 35000, &quot;Reader&quot;);
    Employee employee3 = new Employee(102, &quot;Masthanvali&quot;, 37000, &quot;Teacher&quot;);
    Employee employee4 = new Employee(103, &quot;Satish&quot;, 30000, &quot;Student&quot;);
    Employee employee5 = new Employee(104, &quot;Krishna&quot;, 31000, &quot;Tutor&quot;);
    Employee employee6 = new Employee(105, &quot;Kiran&quot;, 32000, &quot;Drinker&quot;);

    createAnEmployee(employee1);
    createAnEmployee(employee2);
    createAnEmployee(employee3);
    createAnEmployee(employee4);
    createAnEmployee(employee5);
    createAnEmployee(employee6);

    EntityManager manager = factory.createEntityManager();

    Query betweenQuery = manager.createQuery(&quot;select e from Employee e where e.salary between 30000 and 35000&quot;);
    List&lt;Employee&gt; salaryQueryEmployees = (List&lt;Employee&gt;) betweenQuery.getResultList();

    for (Employee employee : salaryQueryEmployees) {
        System.out.println(employee);
    }

    System.out.println();

    Query likeQuery = manager.createQuery(&quot;select  e from Employee e where e.ename like &apos;M%&apos;&quot;);
    List&lt;Employee&gt; likeQueryResults = (List&lt;Employee&gt;) likeQuery.getResultList();

    for (Employee employee : likeQueryResults) {
        System.out.println(employee);
    }

    manager.close();
    factory.close();
}
</code></pre><p>运行结果：</p>
<pre><code>Employee{eid=101, ename=&apos;Manisha&apos;, salary=35000.0, deg=&apos;Reader&apos;}
Employee{eid=103, ename=&apos;Satish&apos;, salary=30000.0, deg=&apos;Student&apos;}
Employee{eid=104, ename=&apos;Krishna&apos;, salary=31000.0, deg=&apos;Tutor&apos;}
Employee{eid=105, ename=&apos;Kiran&apos;, salary=32000.0, deg=&apos;Drinker&apos;}

Employee{eid=101, ename=&apos;Manisha&apos;, salary=35000.0, deg=&apos;Reader&apos;}
Employee{eid=102, ename=&apos;Masthanvali&apos;, salary=37000.0, deg=&apos;Teacher&apos;}
</code></pre><p>sql语法实在是繁多，这里不再一一详细列举。</p>
<h4 id="NamedQuery"><a href="#NamedQuery" class="headerlink" title="NamedQuery"></a>NamedQuery</h4><p><strong>@NamedQuery</strong>注解用实现定义好的且不可变的query语句来执行查询操作，这个query语句中含有未知的参数可以在别处指定，用法如下：</p>
<p>Employee.java:</p>
<pre><code>@Entity
@Table(name = &quot;Employee&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
@NamedQuery(query = &quot;select e from Employee e where e.eid = :id&quot;, name = &quot;find employee by id&quot;)
public class Employee {
    ...
}
</code></pre><p>main函数：</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
public static void main(String[] args) {
    ...

    EntityManager manager = factory.createEntityManager();

    Query query = manager.createNamedQuery(&quot;find employee by id&quot;);
    query.setParameter(&quot;id&quot;, 103);

    Employee employee = (Employee) query.getSingleResult();
    System.out.println(employee);

    manager.close();
    factory.close();
}
</code></pre><h3 id="JPA对继承的处理"><a href="#JPA对继承的处理" class="headerlink" title="JPA对继承的处理"></a>JPA对继承的处理</h3><p>Java对象之间存在错综复杂的继承关系，而关系数据库没有继承这种概念，JPA对这种情况提供了多种解决方案。</p>
<p>考虑如下的继承关系：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8810.25.29.png" alt=""></p>
<h4 id="单一表策略"><a href="#单一表策略" class="headerlink" title="单一表策略"></a>单一表策略</h4><p>单一表策略是指将不同的对象（存在继承关系）放在一个表当中，代码如下：</p>
<p>Staff.java:</p>
<pre><code>@Entity
@Table(name = &quot;Staff&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = &quot;type&quot;)
public class Staff {
    @Id
    private int sid;
    private String sname;

    public Staff(int sid, String sname) {
        this.sid = sid;
        this.sname = sname;
    }

    public Staff() {

    }

    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }
}
</code></pre><p>TeachingStaff.java:</p>
<pre><code>@Entity
@DiscriminatorValue(value = &quot;TS&quot;)
public class TeachingStaff extends Staff {
    private String qualification;
    private String subjectexpertise;

    public TeachingStaff(int sid, String sname, String qualification, String subjectexpertise) {
        super(sid, sname);
        this.qualification = qualification;
        this.subjectexpertise = subjectexpertise;
    }

    public TeachingStaff() {
        super();
    }

    public String getQualification() {
        return qualification;
    }

    public void setQualification(String qualification) {
        this.qualification = qualification;
    }

    public String getSubjectexpertise() {
        return subjectexpertise;
    }

    public void setSubjectexpertise(String subjectexpertise) {
        this.subjectexpertise = subjectexpertise;
    }
}
</code></pre><p>NonTeachingStaff.java:</p>
<pre><code>@Entity
@DiscriminatorValue(value = &quot;NST&quot;)
public class NonTeachingStaff extends Staff {
    private String areaexpertise;

    public NonTeachingStaff(int sid, String sname, String areaexpertise) {
        super(sid, sname);
        this.areaexpertise = areaexpertise;
    }

    public NonTeachingStaff() {
        super();
    }

    public String getAreaexpertise() {
        return areaexpertise;
    }

    public void setAreaexpertise(String areaexpertise) {
        this.areaexpertise = areaexpertise;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    @SuppressWarnings(&quot;unchecked&quot;)
    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        TeachingStaff ts1 = new TeachingStaff(100, &quot;zsr&quot;, &quot;fine&quot;, &quot;a&quot;);
        TeachingStaff ts2 = new TeachingStaff(101, &quot;zx&quot;, &quot;good&quot;, &quot;a&quot;);

        NonTeachingStaff nts1 = new NonTeachingStaff(102, &quot;zy&quot;, &quot;a&quot;);
        NonTeachingStaff nts2 = new NonTeachingStaff(103, &quot;zu&quot;, &quot;b&quot;);

        manager.persist(ts1);
        manager.persist(ts2);
        manager.persist(nts1);
        manager.persist(nts2);

        transaction.commit();

        manager.close();
        factory.close();
    }
}
</code></pre><p>运行结束后打开h2 console，执行:</p>
<pre><code>SELECT * FROM STAFF;
</code></pre><p>运行结果：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8810.51.27.png" alt=""></p>
<h4 id="合并表策略"><a href="#合并表策略" class="headerlink" title="合并表策略"></a>合并表策略</h4><p>合并表策略（不知道怎么翻译才是对的，原文是Joined Table Strategy）是指将几个对象模型中共有的东西抽出来，在此基础上为子类分别建表，代码如下：</p>
<p>Staff.java:</p>
<pre><code>@Entity
@Table(name = &quot;Staff&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
@Inheritance(strategy = InheritanceType.JOINED)
public class Staff {
    ...
}
</code></pre><p>TeachingStaff.java:</p>
<pre><code>@Entity
@PrimaryKeyJoinColumn(referencedColumnName = &quot;sid&quot;)
public class TeachingStaff extends Staff {
    ...
}
</code></pre><p>NonTeachingStaff的变化与TeachingStaff的相同，不再展示。</p>
<p>main方法不变，执行完毕之后，打开h2 console，运行如下指令：</p>
<pre><code>SELECT * FROM STAFF;
SELECT * FROM TEACHINGSTAFF;
SELECT * FROM NONTEACHINGSTAFF;
</code></pre><p>结果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8811.12.43.png" alt=""></p>
<h4 id="一类一表策略"><a href="#一类一表策略" class="headerlink" title="一类一表策略"></a>一类一表策略</h4><p>顾名思义就是为每一个类都产生一个表，此方法不再做展示。</p>
<h3 id="实体间关系"><a href="#实体间关系" class="headerlink" title="实体间关系"></a>实体间关系</h3><p>除了继承，实体之间也有很多复杂的组合关系，JPA为实体之间的关系提供了四种注解：<strong>@OneToOne @OneToMany @ManyToOne @ManyToMany</strong></p>
<h4 id="ManyToOne"><a href="#ManyToOne" class="headerlink" title="ManyToOne"></a>ManyToOne</h4><p>考虑下面的模型：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8811.28.37.png" alt=""><br>此时多个Employee可以对应一个Department，在关系数据库里面，Employee的did便是一个外键，且指向Department的id。</p>
<p>代码如下：</p>
<p>Employee.java:</p>
<pre><code>@Entity
@Table(name = &quot;Employee&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Employee {
    @Id
    private int eid;
    private String ename;
    private double salary;
    private String deg;
    @ManyToOne
    private Department department;

    ...

}
</code></pre><p>Department.java:</p>
<pre><code>@Entity
public class Department {
    @Id
    private int did;
    private String dname;

    public Department(int did, String dname) {
        this.did = did;
        this.dname = dname;
    }

    public Department() {
    }

    public int getDid() {
        return did;
    }

    public void setDid(int did) {
        this.did = did;
    }

    public String getDname() {
        return dname;
    }

    public void setDname(String dname) {
        this.dname = dname;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    @SuppressWarnings(&quot;unchecked&quot;)
    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        Department department = new Department(10, &quot;DingXiang&quot;);
        manager.persist(department);

        Employee employee1 = new Employee(100, &quot;zsr&quot;, 4000, &quot;Student&quot;);
        employee1.setDepartment(department);

        Employee employee2 = new Employee(101, &quot;yui&quot;, 4000, &quot;Student&quot;);
        employee2.setDepartment(department);

        Employee employee3 = new Employee(102, &quot;yuo&quot;, 4000, &quot;Student&quot;);
        employee3.setDepartment(department);

        manager.persist(employee1);
        manager.persist(employee2);
        manager.persist(employee3);

        transaction.commit();

        manager.close();
        factory.close();
    }
} 
</code></pre><p>执行结束后，打开h2 console，查看Employee和Department表，结果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-15%20%E4%B8%8B%E5%8D%8811.47.43.png" alt=""></p>
<h4 id="OneToMany"><a href="#OneToMany" class="headerlink" title="OneToMany"></a>OneToMany</h4><p>上面的反过来说，一个Department可以对应多个Employee，代码修改如下：</p>
<p>Department.java:</p>
<pre><code>@Entity
public class Department {
    @Id
    private int did;
    private String dname;
    @OneToMany(targetEntity = Employee.class)
    private List&lt;Employee&gt; employeeList;

    public Department(int did, String dname) {
        this.did = did;
        this.dname = dname;
    }

    public Department() {
    }

    public List&lt;Employee&gt; getEmployeeList() {
        return employeeList;
    }

    public void setEmployeeList(List&lt;Employee&gt; employeeList) {
        this.employeeList = employeeList;
    }

    public int getDid() {
        return did;
    }

    public void setDid(int did) {
        this.did = did;
    }

    public String getDname() {
        return dname;
    }

    public void setDname(String dname) {
        this.dname = dname;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        Department department = new Department(10, &quot;DingXiang&quot;);

        Employee employee1 = new Employee(100, &quot;zsr&quot;, 4000, &quot;Student&quot;);
        Employee employee2 = new Employee(101, &quot;yui&quot;, 4000, &quot;Student&quot;);
        Employee employee3 = new Employee(102, &quot;yuo&quot;, 4000, &quot;Student&quot;);

        manager.persist(employee1);
        manager.persist(employee2);
        manager.persist(employee3);

        List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();
        employees.add(employee1);
        employees.add(employee2);
        employees.add(employee3);

        department.setEmployeeList(employees);

        manager.persist(department);

        transaction.commit();

        manager.close();
        factory.close();
    }
}
</code></pre><p>执行完毕之后，打开h2 console，查看表信息，如下所示：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-16%20%E4%B8%8A%E5%8D%8812.00.54.png" alt=""></p>
<h4 id="OneToOne"><a href="#OneToOne" class="headerlink" title="OneToOne"></a>OneToOne</h4><p>假设上述Employee类和Department类是一一对应的关系，只需要把ManyToOne小节下Employee类中对department成员上的注解修改成<strong>@OneToOne</strong>，再在main方法中为每个Employee提供一个Department即可，执行完毕后，生成的表的格式和ManyToOne的格式相同，这里不再展示。</p>
<h4 id="ManyToMany"><a href="#ManyToMany" class="headerlink" title="ManyToMany"></a>ManyToMany</h4><p>考虑下面的模型：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-16%20%E4%B8%8A%E5%8D%8812.13.46.png" alt=""><br>一个课程可以有多个老师同时教学，一个老师也可以教多个课程，代码如下：</p>
<p>Clazz.java:</p>
<pre><code>@Entity
@Table(name = &quot;Clazz&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Clazz {
    @Id
    private int cid;
    private String cname;

    @ManyToMany(targetEntity = Teacher.class)
    private Set&lt;Teacher&gt; teachers;

    public Clazz() {
    }

    public Clazz(int cid, String cname) {
        this.cid = cid;
        this.cname = cname;
    }

    public Set&lt;Teacher&gt; getTeachers() {
        return teachers;
    }

    public void setTeachers(Set&lt;Teacher&gt; teachers) {
        this.teachers = teachers;
    }

    public int getCid() {
        return cid;
    }

    public void setCid(int cid) {
        this.cid = cid;
    }

    public String getCname() {
        return cname;
    }

    public void setCname(String cname) {
        this.cname = cname;
    }
}
</code></pre><p>Teacher.java:</p>
<pre><code>@Entity
@Table(name = &quot;Teacher&quot;, schema = &quot;PUBLIC&quot;, catalog = &quot;TEST&quot;)
public class Teacher {
    @Id
    private int tid;
    private String tname;

    @ManyToMany(targetEntity = Clazz.class)
    Set&lt;Clazz&gt; clazzes;

    public Teacher(int tid, String tname) {
        this.tid = tid;
        this.tname = tname;
    }

    public Teacher() {
    }

    public int getTid() {
        return tid;
    }

    public void setTid(int tid) {
        this.tid = tid;
    }

    public String getTname() {
        return tname;
    }

    public void setTname(String tname) {
        this.tname = tname;
    }

    public Set&lt;Clazz&gt; getClazzes() {
        return clazzes;
    }

    public void setClazzes(Set&lt;Clazz&gt; clazzes) {
        this.clazzes = clazzes;
    }
}
</code></pre><p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);


    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();

        Clazz clazz = new Clazz(10, &quot;Chinese&quot;);
        Clazz clazz1 = new Clazz(11, &quot;Math&quot;);
        Clazz clazz2 = new Clazz(12, &quot;English&quot;);

        manager.persist(clazz);
        manager.persist(clazz1);
        manager.persist(clazz2);

        Set&lt;Clazz&gt; clazzes = new HashSet&lt;&gt;();
        clazzes.add(clazz);
        clazzes.add(clazz1);
        clazzes.add(clazz2);

        Set&lt;Clazz&gt; clazzes1 = new HashSet&lt;&gt;(clazzes);
        Set&lt;Clazz&gt; clazzes2 = new HashSet&lt;&gt;(clazzes);

        Teacher teacher1 = new Teacher(1, &quot;zsr&quot;);
        Teacher teacher2 = new Teacher(2, &quot;zx&quot;);
        Teacher teacher3 = new Teacher(3, &quot;zo&quot;);

        teacher1.setClazzes(clazzes);
        teacher2.setClazzes(clazzes1);
        teacher3.setClazzes(clazzes2);

        manager.persist(teacher1);
        manager.persist(teacher2);
        manager.persist(teacher3);

        transaction.commit();

        manager.close();
        factory.close();
    }
}
</code></pre><p>执行完毕之后打开h2 console查看表，结果如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-16%20%E4%B8%8A%E5%8D%8812.33.02.png" alt=""></p>
<h3 id="Criteria-Api"><a href="#Criteria-Api" class="headerlink" title="Criteria Api"></a>Criteria Api</h3><p>Criteria Api是用来执行标准查询的api，其用法遵循以下流程：</p>
<pre><code>EntityManager em = ...;
CriteriaBuilder cb = em.getCriteriaBuilder(); CriteriaQuery&lt;Entity class&gt; cq = cb.createQuery(Entity.class); 
Root&lt;Entity&gt; from = cq.from(Entity.class);
cq.select(Entity);
TypedQuery&lt;Entity&gt; q = em.createQuery(cq);
List&lt;Entity&gt; allitems = q.getResultList();
</code></pre><p>还是拿JPQL小节的数据当例子，代码如下：</p>
<p>Main.java:</p>
<pre><code>public class Main {
    private static final EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;HibernatePersistenceUnit&quot;);

    private static void createAnEmployee(EntityManager manager, Employee employee) {
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        manager.persist(employee);
        transaction.commit();
    }


    public static void main(String[] args) {
        EntityManager manager = factory.createEntityManager();


        Employee employee1 = new Employee(100, &quot;Gopal&quot;, 40000, &quot;Technical Manager&quot;);
        Employee employee2 = new Employee(101, &quot;Manisha&quot;, 35000, &quot;Reader&quot;);
        Employee employee3 = new Employee(102, &quot;Masthanvali&quot;, 37000, &quot;Teacher&quot;);
        Employee employee4 = new Employee(103, &quot;Satish&quot;, 30000, &quot;Student&quot;);
        Employee employee5 = new Employee(104, &quot;Krishna&quot;, 31000, &quot;Tutor&quot;);
        Employee employee6 = new Employee(105, &quot;Kiran&quot;, 32000, &quot;Drinker&quot;);

        createAnEmployee(manager, employee1);
        createAnEmployee(manager, employee2);
        createAnEmployee(manager, employee3);
        createAnEmployee(manager, employee4);
        createAnEmployee(manager, employee5);
        createAnEmployee(manager, employee6);

        CriteriaBuilder criteriaBuilder = manager.getCriteriaBuilder();
        CriteriaQuery&lt;Employee&gt; employeeCriteriaQuery = criteriaBuilder.createQuery(Employee.class);
        Root&lt;Employee&gt; from = employeeCriteriaQuery.from(Employee.class);

        CriteriaQuery&lt;Employee&gt; betweenSelect = employeeCriteriaQuery.select(from)
                .where(criteriaBuilder.between(from.get(&quot;salary&quot;), 30000, 35000));
        TypedQuery&lt;Employee&gt; betweenSelectTypedQuery = manager.createQuery(betweenSelect);
        List&lt;Employee&gt; betweenSelectResults = betweenSelectTypedQuery.getResultList();

        for (Employee employee : betweenSelectResults) {
            System.out.println(employee);
        }

        manager.close();
        factory.close();
    }
}
</code></pre><p>输出和JPQL小节的输出效果相同，可以看出Criteria更加面向对象。</p>
<h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>上面再配置JPA项目的时候我们用Hibernate作为Provider。Hibernate是一个优秀的开源Java ORM框架，既可以适配JPA也可以拿出来单独使用，有了上面的基础其使用也就变的简单自然。Hibernate还提供了缓存和检索服务，拥有拦截功能，其具体使用请查看官方文档，教程推荐: <a href="http://wiki.jikexueyuan.com/project/hibernate/" target="_blank" rel="external">Hibernate教程</a></p>
<p>另外，IntelliJ IDEA也可以直接建立Hibernate项目省去了配置的麻烦…</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/08/用PopupWindow实现键盘之上的悬浮窗/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/08/用PopupWindow实现键盘之上的悬浮窗/" itemprop="url">
                  用PopupWindow实现键盘之上的悬浮窗
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-08T20:22:23+08:00">
                2017-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/08/用PopupWindow实现键盘之上的悬浮窗/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/08/用PopupWindow实现键盘之上的悬浮窗/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近遇到一个写评论的需求，就是点击一个写评论的按钮跳出软键盘，软键盘之上有一个输入框和发送按钮，想了好半天决定采用悬浮窗，其主要想法来自：<a href="http://www.itdadao.com/articles/c15a380342p0.html" target="_blank" rel="external">模仿微信，QQ评论输入框</a>，其效果图如下：<br><img src="http://ok34fi9ya.bkt.clouddn.com/Screenshot_1491657613.png" alt=""></p>
<h1 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h1><h2 id="activity-main"><a href="#activity-main" class="headerlink" title="activity_main:"></a>activity_main:</h2><pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.stephen.popupwindowedittext.MainActivity&quot;
    android:id=&quot;@+id/root&quot;&gt;

    &lt;LinearLayout
        android:id=&quot;@+id/comment_part&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:orientation=&quot;horizontal&quot;
        android:padding=&quot;12dp&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/comment&quot;
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_weight=&quot;1&quot;
            android:textStyle=&quot;bold&quot;
            android:text=&quot;评论&quot;
            android:textSize=&quot;14sp&quot;/&gt;
        &lt;Button
            android:id=&quot;@+id/write_comment_button&quot;
            android:background=&quot;@drawable/bg_write_comment_button&quot;
            android:layout_width=&quot;48dp&quot;
            android:layout_height=&quot;24dp&quot;
            android:text=&quot;写评论&quot;
            android:textSize=&quot;10sp&quot;
            android:textColor=&quot;@android:color/white&quot;/&gt;
    &lt;/LinearLayout&gt;

    &lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/comments_list&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@id/comment_part&quot;/&gt;
&lt;/RelativeLayout&gt;
</code></pre><h2 id="window-edittext"><a href="#window-edittext" class="headerlink" title="window_edittext"></a>window_edittext</h2><pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;horizontal&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:paddingLeft=&quot;12dp&quot;
    android:paddingRight=&quot;12dp&quot;&gt;

    &lt;EditText
        android:id=&quot;@+id/main_edit_text&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_weight=&quot;1&quot;/&gt;
    &lt;Button
        android:background=&quot;@drawable/bg_send_button&quot;
        android:id=&quot;@+id/send_button&quot;
        android:layout_width=&quot;52dp&quot;
        android:layout_height=&quot;24dp&quot;
        android:layout_marginLeft=&quot;8dp&quot;
        android:text=&quot;发送&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;12sp&quot;/&gt;
&lt;/LinearLayout&gt;
</code></pre><h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity:"></a>MainActivity:</h2><pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    private List&lt;String&gt; data = new ArrayList&lt;&gt;();
    private RecyclerView rv;
    private InputMethodManager imm;

    private View commentPatternView;
    private PopupWindow commentPatternWindow;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);

        initView();
    }

    private void initView() {
        findViewById(R.id.write_comment_button).setOnClickListener(this);
        rv = (RecyclerView) findViewById(R.id.comments_list);
        rv.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));
        rv.setAdapter(new CommentsListAdapter(data));
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.write_comment_button: {
                showCommentPattern();
                break;
            }
            case R.id.send_button: {
                sendComment();
                if (commentPatternWindow != null) {
                    commentPatternWindow.dismiss();
                }
                break;
            }
        }
    }

    private void sendComment() {
        String content = ((EditText) commentPatternView.findViewById(R.id.main_edit_text)).getText().toString();
        data.add(content);
        rv.getAdapter().notifyItemInserted(data.size() - 1);
    }

    private void showCommentPattern() {
        View parent = findViewById(R.id.root);

        if (commentPatternView == null) {
            commentPatternView = getLayoutInflater().inflate(R.layout.window_edit_text, null);
            commentPatternView.findViewById(R.id.send_button).setOnClickListener(this);
        }

        if (commentPatternWindow == null) {
            commentPatternWindow = new PopupWindow(commentPatternView, WindowManager.LayoutParams.MATCH_PARENT,
                    WindowManager.LayoutParams.WRAP_CONTENT, true);
            commentPatternWindow.setBackgroundDrawable(new ColorDrawable(Color.WHITE));
            commentPatternWindow.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
        }

        commentPatternWindow.showAtLocation(parent, Gravity.BOTTOM, 0, 0);
        commentPatternWindow.setOnDismissListener(new PopupWindow.OnDismissListener() {
            @Override
            public void onDismiss() {
                imm.toggleSoftInput(InputMethodManager.HIDE_IMPLICIT_ONLY, 0);
            }
        });

        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                imm.showSoftInput(commentPatternView.findViewById(R.id.main_edit_text), InputMethodManager.SHOW_FORCED);
            }
        }, 100);
    }
}
</code></pre><p>上面两个布局文件没什么好说的，主要是第三个文件，首先要注意的是要调用<strong>PopupWindow</strong>的<strong>setBackgroundDrawable</strong>方法，否则会有各种意想不到的bug；其次要调用<strong>setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE)</strong>，这是为了让<strong>PopupWindow</strong>出现在软键盘之上。</p>
<p>软键盘的调用方式也是值得注意的地方，在<strong>showAtLocation</strong>方法调用完成之后不能立即使软键盘弹出，得有一个延时的过程，软键盘消失的事件与window消失的事件绑定在一起即可。</p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>上述方法有一个缺陷，就是不能禁止掉<strong>outsideTouchable</strong>，因为要接受软键盘的输入，所以<strong>focusable</strong>必须为<strong>true</strong>，而<strong>setOutsideTouchable(false)</strong>方法必须在<strong>focusable</strong>为<strong>false</strong>，<strong>touchable</strong>为<strong>true</strong>时才生效，所以上述方法不能保证点击其余空白区域悬浮窗不消失。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/14/使用Fork-Join架构进行归并排序/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/使用Fork-Join架构进行归并排序/" itemprop="url">
                  使用Fork/Join架构进行归并排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-14T23:37:51+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/使用Fork-Join架构进行归并排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/使用Fork-Join架构进行归并排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>以下部分文字，图片摘自《Java并发编程的艺术》</p>
<h1 id="Fork-Join框架简介"><a href="#Fork-Join框架简介" class="headerlink" title="Fork/Join框架简介"></a>Fork/Join框架简介</h1><p>Fork/Join框架是jdk7中提供的并行框架，其主要的特点是把一个大任务分割成几块不同的小任务，由不同的线程去执行这一系列的小任务，最终结果合并成大任务的结果。</p>
<p>其主要原理如图所示：<br><img src="http://cdn.infoqstatic.com/statics_s1_20170314-0434/resource/articles/fork-join-introduction/zh/resources/21.png" alt=""></p>
<h1 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h1><p>工作窃取算法的意思是每个线程的任务队列执行完毕之后，此线程会将其他线程的任务队列中的任务“窃取”到本线程的任务队列中来。使用窃取算法的好处就是充分利用了线程的并行计算，有关工作窃取算法的更多内容，请看：<a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="external">Work Stealing</a></p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>再实际应用上，要首先确定一个大的任务是否能够分成几个小的任务，是否能把小任务的结果进行合并，这样就自然而然的想到递归。下面笔者实现一个用Fork/Join架构实现的归并排序算法：</p>
<pre><code>public class ForkJoinPractice {
    static class SortTask&lt;T extends Comparable&lt;T&gt;&gt; extends RecursiveAction {
        T[] array;
        int start;
        int end;
        int mid;

        public SortTask(T[] array, int start, int end) {
            this.array = array;
            this.start = start;
            this.end = end;
            this.mid = (this.start + this.end) / 2;
        }

        @Override
        protected void compute() {
            int mid;
            if (start &lt; end) {
                mid = (start + end) / 2;
                //将任务分解
                invokeAll(new SortTask&lt;T&gt;(array, start, mid), new SortTask&lt;T&gt;(array, mid + 1, end));
                merge();
            }
        }

        private void merge() {
            int n1 = mid - start + 1;
            int n2 = end - mid;
            int i, j, k;

            List&lt;T&gt; leftList = new ArrayList&lt;&gt;(n1);
            List&lt;T&gt; rightList = new ArrayList&lt;&gt;(n2);

            for (i = 0; i &lt; n1; i++) {
                leftList.add(array[start + i]);
            }

            for (j = 0; j &lt; n2; j++) {
                rightList.add(array[mid + 1 + j]);
            }

            i = j = 0;
            k = start;

            while (i &lt; n1 &amp;&amp; j &lt; n2) {
                if (leftList.get(i).compareTo(rightList.get(j)) &lt; 0) {
                    array[k++] = leftList.get(i++);
                } else {
                    array[k++] = rightList.get(j++);
                }
            }

            while (i &lt; n1) {
                array[k++] = leftList.get(i++);
            }

            while (j &lt; n2) {
                array[k++] = rightList.get(j++);
            }
        }
    }

    public static void main(String[] args) {
        Integer[] array = new Integer[90];
        for (int i = 0; i &lt; 90; i++) {
            array[i] = 90 - i;
        }

        SortTask&lt;Integer&gt; sortTask = new SortTask&lt;&gt;(array, 0, array.length - 1);
        ForkJoinPool pool = new ForkJoinPool();
        pool.submit(sortTask);
        try {
            //等待任务结束
            pool.awaitTermination(3, TimeUnit.SECONDS);
            pool.shutdown();
            for (int i :  array) {
                System.out.println(i);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/14/Java并发编程-二/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/Java并发编程-二/" itemprop="url">
                  Java并发编程(二)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-14T20:20:52+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/Java并发编程-二/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/Java并发编程-二/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>以下内容均摘自《Java并发编程的艺术》</p>
<h1 id="等待／超时模式"><a href="#等待／超时模式" class="headerlink" title="等待／超时模式"></a>等待／超时模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>等待／超时模式的典型应用场景是，等待一段时间，看是否能得到正确的结果，如果能，则将其返回，不能则返回默认值，其代码如下：</p>
<pre><code>public synchronized Object getObject(long millionSeconds) throws InterruptedException {
    long future = System.currentTimeMillis() + millionSeconds;
    long remainingTime = millionSeconds;
    while (obj == null &amp;&amp; remainingTime &gt; 0) {
        wait(remainingTime);
        remainingTime = future - System.currentTimeMillis();
    }

    return obj;
}
</code></pre><h2 id="应用：数据库连接池"><a href="#应用：数据库连接池" class="headerlink" title="应用：数据库连接池"></a>应用：数据库连接池</h2><p>下面来模拟一个数据库连接池，用来从中获取和释放连接，客户端获取连接被设置为超时等待，程序如下：</p>
<pre><code>public class ConnectionPool {
    private final LinkedList&lt;Connection&gt; connections = new LinkedList&lt;&gt;();

    public ConnectionPool(int initSize) {
        if (initSize &lt;= 0)
            throw new IllegalArgumentException(&quot;Init size must &gt; 0&quot;);
        for (int i = 0; i &lt; initSize; i++) {
            connections.addLast(ConnectionDriver.getConnection());
        }
    }

    public void releaseConnection(Connection connection) {
        synchronized (connections) {
            connections.addLast(connection);
            connections.notifyAll();
        }
    }

    public Connection getConnection(long millionSeconds) throws InterruptedException {
        synchronized (connections) {
            if (millionSeconds &lt;= 0) {
                while (connections.isEmpty()) {
                    connections.wait();
                }
                return connections.removeFirst();
            } else {
                long future = System.currentTimeMillis() + millionSeconds;
                long remaining = millionSeconds;

                while (connections.isEmpty() &amp;&amp; remaining &gt; 0) {
                    connections.wait(remaining);
                    remaining = future - System.currentTimeMillis();
                }

                Connection connection = null;
                if (!connections.isEmpty()) {
                    connection = connections.removeFirst();
                }

                return connection;
            }
        }
    }
}
</code></pre><p>ConnectionDriver通过动态代理技术返回一个Connection:</p>
<pre><code>public class ConnectionDriver {

    public static class ConnectionHandler implements InvocationHandler {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            if (method.getName().equals(&quot;commit&quot;)) {
                Thread.sleep(1000);
            }

            return null;
        }
    }

    public static Connection getConnection() {
        return (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(),
                new Class[] {Connection.class},
                new ConnectionHandler());
    }
}
</code></pre><p>上面的连接池通过构造函数传入的initSize来定义里面的连接数量，通过<strong>release</strong>方法来释放用过的连接，此时连接被重新加入到队列内部，然后通知在<strong>connections</strong>上等待的线程此时有连接可以进行复用。<strong>getConnection</strong>通过制定的参数设置超时时间，并判断队列是否为空，不为空则直接从队列里面取出第一个并返回，不是的话则在<strong>connections</strong>上进行等待，知道超时或者又有复用的connection为止。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/Java并发编程-一/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/Java并发编程-一/" itemprop="url">
                  Java并发编程(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-13T18:46:34+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/13/Java并发编程-一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/13/Java并发编程-一/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>一下部分文字图片来自《Java并发编程的艺术》</p>
<h1 id="多线程简介"><a href="#多线程简介" class="headerlink" title="多线程简介"></a>多线程简介</h1><p>线程是现代操作系统调度的最小单元，一个进程可以包含很多线程。在Java的内存区域里面，每一个线程都有自己的程序计数器和虚拟机栈。处理器通过时间切片的方法在各个线程之间来回切换，可以用下面的代码查看JVM运行时各个线程的信息：</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) {
        ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();
        ThreadInfo[] threadInfoArray = mxBean.dumpAllThreads(false, false);

        for (ThreadInfo info : threadInfoArray) {
            System.out.println(&quot;Thread id: &quot; + info.getThreadId() + &quot; Thread name: &quot; +
                    info.getThreadName() + &quot; Thread state: &quot; + info.getThreadState());
        }
    }
}
</code></pre><p>运行结果如下：</p>
<pre><code>Thread id: 9 Thread name: Monitor Ctrl-Break Thread state: RUNNABLE
Thread id: 4 Thread name: Signal Dispatcher Thread state: RUNNABLE
Thread id: 3 Thread name: Finalizer Thread state: WAITING
Thread id: 2 Thread name: Reference Handler Thread state: WAITING
Thread id: 1 Thread name: main Thread state: RUNNABLE
</code></pre><p>也就是说，运行main函数时，不只是main线程在运行，Java天生就是多线程的。</p>
<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>在Java程序里面，线程的优先级通过<strong>setPriority(int priority)</strong>来设置，<strong>priority</strong>的取值范围为1-10，默认为5，线程的优先级越高，处理器对此线程所切的时间片越长，但是不同的操作系统的表现不同，有些会忽略掉线程的优先级，因此，设置优先级不会保证多线程程序的正确性，在实际编程过程中不应该使用。</p>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>线程的状态分为以下几种：</p>
<ul>
<li><strong>NEW</strong> 被创建成功，还没有调用<strong>start()</strong>方法。</li>
<li><strong>RUNNABLE</strong> 正在运行中。</li>
<li><strong>BLOCKED</strong> 正在处于阻塞状态。</li>
<li><strong>WAITING</strong> 等待状态，此线程在等待其他线程做出特定的动作。</li>
<li><strong>TIME_WAITING</strong> 超时等待状态。</li>
<li><strong>TERMINATED</strong> 终止，线程结束。</li>
</ul>
<p>拿上面的运行结果的线程名为<strong>Finalizer</strong>的线程来说，运行时处于<strong>WAITING</strong>状态，它在等待有对象进入它内部持有的<strong>ReferenceQueue</strong>，并执行清理动作，有关Finalizer的更多信息，查看：<a href="http://blog.csdn.net/rsljdkt/article/details/12242007" target="_blank" rel="external">GC执行finalize的过程</a></p>
<p>为了说明各大状态，我先用开几个线程，然后用<a href="http://blog.csdn.net/fenglibing/article/details/6411940" target="_blank" rel="external">jstack</a>指令查看各线程的状态。</p>
<p>代码如下：</p>
<pre><code>class SleepUtils {
    public static void sleep(int millionSeconds) {
        try {
            Thread.sleep(millionSeconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class ThreadStateTest {

    static class TimeWaitingThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                SleepUtils.sleep(100);
            }
        }
    }

    static class PauseThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                long current = System.currentTimeMillis();
                while (System.currentTimeMillis() - current &lt;= 3000);
            }
        }
    }

    static class Waiting implements Runnable {
        @Override
        public void run() {
            while (true) {
                synchronized (Waiting.class) {
                    try {
                        Waiting.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    static class Block implements Runnable {
        @Override
        public void run() {
            synchronized (Block.class) {
                while (true) {
                    SleepUtils.sleep(4000);
                }
            }
        }
    }

    public static void main(String[] args) {
        new Thread(new TimeWaitingThread(), &quot;TimedWaitingThread&quot;).start();
        new Thread(new PauseThread(), &quot;PauseThread&quot;).start();
        new Thread(new Waiting(), &quot;WaitingThread&quot;).start();
        new Thread(new Block(), &quot;Block1&quot;).start();
        new Thread(new Block(), &quot;Block2&quot;).start();
    }
}
</code></pre><p>运行之后，先在终端运行<a href="http://blog.csdn.net/fenglibing/article/details/6411932" target="_blank" rel="external">jps</a>命令，结果如下：</p>
<pre><code>37729 
38982 Launcher
38983 AppMain
38986 Jps
</code></pre><p>其中<strong>AppMain</strong>就是刚才开启的进程pid，现在运行<strong>jstack 38983</strong>，运行结果如下（部分）：</p>
<pre><code>&quot;Block2&quot; #14 prio=5 os_prio=31 tid=0x00007fc65c835000 nid=0x5703 waiting for monitor entry [0x0000700002ba2000]
   java.lang.Thread.State: BLOCKED (on object monitor)
    at com.stephen.ThreadStateTest$Block.run(ThreadStateTest.java:58)
    - waiting to lock &lt;0x00000007956f6ea8&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Block)
    at java.lang.Thread.run(Thread.java:745)

&quot;Block1&quot; #13 prio=5 os_prio=31 tid=0x00007fc65d82a000 nid=0x5503 waiting on condition [0x0000700002a9f000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
    at java.lang.Thread.sleep(Native Method)
    at com.stephen.SleepUtils.sleep(ThreadStateTest.java:10)
    at com.stephen.ThreadStateTest$Block.run(ThreadStateTest.java:58)
    - locked &lt;0x00000007956f6ea8&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Block)
    at java.lang.Thread.run(Thread.java:745)

&quot;WaitingThread&quot; #12 prio=5 os_prio=31 tid=0x00007fc65d82f800 nid=0x5303 in Object.wait() [0x000070000299c000]
   java.lang.Thread.State: WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    - waiting on &lt;0x00000007956f37f0&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Waiting)
    at java.lang.Object.wait(Object.java:502)
    at com.stephen.ThreadStateTest$Waiting.run(ThreadStateTest.java:44)
    - locked &lt;0x00000007956f37f0&gt; (a java.lang.Class for com.stephen.ThreadStateTest$Waiting)
    at java.lang.Thread.run(Thread.java:745)

&quot;PauseThread&quot; #11 prio=5 os_prio=31 tid=0x00007fc65e01e000 nid=0x5103 runnable [0x0000700002899000]
   java.lang.Thread.State: RUNNABLE
    at com.stephen.ThreadStateTest$PauseThread.run(ThreadStateTest.java:33)
    at java.lang.Thread.run(Thread.java:745)

&quot;TimedWaitingThread&quot; #10 prio=5 os_prio=31 tid=0x00007fc65c80e000 nid=0x4f03 waiting on condition [0x0000700002796000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
    at java.lang.Thread.sleep(Native Method)
    at com.stephen.SleepUtils.sleep(ThreadStateTest.java:10)
    at com.stephen.ThreadStateTest$TimeWaitingThread.run(ThreadStateTest.java:23)
    at java.lang.Thread.run(Thread.java:745)
</code></pre><p>现在来逐一解释：</p>
<ul>
<li><strong>Block2</strong>：由于<strong>Block1</strong>已经获得<strong>Block.class</strong>锁，所以此线程处于阻塞状态。</li>
<li><strong>Block1</strong>：此线程不断的进行睡眠，且睡眠操作具有时间限制，因此处在超时等待操作状态。</li>
<li><strong>WaitingThread</strong>：此线程在<strong>Waiting.class</strong>上等待，且没有时间限制，所以处在waiting状态。</li>
<li><strong>PauseThread</strong>：此线程和<strong>TimedWaitingThread</strong>线程达到的效果相同，但是实现的手段不同，没有调用<strong>Thread.sleep(int millionSeconds)</strong>方法，处在<strong>Runnable</strong>状态。</li>
<li><strong>TimedWaitingThread</strong>：此线程不断调用<strong>Thread.sleep(int millionSeconds)</strong>方法，处于超时等待状态。</li>
</ul>
<h1 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h1><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><p>其他线程可以调用另一个线程的<strong>interrupt()</strong>方法来中断线程，可以调用线程的<strong>isInterrupted()</strong>来判断一个线程是否被中断，但是这个方法不总是返回true:</p>
<ul>
<li>当线程终止时，此方法会返回false。</li>
<li>抛出<strong>InterruptedException</strong>的方法，在抛出异常之前，会将标识位设置为false，因此方法也总是返回false。</li>
</ul>
<p>现在用如下程序做出证明：</p>
<pre><code>public class InterruptTest {
    static class SleepThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                SleepUtils.sleep(3000);
            }
        }
    }

    static class NormalThread implements Runnable {
        @Override
        public void run() {
            while (true);
        }
    }

    public static void main(String[] args) {
        Thread sleepThread = new Thread(new SleepThread(), &quot;Sleep&quot;);
        Thread normalThread = new Thread(new NormalThread(), &quot;Normal&quot;);

        sleepThread.start();
        normalThread.start();

        SleepUtils.sleep(2000);

        sleepThread.interrupt();
        normalThread.interrupt();

        System.out.println(&quot;Sleep thread interrupted is &quot; + sleepThread.isInterrupted());
        System.out.println(&quot;Normal thread interrupted is &quot; + normalThread.isInterrupted());
    }
}
</code></pre><p>结果如下：</p>
<pre><code>Sleep thread interrupted is false    
Normal thread interrupted is true
</code></pre><h2 id="设置boolean变量"><a href="#设置boolean变量" class="headerlink" title="设置boolean变量"></a>设置boolean变量</h2><p>还可以设置boolean变量来通知线程的结束，这种方式比上面的<strong>interrupt</strong>方法更为优雅：</p>
<pre><code>public class BooleanFlagThread {
    static class CounterRunnable implements Runnable {
        long i = 0L;
        private volatile boolean isCancelled = false;

        public void cancel() {
            isCancelled = true;
        }

        @Override
        public void run() {
            while (!isCancelled &amp;&amp; !Thread.currentThread().isInterrupted()) {
                i++;
            }
        }
    }

    public static void main(String[] args) {
        CounterRunnable cr = new CounterRunnable();
        Thread countThread = new Thread(cr, &quot;Count&quot;);
        countThread.start();

        SleepUtils.sleep(2000);
        cr.cancel();

        System.out.println(&quot;&quot; + cr.i);
    }
}
</code></pre><h1 id="线程之间的通信：notify-wait"><a href="#线程之间的通信：notify-wait" class="headerlink" title="线程之间的通信：notify(), wait()"></a>线程之间的通信：notify(), wait()</h1><p>线程除了用<strong>synchronized</strong>,<strong>volatile</strong>来进行通信之外，还可以用notify和wait方法，使用这两个方法的前提是某个线程获取了相应对象的锁，典型应用的示例代码如下：</p>
<pre><code>public class NotifyWaitTest {
    static Object lock = new Object();
    static boolean flag = true;

    static class Wait implements Runnable {
        @Override
        public void run() {
            //获取对象的锁
            synchronized (lock) {
                while (flag) { // 2
                    System.out.println(&quot;不满足相应的条件&quot;);
                    try {
                        //进入wait状态，同时释放对象的锁
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(&quot;条件满足&quot;);
            }
        }
    }

    static class Notify implements Runnable {
        @Override
        public void run() {
            //获取对象的锁
            synchronized (lock) {
                if (flag) {
                    flag = false; // 1
                    //通知改变
                    lock.notify();
                }

                System.out.println(&quot;条件已改变&quot;);
            }
        }
    }

    public static void main(String[] args) {
        Thread waitThread = new Thread(new Wait(), &quot;Wait&quot;);
        Thread notifyThread = new Thread(new Notify(), &quot;Notify&quot;);
        waitThread.start();
        //保证wait先执行的方式
        SleepUtils.sleep(2000);
        notifyThread.start();
    }
}
</code></pre><p>输出的结果如下：</p>
<pre><code>不满足相应的条件
条件已改变
条件满足
</code></pre><p>需要注意的是：</p>
<ul>
<li>在调用notify, wait方法之前，要先获得对象的锁。</li>
<li>wait方法，会释放相应的锁。</li>
<li>notify方法会将调用wait的线程从等待队列到同步队列，此时wait线程将从WAITING状态转到BLOCK状态。</li>
<li>只有当notify的线程释放对象锁时，另一个wait线程才会返回继续工作。</li>
<li>notify和wait具有happens-before关系。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/Java内存模型-三/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Stephen Zhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/lion.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stephen's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stephen's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/Java内存模型-三/" itemprop="url">
                  Java内存模型(三)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-13T18:44:31+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/13/Java内存模型-三/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/13/Java内存模型-三/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：</strong>一下部分文字图片来自《Java并发编程的艺术》</p>
<h1 id="双重检查锁解决方案"><a href="#双重检查锁解决方案" class="headerlink" title="双重检查锁解决方案"></a>双重检查锁解决方案</h1><p>Java程序有时需要用到单例模式，通常用延迟初始化的方式实现单例模式，但是只是简单的延迟初始化可能会有线程安全问题，例如：</p>
<pre><code>public class Instance {
    private static Instance instance;

    public static Instance getInstance() {
        if (instance == null) { //1
            instance = new Instance();
        }

        return instance;
    }
}
</code></pre><p>这段代码有很严重的问题，加入两个线程同时处于1操作并且判断instance为空的话，那么instance就会被初始化两次。</p>
<h2 id="synchronized解决方案"><a href="#synchronized解决方案" class="headerlink" title="synchronized解决方案"></a>synchronized解决方案</h2><p>解决上述问题最简单的方法便是用<strong>synchronized</strong>关键字标注<strong>getInstance</strong>方法：</p>
<pre><code>public synchronized static Instance getInstance() {
    if (instance == null) {
        instance = new Instance();
    }

    return instance;
}
</code></pre><p>此方法解决了多线程冲突的问题，但是如果线程太多且<strong>instance</strong>初始化过程太耗时的话，就会转成重量级锁，性能问题随之而来。</p>
<h2 id="双重检查锁定-Double-Checked-Lock"><a href="#双重检查锁定-Double-Checked-Lock" class="headerlink" title="双重检查锁定(Double Checked Lock)"></a>双重检查锁定(Double Checked Lock)</h2><p>为了解决性能的开销，采取了下述办法来解决：</p>
<pre><code>public class Instance {
    private static Instance instance;

    public static Instance getInstance() {
        if (instance == null) { //1
            synchronized (Instance.class) { //2
                if (instance == null) { //3
                    instance = new Instance();
                }
            }
        }

        return instance;
    }
}
</code></pre><p>采用上述办法不能完美地解决问题，出现的问题是返回的引用可能指向一个未被完全正确初始化的对象，下面来分析一下。</p>
<p>假设初始有两个线程A,B同时调用<strong>getInstance</strong>方法，判断instance为空之后开始竞争<strong>Instance</strong>锁，设B线程首先获得了锁，并在成功初始化<strong>instance</strong>对象之后释放锁，此时线程A再获取锁，根据happens-before关系，此时线程A对<strong>instance</strong>对象的改变是可以看到的，因此整个过程只初始化了一次，截止到现在是没有问题的。</p>
<h3 id="对象的初始化过程"><a href="#对象的初始化过程" class="headerlink" title="对象的初始化过程"></a>对象的初始化过程</h3><p>上述办法的问题来自于对象初始化过程的重排序，<strong>instance</strong>初始化可以分成以下三个过程：</p>
<ul>
<li>分配对象的存储空间。</li>
<li>进行初始化。</li>
<li>将对象的地址赋值给引用。</li>
</ul>
<p>问题来自于第二步和第三步的重排序。加入现在有两个线程A,B同时执行，B 先获得了锁先执行，此时A执行到上面的1操作，但是B线程此刻已经把对象地址赋值给了引用，但是并没有正确的初始化（3和1不具备happens-before）关系，此刻A线程读到的<strong>instance</strong>引用是不为空的，但是对象并没有正确的初始化，便即刻将其暴露给外部，问题就出现了。</p>
<h3 id="基于volatile的解决方案"><a href="#基于volatile的解决方案" class="headerlink" title="基于volatile的解决方案"></a>基于volatile的解决方案</h3><p>在<strong>instance</strong>对象前面加上<strong>volatile</strong>关键字可以禁止上述初始化过程的重排序：</p>
<pre><code>public class Instance {
    private volatile static Instance instance;

    public static Instance getInstance() {
        if (instance == null) {
            synchronized (Instance.class) {
                if (instance == null) {
                    instance = new Instance();
                }
            }
        }

        return instance;
    }
}
</code></pre><p><strong>volatile</strong>关键字保证了读取到引用不为空时对象已经被正确地初始化，问题解决。</p>
<h3 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h3><pre><code>public class Instance {
    private static class InstanceHolder {
        private static Instance instance = new Instance();
    }

    public static Instance getInstance() {
        return InstanceHolder.instance;
    }
}
</code></pre><p>此种方法适合包含无参构造函数的类的单例模式，原理如下：</p>
<p>假设有两个线程A,B当两个线程同时开始访问<strong>Instance</strong>类的时候，开始类的初始化，此时JVM将尝试获取<strong>Instance</strong>类上的锁，防止多个线程同时初始化。</p>
<p>假定线程B获取了初始化的锁，当执行完<strong>instance = new Instance()</strong>语句时，释放锁，线程A执行时将会看到已经初始化的<strong>instance</strong>实例并将其返回，初始化过程的重排序对于线程A此时是不可见的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/lion.jpg"
               alt="Stephen Zhang" />
          <p class="site-author-name" itemprop="name">Stephen Zhang</p>
          <p class="site-description motion-element" itemprop="description">Stephen Zhang's notes.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Zhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zsrcodingme"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
